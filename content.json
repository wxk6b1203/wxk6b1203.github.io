{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"improvedNPC一日打码，终生为农 人生如逆旅，我亦是路人。 https://blog.wxk.at 是 wxk6b1203.github.io 的镜像，https://blog.wxk.me 是国内coding page的镜像。","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CLRS滑稽导论 (1) : AVL树","text":"&emsp;&emsp;在二叉树的学习中，我们会接触到很多不同的树。其中，用得最为普遍的，是二叉搜索树。而为提升二叉树搜索的效率，又引入自平衡二叉树的概念。自平衡二叉搜索树是指通过处理可以实现子树相对平衡，即不极端地偏向一边的二叉搜索树。由于相对平衡的特性，树可以实现查询、插入、删除操作在时间上的优化。 &emsp;&emsp;AVL树是最早被构造出来的自平衡二叉搜索树。它的构成比较简单，维护的只有树的高度一个因子。同时，对该因子进行修饰，可以演变成维护树的高差。但是……其实，作者提出了这个模型，但并没有指定某种实现。实现的方法很多，但都是在维护它的定义。可以对每个树高进行记录，也可以用平衡因子的方法来标记偏移方向。这里利用树的高差进行处理。其实绝大多数的说法都是平衡因子，但维护的方式不同。只是实现的不同技巧罢了。 一、定义 AVL树的递归定义是，对于每一个节点的左右子树，他们的高差不超过1。$$x.h = max(x.left.h, x.right.h)+1$$即：$$|h_l-h_r| \\le 1$$这样做的好处是，可以实现树高仅为$O(log\\ n)$ 。那么，查询、插入、删除的时间复杂度都类似地为$O(log\\ n)$。 下面我们来证明时间复杂度应该为$O(log\\ n)$。 如果一棵树是动的，那他的高度就不好处理了。但如果假设是静态的，一切都会好处理得多。我们假设树高为$h$， 则设高为$h$的树的节点数为$N_h$。 我们定义：$N_h$ 是高为 h 的树中所含有最少的节点（$N_h$ is the min number nodes in an tree of high h），同时假设左子树比右子树永远高1。则得出： （1）当高度为常数时，时间、空间复杂度也为常数。即： $$N_{o(1)} = O(1)$$ （2）当树的高度为$h$时， $$N_h = 1 + N_{h-1}+N_{h-2}$$ (3) 我们用它和斐波那契数列进行比较，并利用斐波那契数列的特性进行化简： $$N_h = F_h + 1 (F_h \\ is\\ the \\ Fib\\ sequence)$$ $$N_h &gt; N_{h-1} + N_{h-2} = F_h \\ (F_h \\ is\\ the \\ Fib\\ sequence)$$ 而我们知道，斐波那契数列是指数级增长的函数，$F(n) = O(2^n)$ 依据它的指数边界： $$N_h &gt; F_h = \\frac{\\varphi^h}{\\sqrt{5}} = O(2^n)$$ $$\\lim _{h \\rightarrow \\infty}{N_h} &gt; F_h = \\varphi^h$$ $$log\\ N_h = h$$ that is: $$h = O(log\\ n)$$ 自此，AVL树是平衡树的证明结束。只要他是平衡的，那他的查询(query)、删除(delete)、插入(insert)都是对数时间复杂度的。 然后，我们来一步步用最基础的方式实现它既然为二叉搜索树，那么他的搜索过程和普通的搜索树是一样的。作为平衡树，他的关键点在于他的插入与删除。因为插入与删除会改变树的形态。所以，这里我们只描述插入与删除。查询部分，请参阅CLRS v3的第12章。 首先，我们开始构造一棵树。树的节点要有如下的关键词：左子树、右子树、亲代的指针，树高的平衡因子，节点的权值。树要包含有根节点，空节点（为了方便实现与保护不越界）。 一个直观的演示：位于visualgo的链接 (要手动调到AVL🌲部分) 12345678910111213141516171819struct node { int key; // Key int avlK; // load balance factor node *left, *right, *p;// respective pointers node() : key(0), avlK(0), left(NULL), right(NULL), p(NULL) {} node(int key, int level = 0) : key(key), avlK(level), left(NULL), right(NULL), p(NULL) {}};struct AVLtree { node *root; node *nil; AVLtree() { nil = new node(-1, -1); root = nil; nil-&gt;right = nil; nil-&gt;left = nil; }}; 同时，我们需要一些公用的函数：123456789101112131415161718int max(int a, int b) { return a &gt; b ? a : b; }int inOrder(AVLtree &amp;T, node *x) { if (x != T.nil) { inOrder(T, x-&gt;left); printf(\"%d : %d\\n\", x-&gt;key, x-&gt;avlK); inOrder(T, x-&gt;right); } return 1;}node *getMinPointer(AVLtree &amp;T, node *x) { node *t = x; while (t-&gt;left != T.nil) { t = t-&gt;left; } return t;} 然后我们来定义旋转。 旋转是为了降低树的高度，以达到平衡局部的需求。平衡树中的关键步骤都是与旋转有关。旋转包括左旋和右旋，两种方法是对称的。同时，由于AVL树中平衡因子的特性，我们需要修饰旋转后节点的平衡因子。对于AVL树来说，他的平衡可以用平衡因子来调控。 而这里平衡因子的维护方法是，$ v.h = max(v.left.h,\\ v.right.h)+1 $。所以，它左右子树高差差区间为$[-2, 2]$。如果恰好遇到有些节点abs(x) == 2，则证明，树的高度需要调节。于是乎通过旋转来达到目的。 以下是旋转部分的代码：（和CLRS v3红黑树的旋转~几乎无异~没有差别） 1234567891011121314151617181920// This is the left version. Reverse the direction will be the right version.int leftRotate(AVLtree &amp;T, node *x) { node *y = x-&gt;right; x-&gt;right = y-&gt;left; if (y-&gt;left != T.nil) { y-&gt;left-&gt;p = x; } y-&gt;p = x-&gt;p; if (x-&gt;p == T.nil) { T.root = y; } else if (x == x-&gt;p-&gt;left) { x-&gt;p-&gt;left = y; } else { x-&gt;p-&gt;right = y; } y-&gt;left = x; x-&gt;p = y; return 1;} 右旋：（其实差不多的，就是左旋的逆） 12345678910111213141516171819int rightRotate(AVLtree &amp;T, node *x) { node *y = x-&gt;left; x-&gt;left = y-&gt;right; if (y-&gt;right != T.nil) { y-&gt;right-&gt;p = x; } y-&gt;p = x-&gt;p; if (x-&gt;p == T.nil) { T.root = y; } else if (x == x-&gt;p-&gt;right) { x-&gt;p-&gt;right = y; } else { x-&gt;p-&gt;left = y; } y-&gt;right = x; x-&gt;p = y; return 1;} 然后处理插入部分。插入部分的开始跟普通二叉搜索树一致，只不过到了插入完毕以后，要向后轮询其平衡因子以修正树的平衡性。 123456789101112131415161718192021222324252627282930313233343536/** * Procedure Insert: * TODO: insert the target node into one tree. * param: * T: the target tree * ins: the node to be inserted */int Insert(AVLtree &amp;T, node *ins) { // y: trace x's parent; // x: trace y's parent; node *x, *y; // initalize x, y y = T.nil; x = T.root; while (x != T.nil) { // trace the pos y = x; if (ins-&gt;key &lt; x-&gt;key) { x = x-&gt;left; } else x = x-&gt;right; } // Go as routinue; ins-&gt;p = y; // Bind its parent if (y == T.nil) { // Case of only one node T.root = ins; y = T.root; } else if (ins-&gt;key &lt; y-&gt;key) { y-&gt;left = ins; } else { y-&gt;right = ins; } ins-&gt;left = T.nil; ins-&gt;right = T.nil; insertFix(T, ins); // Invoke the fix procedure. return 0; // Status code. Just persional convention.} &emsp;&emsp;上面的第34行，转到了修正树的结构的部分。插入之后，树可能遇到平衡问题：左子树比右子树高2（反过来亦然），这样就打破了树的平衡性。可能的情况如下图： 又如： 那么，我们就通过向上追溯平衡因子，进而旋转使之平衡。 对于第一种，我们采用这样的方式： 然后，我们又发现，第二种情况可以转换变成第一种。 嗯。很好。多节点的时候，其实也是相近的。 这里最困难的地方在于维护平衡因子。既要是其正确表达当前状态下倾斜的方向，又要对相应节点进行旋转。 所以我们来fix它。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int insertFix(AVLtree &amp;T, node *x) { // 务必要小心 bool Flag = 0; node *z = NULL; int highTmp = 0; node *y = NULL; while (x != T.root) { Flag = 0; y = x-&gt;p; highTmp++; if (highTmp &gt; y-&gt;avlK) { y-&gt;avlK = highTmp; } if (y-&gt;left-&gt;avlK - y-&gt;right-&gt;avlK &gt;= 2) { Flag = 1; if (x-&gt;right-&gt;avlK &gt; x-&gt;left-&gt;avlK) { leftRotate(T, x); x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; y-&gt;avlK = max(y-&gt;left-&gt;avlK, y-&gt;right-&gt;avlK) + 1; x = y-&gt;left; } rightRotate(T, y); y-&gt;avlK = max(y-&gt;left-&gt;avlK, y-&gt;right-&gt;avlK) + 1; x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; // DO Sth } else if (y-&gt;right-&gt;avlK - y-&gt;left-&gt;avlK &gt;= 2) { Flag = 1; if (x-&gt;left-&gt;avlK &gt; x-&gt;right-&gt;avlK) { rightRotate(T, x); x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; y-&gt;avlK = max(y-&gt;left-&gt;avlK, y-&gt;right-&gt;avlK) + 1; x = y-&gt;right; } leftRotate(T, y); y-&gt;avlK = max(y-&gt;left-&gt;avlK, y-&gt;right-&gt;avlK) + 1; x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; } highTmp = Flag ? x-&gt;avlK : highTmp; if (x == T.root) { break; } x = x-&gt;p; } return 1;} 这就。。Fix完了。233 然后就是delete部分，参考红黑树的实现&emsp;&emsp;delete部分其实是插入的逆。首先使用正常的二叉搜索树插入，然后再从被抽取的位置开始对其进行fix。&emsp;&emsp;贴代码：1234567891011121314151617181920212223242526272829303132333435/** * Procedure: AVL_Delete * @param T : AVLtree &amp; * @param z : node * * @return : int */// Now is part of original RB-deletevoid AVL_Delete(AVLtree &amp;T, node *z) { node *x; node *y = z; int yAVLK = z-&gt;avlK; if (z-&gt;left == T.nil) { x = z-&gt;right; AVL_Transplant(T, z, z-&gt;right); } else if (z-&gt;right == T.nil) { x = z-&gt;left; AVL_Transplant(T, z, z-&gt;left); } else { y = getMinPointer(T, z-&gt;right); x = y-&gt;right; // Get the right next pointer &amp; ready to transplant if (y-&gt;p == z) { // If y &amp; z are adjacant x-&gt;p = y; } else { AVL_Transplant(T, y, y-&gt;right); y-&gt;right = z-&gt;right; y-&gt;right-&gt;p = y; } AVL_Transplant(T, z, y); y-&gt;left = z-&gt;left; y-&gt;left-&gt;p = y; y-&gt;avlK = z-&gt;avlK; } AVLDeleteFix(T, x);} 同样地，从被削减的那个点开始修复。逐步向上更新🌲高。123456789101112131415161718192021222324252627282930313233void AVLDeleteFix(AVLtree &amp;T, node *x) { int highFix = x-&gt;avlK; node *y; do { y = x; x = x-&gt;p; x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; if (x-&gt;left-&gt;avlK - x-&gt;right-&gt;avlK &gt;= 2) { if (y-&gt;right-&gt;avlK &gt; y-&gt;left-&gt;avlK) { leftRotate(T, y); y-&gt;avlK = max(y-&gt;left-&gt;avlK, y-&gt;right-&gt;avlK) + 1; x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; y = x-&gt;left; } rightRotate(T, x); x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; y-&gt;avlK = max(y-&gt;left-&gt;avlK, y-&gt;right-&gt;avlK) + 1; x = x-&gt;p; // update pointer } else if (x-&gt;right-&gt;avlK - x-&gt;left-&gt;avlK &gt;= 2) { if (y-&gt;left-&gt;avlK &gt; y-&gt;right-&gt;avlK) { rightRotate(T, y); y-&gt;avlK = max(y-&gt;right-&gt;avlK, y-&gt;left-&gt;avlK) + 1; x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; y = x-&gt;right; } leftRotate(T, x); x-&gt;avlK = max(x-&gt;left-&gt;avlK, x-&gt;right-&gt;avlK) + 1; y-&gt;avlK = max(y-&gt;left-&gt;avlK, y-&gt;right-&gt;avlK) + 1; x = x-&gt;p; // update pointer } } while (x != T.root);} &emsp;&emsp;删除的fix和插入的fix几乎一致，不断向上搜索，更新avl平衡因子，遇到过度倾斜的时候就立刻修复。 ～完啦！～转载请联系作者","link":"/2017/09/01/AVL-Tree/"},{"title":"CS: APP 官方的勘误","text":"第三版的CS:APP有很多细节问题。特别日前看到的第三章。不过国内的出版社有进行勘误，尽管还是没有完全地查出来。 (尽管都是细节问题，但也是应该检查正确才行。) Despite our best efforts to create a book with zero defects, our vigilant readers have pointed out some bugs. Please report any new errata to Randy Bryant and Dave O’Hallaron. Note that some of these errors have been corrected in more recent printings. There are a number of mistakes made by the authors in CS: APP. Here is the link to official errata webside: CMU勘误的地址 抽取其中的一部分（第三章）： p. 171, second-to-last line. 248 is 256 terabytes, not 64 terabytes.Posted 09/09/2016. Don Bagert p. 174, code annotation at top of page. It should read “Disassembly of function multstorein binary file mstore.o.”Posted 10/25/2015. Shoeb Mohammed p. 175, code annotation in middle of page. It should read “Disassembly of function multstore in binary file prog.”Posted 10/25/2015. Shoeb Mohammed p. 177, aside “ATT versus Intel assembly-code formats,” last sentence of first paragraph. The assembly code shown is for the function multstore, not sum.Posted 11/09/2015. Shoeb Mohammed p. 179, Section 3.4, first paragraph. The ranges given for the eight named registers for the three different instruction sets are incorrect. They should be: For 8086: %ax through %sp. For IA32: %eax through %esp. For x86-64: %rax through %rsp. Posted 07/19/2017. Yili Gong p. 183, sample code near bottom of page, line 4. The code should be “movb $-17, (%rsp).”Posted 10/24/2015. Jason Waterman p. 188, aside “Some examples of pointers,” call to printf. The format string should be “a = %ld, b = %ld\\n”.Posted 11/09/2015. Shoeb Mohammed p. 191, second full paragraph. The first sentence should state: “The third column of Figure 3.9 illustrates the effect of executing the instruction popq %rdx …”Posted 09/28/2015. Max Ma p. 191, fourth line of paragraph that begins “The third column of Figure 3 …” It should state that the value 0x123 remains at memory location 0x100.Posted 11/09/2015. Carlos Galdino p. 198, first line of first full paragraph. There should be a period after the word “forms”.Posted 09/19/2016. Anise Ghorbani p. 199, third full paragraph. The reference to instruction idivl should be to idivqinstead.Posted 02/21/2017. Changan Wang p. 199, fourth full paragraph. The paragraph should start with “For most applications of 64-bit division …”Posted 09/19/2015. Xingda Zhai p. 200, first line of text. It should state “In this code, argument qp must first be saved in a different register (line 2), …”Posted 08/16/2015. Dmitry Neverov p. 204, Practice Problem 3.13, second paragraph. It should state “Suppose a is in some portion of %rdi while …”Posted 10/15/2015. Ronald Greenberg p. 205, Practice Problem 3.13, code for D. The second instruction should be “setne %al.”Posted 11/09/2015. Carlos Galdino p. 214, third paragraph. The second sentence should be “The function computes the absolute value of the difference of its two arguments x and y, …”Posted 11/11/2015. Yili Gong p. 214, Figure 3.17(c). The comment on line 8 of the code should state “Return rval”.Posted 03/18/2017. p. 218, assembly code for cread. In the annotations for lines 3 and 5, “x” should be “xp”.Posted 11/19/2015. Vlad Buslov p. 226, last sentence before Practice Problem 3.25. It should state “The compiler has determined that the loop can only be entered when n &gt; 1, and that, as n is decremented, it will reach value 1 before reaching a value less than 1.”Posted 06/11/2017. Daniel O’Brien p. 234, first and second lines of text. They should state “ … indexed by register %rsi, which holds … ”Posted 09/02/2015. Dmitry Neverov p. 235, Figure 3.23, annotation for line 5 of code. It should state “Goto jt[index].” Posted 12/25/2015. Xinzhen Chen* p. 238, Problem 3.31, Comments in assembly code at top of page. The register allocation is listed incorrectly. It should state “a in %rdi, b in %rsi, c in %rdx, dest in %rcx.”Posted 07/25/2015. Yu Zhong and Carlos Galdino p. 241, fourth and fifth lines. They should state “Procedure P can pass up to six integral values (i.e., pointers and integers) in registers … ”Posted 09/02/2015. Dmitry Neverov p. 243, Figure 3.27a, line 2. The annotation should state “L1: y+2.”Posted 02/15/2016. Xinzhen Chen p. 244, first full paragraph. The value 0x400054e should be 0x40054e.Posted 07/26/2017. Daniel O’Brien p. 244, second full paragraph. The value 0x4000560 should be 0x400560.Posted 07/26/2017. Daniel O’Brien p. 244, Comment after line 4. It should state “Disassembly of first(long x)”Posted 09/02/2015. Dmitry Neverov p. 249, Fourth line from bottom. Sentence ending “… and 17 (s3).” should be “… and 17 (x4).”Posted 11/29/2016. Hyun Chun p. 252, Practice Problem 3.34. The first two sentences should state “Consider a function P, which generates local values, named a0–a7. It then calls function Q, which has no arguments.”Posted 11/23/2015. Vlad Buslov p. 257, Table near the bottom of the page. The assembly code for the first entry should be “movq %rdx,%rax.”Posted 10/03/2015. Zhiwei Xin p. 259, Figure 3.36 The fourth block from the bottom should have the label A[3][2].Posted 04/04/2017. Dean Kajmakci p. 259, assembly code in middle of page, line 3. The annotation should state: “Read from M[xA + 12i + 4j].”Posted 10/25/2015. Karan Dwivedi p. 263, assembly code in middle of page, line 3. There is a missing ‘)’ at the end of the annotation.Posted 02/11/2016. Elizabeth White p. 264, Annotations of last block of assembly code. It should state that j is in register %rdx.Posted 07/26/2017. Daniel O’Brien p. 266, middle of page. The declaration and initialization of r should be:struct rect r = { 0, 0, 10, 20, 0xFF00FF };Posted 08/04/2015. Yu Zhong p. 277, first bullet, second and third lines after declarations. They should state “… if the object has type T, then the pointer has type T .” Posted 09/02/2015. Dmitry Neverov* p. 281, Figure 3.40. The first sentence of the caption should read “Character array buf is just below part of the saved state.”Posted 12/01/2015. Yili Gong p. 282, Practice Problem 3.46, second paragraph. It should state that get_line is called with return address 0x400076.Posted 11/23/2015. Vlad Buslov p. 284, Practice Problem 3.46, part E. The question for ask for three things wrong with the code.Posted 07/26/2017. Daniel O’Brien p. 293, Practice Problem 3.49, second paragraph. The text should state: “… there may be an offset of e2 bytes between the values of s2 and p.”Posted 11/09/2015. Shoeb Mohammed p. 295, Figure 3.45. The lower 128 bits of register %ymm13 should be labeled %xmm13.Posted 10/28/2015. David Hirschv p. 300, Problem 3.51, second line. The return value has type “dest_t.”Posted 10/13/2016. Anise Ghorbani p. 313, Problem 3.60, first line of code. Argument n should be declared as being of type int.Posted 07/21/2015. Lauren Cooper p. 326, Solution to Problem 3.3, fifth line of code. The code should be movq %rax, $0x123to be consistent with the problem statement, although both versions have the same error.Posted 06/02/2015. Zhi Li p. 326, Solution to Problem 3.3, sixth line of code. The code should be movl %eax, %rdxto be consistent with the problem statement, although both versions have the same error.Posted 09/02/2015. Elizabeth White p. 330, Solution to Problem 3.14D. The comparison is for &lt;=.Posted 08/16/2015. Dmitry Neverov p. 331, Solutions to Problems 3.15B and 3.15D. The values starting with “0x0x” should start with “0x” instead.Posted 12/04/2015. Carlos Galdino and Yili Gong p. 333, Solution to Problem 3.20. The comment on the third line of code should read “Test x”.Posted 06/02/2015. Curtis Gagliardi p. 338, Solution to Problem 3.30, third bullet. The final sentence should say “Thus, case labels 3 and 6 are missing in the switch statement body.”Posted 09/27/2015. Xinyun Zhao p. 339, Solution to Problem 3.32, line labeled “F4”. The instruction should be “repz retq.”Posted 10/13/2016. Wenjun Huang p. 346, Solution to Problem 3.46C. The program is attempting to return to address 0x400034, not 0x040034.Posted 10/24/2016. Wenjun Huang p. 347, Solution to Problem 3.47E. In addition, the program should test the value returned by gets to make sure it’s not NULL.Posted 07/26/2017. Daniel O’Brien p. 348, Solution to Problem 3.51. In the third entry of the table, the conversion is from double to float, as is requested in the problem statement.Posted 08/09/2015. Yu Zhong p. 349, Solution to Problem 3.53, last paragraph of text. The ambiguity arises from the commutativity of addition, not multiplication.Posted 11/09/2015. Shoeb Mohammed","link":"/2017/08/10/CS-APP-errata/"},{"title":"LeetCode 43 - 大数乘法","text":"模拟算乘法，实现大整数乘法。仅限整数，负数要加点判断条件。 这个方法虽然不是最快的，但比较好理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { public String multiply(String num1, String num2) { // trivial case if (num1.equals(\"0\") || num2.equals(\"0\")) { return \"0\"; } if (num1.equals(\"1\")) return num2; if (num2.equals(\"1\")) return num1; // method call optimition int len1 = num1.length(); int len2 = num2.length(); // target result; int[] res = new int[len1 + len2]; for (int i = len1 - 1; i &gt;= 0; i--) { for (int j = len2 - 1; j &gt;= 0; j--) { // multiply single numbers int tmp = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); // len - i - 1 means indentation // add up two single num res[(len1 - i - 1) + len2 - j - 1] += tmp % 10; // carry int add = res[(len1 - i - 1) + len2 - j - 1] / 10; res[(len1 - i - 1) + len2 - j - 1] %= 10; res[(len1 - i - 1) + len2 - j] += add; res[(len1 - i - 1) + len2 - j] += tmp / 10; } } int fin = res.length - 1; while (res[fin] == 0) fin--; StringBuilder sb = new StringBuilder(); // reverse order to append as string while (fin &gt;= 0) { sb.append((char) (res[fin--] + '0')); } return sb.toString(); }}","link":"/2020/03/05/big_num_mul/"},{"title":"Red Black Tree (Draft)","text":"本文处于草稿中。。。 定义：红黑树利用特征标记决定高度的自平衡二叉搜索树，具有额外的数据决定其节点为黑或红节点。每一条从单一节点到叶子结点的路径都有相同数目的黑色节点。利用此特性，保持树高为$O(lg\\ n)$。 pre：平衡树：空树或其左右两个子树高度差相对小的二叉搜索树。 正确性特性： 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径)都包含相同数目的黑色节点。 为便于实现且解决边界问题，利用单一 $T.nil$ 节点作为空节点，并且将类似于原始二叉搜索树中的空指针指向$T.nil$。$T.nil$可以作为辅助节点，为后续插入删除做辅助。 每个节点包含：color, key, right, left, p指针。 解释： 性质2保证了根节点为黑色，但并不是必须的。（ex13.1-3）保证红色节点不可连续，而且单一路径黑节点数目相同，树就可以实现平衡。 NIL节点实现了，所有的有数据节点都为内部节点。 性质4决定了红色节点不可连续，但对于黑色节点没有限制。只要树的简单路径黑节点数目相同，就保证了4的正确性。 这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。（ex13.1-5) 说明：假设单一路径中全部节点为黑色，由性质4，另一单一路径的全部节点最多为红黑相间。因此不可以超过两倍。 树高的证明 根据性质4，5，定义辅助函数“树的黑高” $bh(x)$ 。利用说明任何以 $x$ 为跟的红黑树都有至少 $2^{bh(x)}-1$ 个内部节点。 证明：数学归纳法 设：根为x的树高为h。 $x=0​$ 时， $2^{bh(x)}-1=0​$ ； 假设x为根的树有2个子代，则：取决于当前子树的子代为黑或者红，黑高为bh(x) 或者 bh(x)-1; // 这句有啥意义？ 假设 $x’=x-1$ 黑高为 $2^{bh(x’)}-1$ 成立，则： $\\because x’=x$ 时： 减去根的黑节点，左右子树：$h’=2^{bh(x)-1}-1$, $\\therefore 2h’+1=2^{bh(x)}-1$ (1)","link":"/2017/08/09/Red-Black-Tree/"},{"title":"《华伦夫人的职业》中价值忽视与压迫下的道德缺失与伦理疑难探讨","text":"【摘要】《华伦夫人的职业》是萧伯纳具有代表性的“问题剧”。剧本借助华伦夫人之女儿薇薇与其以及众人斗争的情节，揭露了19世纪末的资本主义社会下人普遍面临的价值缺失与价值压迫导致的伦理缺失与破坏问题。其中，道德的对抗围绕华伦夫人的卖淫生涯展开。本文根据剧本，对其中的道德伦理问题进行了探讨。 【关键词】华伦夫人的职业，价值压迫，道德低位，伦理疑难 &emsp;&emsp;《华伦夫人的职业》是萧伯纳非常经典的“问题剧”，是从家庭到社会诸多层面上对道德伦理问题的探讨。尽管剧本的情节线始终围绕着华伦夫人卖淫、当妓院老板的职业进行争论，情节冲突也围绕着华伦夫人和她的女儿薇薇展开，但价值与道德的冲突与对抗包括但不限于对卖淫的批判。社会的价值无视与价值压迫对全体人员都是具有决定性的。“在维多利亚时代，大不列颠的经济和社会发生了巨大的变化，其中最为突出的便是中产阶级人群的增长。但这繁忙的表面现象始终无法覆盖资本家的错误与伪善。”( 杨佳宁 18 ) &emsp;&emsp;萧伯纳曾经说过，“（写此剧本）是为了叙述卖淫为职的真相。它的产生不是因为女人的放荡不羁或男人的荒淫无度，而只是因为过低的报酬，价值的无视和过度的工作逼迫女人不得不从事性工作来把握她的身体和灵魂”(Powell, Kerry 229)。 而这种低估与压迫正是矛盾的华伦夫人悲剧的源头。家庭伦理受到破坏，社会道德地位倾斜，最后尽管依然有反省与忏悔的道德残余，但也只是手中嘴上的玩物。一个女人沉迷于金钱美色，害怕于贫穷受困，为力量无穷的社会所压迫，她就再也不会想解决这些道德的矛盾，宁可痛苦，宁可家庭分崩离析，宁可堕入万劫不复的深渊。 &emsp;&emsp;对贫穷的恐惧，对富贵的追求，是伦理疑难最初的问题。对于华伦夫人，最初始的层面便是金钱。由始至终，为了金钱，华伦夫人的选择都是受迫的。最初的困处在于贫穷与困苦。面对薇薇的质疑，华伦夫人称，自己的生活方式是不可选择的。最初的她“在酒吧端酒洗杯子，每天工作十四个小时，一个星期挣4个先令”，饱受贫穷的折磨。后来遇上了她的姐姐莉齐，走上了卖淫为生的道路。莉齐呵斥她称，“你在这里干什么，你这小傻瓜？累坏了身子，糟蹋了脸子，替别人赚钱！” 然而，如果她不选择这样的生活，她可能“死于铅中毒”，可能替人擦地板，最后进入济贫院，可能嫁给他人，相夫教子，成为永远受穷的“废物女人”。社会的不公平对待是无情而冷酷的，对她就是一种压迫，对人性就是一种泯灭。人的价值被削弱，工作显得一文不值。于是她选择了成为性工作者。尽管是社会中道德地位的低下者，却能保证自己的生活。她的个人意志便是摆脱贫穷，走向上流社会。这样的驱动是直观而有力的，促使人选择了逃离贫困，处于永远处于道德低位和伦理矛盾的人生道路。 &emsp;&emsp;忽视价值，金钱至上，泯灭人性，是那个年代所持有的社会风气与状态。作为处于弱势，却要维护所谓的“正统礼节”的女性，就更加难以得到足够高的社会地位。对被忽视、被歧视，处于贫穷的恐惧始终贯穿着华伦夫人的一生。以至于后来她成为妓院老板，成为内心恐惧的大量资产的占有者，直到最后即便想和薇薇和好也还不肯放弃手中的肮脏的工作。即便是成为贵妇，也不肯放下手中的东西。贫穷太可怕，对女人的价值忽视太可怕。然而，这种压迫不仅仅作用于女人。男人也利用着这种风潮积攒自己的财富，提高自己的地位。科洛夫茨与华伦夫人狼狈为奸，弗兰克因觊觎华伦夫人的财产而追求薇薇，得知薇薇与其决裂后果断全身而退。社会性的金钱压迫使得人完全变了样。 &emsp;&emsp;家庭的道德地位与伦理选择之难是随之而来的问题。在金钱问题之后，便是家庭道德困境。这也是萧伯纳把社会各阶层面临的道德问题所汇聚起来的核心 (Dierkes-Thrun, Petra 293)。也对于薇薇，以及自己不完整的家庭，华伦夫人的态度是严谨的。她把培养成剑桥大学的高材生，给予了许多的重视——尽管是从旧思想层面得来的重视，把她当作小孩子，希望得到孩子的赞同和同情。尽管孩子有个亵渎她的神职的父亲，这是一个令华伦夫人不满意的地方。但对于塞缪尔牧师，“她从来没有用那种力量，没有引起我片刻的不安。” 然而她始终逃不过一个事实，她是一个“道德上的弱势者”，她的女儿也因此成为了“道德弱势者的女儿”。这样的伦理身份让华伦夫人矛盾，也让薇薇矛盾。这也使得薇薇知道她母亲继续这样的工作之后，她颜面大变，再也不相信华伦夫人，对她完全失去了信心。 &emsp;&emsp;华伦夫人始终带有着一个旧时代女性的灵魂。看待她的女儿，她也始终用着旧时代的眼光。然而，薇薇却有着完全不一样的人生感悟与社会思考。道德的低位，金钱的胁迫，在其母亲看来都是无法接受的事物。当一个旧时代的母亲对新时代的女儿有着桎梏一般的贪图和祈求，希望能利用自己所谓的养育之恩来达到争取获得认同的时候，冲突一定是激烈而惨淡的。一方面希望女儿成为新女性，另一方面又希望新女性认同与拥护守旧的自己，再加上原本处于道德低位的家庭，这样的结局不难预料。相反，由于她的隐忍和恪守，加上塞缪尔牧师自身所处的伦理弱势，她取得了塞缪尔牧师的尊敬与宽容，尽管可能并不能让她满足。价值压迫与忽视在此体现得最直接的就在于，女性，或者说人由于忽视而变得廉价，个人的伦理道德也被社会整体性地无视。没有金钱，就无法让薇薇有较高的造诣；如果不为了金钱，恪守家庭准则，那她们也将沦落社会的最底层，也不会有薇薇的觉悟。金钱体现了人所有的价值，甚至畸形地构建了家庭伦理的基石。 &emsp;&emsp;每个家庭都是构成社会的一个元素，而社会又反作用与每一个家庭。社会伦理的偏差在剧中充当了典型的社会环境中重要的角色。当社会确实是这样运作的时候，每个人都是社会的一颗齿轮，尽管它可以不知道自己充当的低位，但它确实运作着，推动着整个社会风潮的发展。即便是薇薇，也是逃不过这样的局面。随着第二次工业革命的进行，资本成为社会的驱动力，每个人都投身其中，不管愿意与否。科洛夫茨为寻求暴利，与华伦夫人合作，甚至以此要求将薇薇嫁给他；而华伦夫人尽管对他充满痛恨，并给予激烈的回复，但兴许是并没有在行动上有所反应；弗兰克也是年轻人中“好于钱色”的代表；而薇薇上学的钱，学校建设的经费，很多也是来自充满罪恶的资本家的捐助。这是一个基于资本的整体。而其实，以薇薇为代表的新兴者只是社会马车中极小的一部分。他们保证了自己的生存，甚至努力改变着社会的运作方式。但他们非常细小。作为社会新思潮的开拓者，可能面临各种风险。 &emsp;&emsp;在故事即将结束的时候，无奈的华伦夫人甚至问了一句，“你知道我有多富吗?”。这句既讽刺又带有几分绝望的哀嚎十分生动而震撼，把薇薇和她二人的冲突带到了不可挽回的地步。从功利主义的层面来讲，华伦夫人投入可能想得到薇薇的认同，实现二人最大的利益。但更深层次，无意识到的，是试图把她的顾虑，她旧有的气息，她的对社会绝望与恐惧带给她。既是寻求可怜，也是希望得到分担。“我的用心没有什么不对，你就是不懂得我的好心好意。” 然而，几乎每一个人都是为了利益而相互结交，华伦夫人的圈子更是如此。兴许，她的心意也是如此罢。没有所谓的价值认同，有的只是人格的轻视。从这个角度上说，华伦夫人是非常孤立，非常无助的。他的女儿成为了唯一可能有的心灵支柱。此时，好梦碎裂，斗争结束。社会是绝情的。问题剧结尾展现给我们的正是资本主义社会已成为一个无纯洁与正义可言的肮脏泥潭 。(易晓明 8) &emsp;&emsp;维多利亚时代是英国历史上的黄金时期，责任、礼节和个人道德取向被视为道德观念的核心。然而，这些堂而皇之的“绅士”、“贵妇”的背后却隐藏着许多黑暗的角落，例如贫穷，性交易，赌博等。当一个妇女面临贫穷及痛苦与把自己当作东西买出去的选择时，她的行为已经难以判断是否道德( 杨佳宁 53 )。同时，正因为有华伦夫人为代表的贫穷女性牺牲，才有薇薇对社会的发现，以及自身的道德觉悟；正是有了薇薇的“背叛”，才会有社会整体性的价值发现与革命性的道德发觉。长江后浪推前浪，这是进化论的必然选择。 &emsp;&emsp;许多的评论认为，造成这样的社会压迫，对人贬低与无视，并把道德放在暗地里的，全因为资本主义的不公与罪恶。这似乎很有道理。在文中，科洛夫茨甚至说，“你要是这么拿道德标准选择朋友，你只有离开英国。” 然而，我却不完全这般认为。若放低复杂的政治因素，社会的价值取向与道德偏好是和社会创造力息息相关。要构建一个完整的道德体系，除了要将生产力提高以外，还需要基于当下生产力的道德自觉和文化发展。薇薇等“新人”的出现，正是对社会的跟进与改造，这其中是需要有很多的突破甚至牺牲的。然而这并不同于“破四旧”一般的改造，这是文化自觉导致，而非纯粹为了革命而革命。人的素质没有得到提高而提出所谓的”打破旧俗”，那就是横生灾难，伺机报复。社会整体地对女性进行价值贬低和价值压迫，很多时候是在整个客观的经济体中有着必然的需求。尽管这确实罪恶，却是社会发展中无法避免的过程，无可避免的“发展中”的生活逻辑。不公与罪恶始终是较小的一部分。萧伯纳在道德评价与历史评价之间没有表现出自己直接的见解, 而只是客观地再现了由两种不同的生活逻辑所构成 的生活内容。因而应该说，萧伯纳是在整个社会与人类历史中确认人类的位置、个体的位置，关注人的处境、揭示人存在的现状的。这正是萧伯纳的情感之所在( 易晓明 8 )。 &emsp;&emsp;贫穷与低下的社会地位把华伦夫人逼上了娼妓的道路，在这样的生计下，她成为了贵妇，进入了上流社会，每日享受着荣华富贵。然而，她的选择所造就的道德低位再一次把她放到了社会的低位，社会道德与社会伦理的低位。从金钱价值的低位跳到了道德价值的低位，她始终没有逃离社会的压迫，始终没有逃脱个人价值的贬低与无视的命运。她的人生充满了伦理的疑难。从家庭到社会，从自身到他人，她的选择一直都无法摆脱社会价值确实所带来的伦理疑难。这样的处境使得她注定是社会过渡发展中被海浪淹没的沙子，尽管有自己的作用，但看上去却十分地微小。这就是萧伯纳在对当时人类历史所处位置的状态进行的描绘。包括华伦夫人的“相似者”，弗兰克，科洛夫茨，无疑也都是时代的映照。 &emsp;&emsp;尼采曾经说过，人之伟大，在于它是桥梁而不是目的；人之可爱，在于它是过渡与总结。在社会价值不断发展的过程中，道德与伦理会被不断更新，不断修正，不断稳固。每个人都将会有更多的社会机遇。而《华伦夫人的职业》给我们展示的，便是曾经的不公，曾经的压迫与忽视，曾经的疑难与困惑。这种人类发展过程中的自我审视与反思将会推动人类社会文明的发展，将世界变得更加和谐，更加美好，更加温暖，更加充满希望。 Work cited Dierkes-Thrun and Petra. “Incest and the Trafficking of Women in Mrs. Warren’s Profession: ‘It Runs in the Family’ “ English Literature in Transition, 1880-1920, 2006: 293-310. Print. 尼采：《查拉图斯特拉如是说》，黄敬甫、李柳明译，中华书局，2013年 Powell, Kerry. The Cambridge companion to Victorian and Edwardian theatre. Cambridge University Press, 2004. Print. 萧伯纳：《华伦夫人的职业》，《华伦夫人的职业——萧伯纳剧作选》，贺哈定、吴晓园译，上海：上海译文出版社，2006年，第103 -182页。 杨佳宁:《〈华伦夫人的职业〉的文学伦理学批评解读》，哈尔滨师范大学，2016年。 易晓明：《从问题剧看萧伯纳的思想倾向》，《外国文学评论》1999年02期，第8页。","link":"/2017/08/09/华伦夫人的职业作业/"},{"title":"LeetCode - 二分查找","text":"“90%的程序员不能写出正确的二分查找” – 不是我说的 二分查找及其变种有很多种形式，例如查找第一个出现的、查找出现的区间，等。但都不能脱离一个宗旨：每次查找都要有下标的更迭。 一个经典的二分查找的错误是，出现了下标分别处在了i和i+1，而却判断nums[l] &lt; nums[mid] ? l = mid : r = mid。（这里是不规范的写法）。这会可能导致产生一个死循环，因为，(i + i + 1) // 2 = i。如果第一个判断条件被命中，则永远循环在了那儿。 另外一个不恰当的做法是，判断两边的值，进而判断是否到了边界，然后判断mid值。这种做法可能导致的错误是，l == i, r == i + 1 时，我的mid又要被判断了一次。这种做法是比较冗余的，而且可能导致insidious bug。 基本正确做法是，12345678910111213141516171819bool bin_search(vector&lt;int&gt;&amp; nums, int target) /* 判断是否存在，且数值不重复的情况 */{ int l = 0, r = nums.size() -1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] &lt; target) /* target在 mid左边 */ { l = mid + 1; } else /* 因为 (i + i + 1) // 2 -&gt; i, r = mid就行了 */ { r = mid; } } return nums[l] == target;} 一些变种： 数值存在，找边界：1234567891011121314151617181920212223242526272829303132333435363738/* LeetCode p34 */class Solution { public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { if (nums.size() == 0) return vector&lt;int&gt;{-1, -1}; int l = 0, r = nums.size() - 1, mid; int i = l, j = r; /* 找小边界 */ while (j &gt; l) { mid = (j + l) / 2; if (nums[mid] &lt; target) { l = mid + 1; } else { j = mid; } } /* 不存在，返回 */ if (nums[j] != target) { return vector&lt;int&gt;{-1, -1}; } /* 找大边界 */ while (i &lt; r) { mid = (i + r) / 2; if (nums[mid] &lt;= target) { i = mid + 1; } else { r = mid; } } return nums[r] == target ? vector&lt;int&gt;{l, r} : vector&lt;int&gt;{l, r - 1}; }}; 二分查找的边界条件十分值得注意。很容易出现查找缺漏、死循环的情况。 如有错误，恳请指正！","link":"/2019/03/20/binary_search/"},{"title":"Class Stuff","text":"&emsp;&emsp;这个学期教我们离散的是Yjj.&emsp;&emsp; 陈寅老师的ppt (psw: ClassStuff) 如果你有什么好的资料，欢迎发到这里来 （继续愉快地念屁屁踢）","link":"/2017/09/07/class-stuff/"},{"title":"DCA - 对AES侧信道分析的总结","text":"DCA计算原理与实现中的局限性DCA采用与硬件上DPA相近的从trace到relationship computation的操作方案，通过采集样本-样本分类-样本相关性对比的方法，分析给出的猜测是否正确，得出结论。目前的情况是，处于中间的noisy round，无法抵御或完全抵御DCA攻击。 踪迹采集踪迹采集器TracerGrind是一个valgrind的插件，他会记录每一次应用中的读写及其读写周期、外部调用、指令地址、数据地址、数据区域及长度等。一般我们需要采集的为数据的读写情况。每一次加密采集都会形成一个(明文，密文，读写上下文)三元组。不同的三元组有利于最终后期做CPA时不同的覆盖情况。根据算法内部的长度不同，需要采用不同的监视长度。如noisy_round是8-128的，两个64拼成一个128。这意味着大概率CPA所需要的读写踪迹分布在长度为8的部分上。这也是一开始分析8-128不成功的原因。 踪迹汇总采集后的踪迹会汇总形成一个独立的有一定格式的二进制文件上，供Daredevil进行CPA分析。Daredevil一般采用一阶相关关系分析来做密钥的匹配工作。相关配置会写在config文件上。如 1234567891011121314151617181920212223242526[Traces]files=1trace_type=itranspose=trueindex=0nsamples=492096trace=stack_data_rw8_201_492096.trace 201 492096[Guesses]files=1guess_type=utranspose=trueguess=stack_data_rw8_201_492096.input 201 16[General]threads=8order=1return_type=doublealgorithm=AESposition=LUT/AES_BEFORE_SBOXround=0bitnum=allbytenum=allcorrect_key=0x000102030405060708090a0b0c0d0e0fmemory=4Gtop=20 就代表了，踪迹的数据为整型，踪迹矩阵（时间为列，数据为行）需要经过转置（这里是固定参数），踪迹汇总名为stack_data_rw8_201_492096.trace，猜测推导输入是利用明文输入，名为stack_data_rw8_201_492096.input，一共进行了201此追踪，产生了492096个读写样本点，算法每轮长度为16字节（即针对0~15轮进行破解），用AES的在sbox之前的表来进行比对（这个通常要after sbox才能成功），针对round 0 进行破解，给出前20个最高可能的待选样本。 构建猜想构建猜想的过程进行选择函数的过程。选择函数会将每一个明文输入对应到字节一个映射过的字节，这个过程我们称之为猜想表对换。输入明文会被对换，然后按照16字节的对换后结果进行汇总。通常选择函数会将一个字节对应到一个对换过的汉明距离（当数据有缺陷的时候）或每一比特位置对应到0-1上，成为选择分类的依据。这里的矩阵结构比较不明显，他是一个$n \\times m$的矩阵，n是采样次数，m是16，固定长度。代表输入的明文被合并到一个矩阵上。这些矩阵每个明文通过一个选择，就得到猜想。 123456789for (i=0; i &lt; nrows; i++) { for (j=0; j &lt; n_keys; j++) { if (bit == -1) { /* No individual bits. */ (*guess)[j][i] = HW ((TypeGuess) sbox[ (uint8_t) mem[i][bytenum] ^ j ]); } else if (bit &gt;= 0 &amp;&amp; bit &lt; 8) { (*guess)[j][i] = (TypeGuess) ((sbox[ (uint8_t) mem[i][bytenum] ^ j ] &gt;&gt; bit)&amp;1); } }} 样本关系计算这一步会将每一个样本点与上一步骤的猜想进行比对。每读写16个字节的样本，就与目标猜想进行一次比对。这也是为什么noisy round会成功的原因：如果你的选择函数有效，且你的有效区间被采样了，如果相关关系正确，你就必然会在后续的关系比对上产生一个峰值。但这也是为什么noisy round会导致部分出错的原因：我们攻击的是第0轮到第一轮之间的数据。如果这个16字节noisy round被拆开了有一半被当作下一个16字节样本，后续的所有过程会有连锁反应。这也是第一轮noisy round能部分阻挡DCA的原因。这也侧面证明了，noisy round在实现上与我们所想的，有一定的差别。他的结构跟正常AES轮次不太一样。 按照相关关系，给出Top K符合的字节并不是每一次都能获取到最佳的比对字节。有可能有一个比对达标，但又有可能没有。其中，peek最接近0.25，0.5，0.75，1的，被认为是最佳选择。 常见的操作失败 目标数据长度不同。如：8-128的表必定对应长度为8字节，即64bit的读写区间。（因为8字节是目前最长的基础数据）如果使用了1、2、4字节，即char，short，int，会错误采样。默认进行4字节的采样。 目标地址不能精准定位。这tracegraph，也确实是吹牛。因为几乎不可能看出来地址在哪里。 动态库有自己的地址空间，必须采取其他措施。 WBSM4可能存在的隐患 仿射变换的计算过程会直接干扰到对换关系的比对，这会导致cpa无法进行或误判。这点日后深入拓展。 主密钥的情况，会有更多出入。aes和des的第一轮密钥都是原生密钥没有改变，所以第一轮就给出master key。sm4的情况？","link":"/2020/03/01/dca/"},{"title":"网盘系统建立啦！","text":"为了自己、班委以及相关需要的人实现分享文件的便利，我建立了一个网盘系统，用的是seafile&emsp;&emsp;当然是fs.wxk.es啦。。（当然是选择继续阅读啦） seafile最大的好处在于，它是python运行时，c为主体构建的。部署便捷，文档齐全（有点老）但不足还是有很多的。比如不支持文件搜索。 现在实现的简单的功能特性： 简单的文件存储：网盘会分配少量的定额，满足分享公示、文件的需求；（一般少于800MB） 外链分享：通过外链的分享，实现文件的共享。可以添加外链过期时间，添加密码，还可实现更多； PDF、word、excel、markdown等预览：网盘自带预览系统，可以实现免下载预览；（微信内部浏览器不支持（偶尔闪退））【额，好像还是不支持xlsx格式的预览，随意啦（滑稽）】 全面的安全机制：小站拥有完备的安全规则，拥有A+级的安全评估； 主机商提供完备的服务，不会断电，极力保护数据不会丢失。 尚存的不足： 由于服务器仅为少量用户使用而配置，网盘仅提供少量的注册名额即存储空间； 服务器处于测试阶段，仅保证90%的SLA；（233） 其实主要的用途，还是分享文件的方便快捷，以及安全的考虑。其实pan.scnu已经做了全部事情了……现在已经共享出来的链接： 一些书籍以及参考资料 一些基本网络工具 数学建模的零星资料 密码都是ping1008 （关于里面的内容，有些是比较私人化但又是免费的。请不要利用） 曾经也用过owncloud构建，但相对比较繁琐，而且会出现下载断链的情况（未探清楚是什么原因），于是乎一脚踹开了。同时，为了网站的安全，弄到了不少nginx部署上的技巧。例如防止xss攻击，实现CST，以及相应的监控等。监控用了report.io，一个非常管用的CST报告网站。 一些常用的Nginx规则： 123456789101112131415161718192021222324252627282930313233343536server_tokens off;ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 仅允许安全的SSL版本add_header X-Robots-Tag none;add_header X-Download-Options noopen;add_header X-Permitted-Cross-Domain-Policies none;add_header X-Frame-Options \"SAMEORIGIN\";add_header X-XSS-Protection \"1; mode=block\";add_header X-Content-Type-Options nosniff;add_header Strict-Transport-Security \"max-age=129600; includeSubDomains\";add_header 'Referrer-Policy' 'origin';add_header Content-Security-Policy \"default-src 'self' https://pagead2.googlesyndication.com; script-src 'self' data: 'unsafe-inline' 'unsafe-eval' https://pagead2.googlesyndication.com https://secure.gravatar.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://pagead2.googlesyndication.com https://secure.gravatar.com https://translate.googleapis.com; img-src 'self' data: https://dmmj3mmt94rvw.cloudfront.net https://fonts.gstatic.com https://csi.gstatic.com https://googleads.g.doubleclick.net https://gstatic.com https://secure.gravatar.com https://stats.g.doubleclick.net https://www.gstatic.com; font-src 'self' data: https://dmmj3mmt94rvw.cloudfront.net https://fonts.googleapis.com https://fonts.gstatic.com https://themes.googleusercontent.com https://www.gstatic.com; connect-src 'self' https://fonts.gstatic.com https://pagead2.googlesyndication.com; media-src 'self' data: https://ssl.gstatic.com; object-src 'self' https://fonts.gstatic.com https://pagead2.googlesyndication.com https://www.gstatic.com; child-src 'self'; frame-src 'self' https://googleads.g.doubleclick.net gsa://onpageload https://onpageload https://secure.gravatar.com https://tpc.googlesyndication.com ; worker-src 'self'; frame-ancestors 'self'; form-action 'self'; upgrade-insecure-requests; report-uri https://pingfs.report-uri.io/r/default/csp/enforce\";# 留意那个report-uri，是我个人的报告uri。请使用时务必更改为自己的ssl_session_cache shared:SSL:10m;ssl_session_timeout 20m;ssl_prefer_server_ciphers on;ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:!RC4-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;ssl_dhparam /etc/ssl/certs/dhparam.pem; # 这是自己生成的DH key，留意下文参考链接location ^~ /.well-known/acme-challenge/ { default_type \"text/plain\"; root /usr/share/nginx/certbot;}location = /.well-known/acme-challenge/ { return 404;}location = /.well-known/carddav { # 这是给PHP用的 return 301 $scheme://$host/owncloud/remote.php/dav;}location = /.well-known/caldav { return 301 $scheme://$host/owncloud/remote.php/dav;} 现在fs在ssl Lab的评分是A+～ 另外，IE6，Java6u等老版本浏览器，已经不被支持了。（blog的配置和fs的几乎无异） 附上我的参考资料： 利用Certbot优雅获取Let’s Encrypt免费SSL证书 – 会长出品 Nginx 配置之安全篇 – Jerry Qu","link":"/2017/08/17/file-share-sys-deploy/"},{"title":"我最喜欢的快速排序算法","text":"123456789101112131415161718192021222324program qsort;var n,p:integer; a:array[0..100000] of integer;procedure qs(l,r:integer);//假设被排序的数组是a,且快排后按升序排列）var i,j,m,t:integer;begin i:=l; j:=r;//(l（left）,r（right）表示快排的左右区间) m:=a[(l+r)div2];//注意：本句不能写成：m:=(l+r)div2; repeat while a[i]&lt;m do inc(i); while a[j]&gt;m do dec(j);//若是降序把'&lt;'与‘&gt;'互换; if i&lt;=j then begin t:=a[i]; a[i]:=a[j]; a[j]:=t; inc(i); dec(j); end; until i&gt;j; if l&lt;j then qs(l,j);//递归查找左区间 if i&lt;r then qs(i,r);//递归查找右区间end;","link":"/1970/01/01/favourite/"},{"title":"给17级计科新生的一丁点儿建议","text":"Computer Science: a Sophomore’s perspective :)&emsp;去年15级迎接16级如同昨日，而现在17级的新生又到了，日子也是过得挺快。我不是你们兼班兼助，以后也应该不会是。如果说这篇东西写给哪些人看，我想应该也就是给17计算机学院新生。老人们，不管是咸鱼还是大佬，都有了自己的想法了罢。咸鱼想翻身不容易，但大佬变咸鱼也可能只是一念之间（233）。大学是学习的开始，希望大家尽早做好准备。bintou老师曾有写一篇给计算机学院新生的一封信，你们可以读完老师的建议然后再选择是否继续读下去。当然，我会把一些更细的东西夹杂进来。不能覆盖大学生活的方方面面，权当敲门砖，但求抛砖引玉。&emsp;&emsp;计科，也就是熟知的计算机科学与技术，含糊得讲，就是围绕计算机展开的，根据计算原理、计算理论，以计算为中心的科学技术。这其中包括了科学上的探索与工程上的创造。科学的体现，在此又与数学紧密联系，在即将接触到的比如算法与数据结构，线性代数，概率论等学科或知识中会体现出来。工程的体现，包括程序的设计，程序、计算机以及网络的体系结构，注重人的动手能力以及对于程序的整体规划能力。但其主体，还是科学。一切在工程上不以科学为基础的高调都是耍流氓，一切没有科学根据的动手都是空谈。也许你们进来以后，会有老师，可能看上去很“高逼格”的老师对你们说，“科学对于我们绝大多数的同学来说，都是不可能的，我们的同学绝大多数都往工程方向走，所以我们要提高我们的工程能力。” 那绝对是胡扯。尽管工程方向确实为大多数，但没有扎实的科学根基，谈何工程？更进一步，“作为一门学科，无论冷热，我们需要做的是：发现其本质、遵循其发展规律。” 立志科研，成为科研人物，站在计算机科学的前端，也是这门学科培养人才的最终目的。&emsp;如老师所说，初入计算机科学，笼统的任务，就是学英语，学数学，学编程。学英语，是要提高自己的英语阅读能力，习惯于阅读英语的书籍专著。刚开始可能读起来比较吃力，但也应慢慢训练，习惯了就会发现英语的理解起来更加透彻。As far as I’m concerned, 不管曾经有无经验，第一本英文书籍都推荐How to think like a computer scientist: C version。学数学，第一学期最重要的包括高等数学，线性代数。日后，线性代数在学科中的地位会愈发显著。至于更进一步，就在下文了。学编程，就主要体现为学习程序设计语言, c 或者 c++，理解程序设计的思想，面向过程、面向对象，学会科学地构建更具规模的程序，提高代码的复用性。&emsp;关于该学什么，老师已经有了一个文档，CS核心教程。这个文档可能和学院给你的不太一样，但它一定是高水平的，超出学院的要求，对于成为计算机领先人士有指南针般的作用。每一本书都是一个里程碑，学习吸收，对于你一定会有好处。下下文会说到。 &emsp;补充的东西：可能有用的书籍（密码是ping1008） &emsp;可能在进入计算机学院之前，绝大多数同学就会听闻，“学计算机呀，敲代码的，呵呵……”。没错，代码，是人机交互的根本方式，是连接碳基生命与硅基生命的桥梁。通过程序的命令或语句，实现程序设计者所需要的功能。学院主要教导的，就是c++的学习。可能大家会对c还是c++感到迷惑，因为老师、学院的说法也是含糊。但你从任意一门入手，都是可以的。做好选择，深入理解，不必要迷茫。可以说，学院一开始教导的东西，在c、c++中的体现是无异的。课上的老师几乎只教语言，没有设计更多的设计思想。但这是我们要好好理解的。 对于此，推荐一些书。希望对大家会有益。 How to think like a computer scientist: C version C++ primer plus &emsp;第一本大家应该听老师所提及了，非常适合入门。第二本却不常为推荐，褒贬不一，甚至为人诟病。(中文版，还是妥协了)。因为这一本，很厚，很细，像字典。可能很多人拿出来翻两下就已经失落了。但其中有非常详细的解释与实现，快节奏地跟着书本走一边学一边敲，学会了就好，然后慢慢实现一两个功能，实现一两个冒泡排序之类的算法。学习C++，一定不能脱离算法与数据结构。你可以把他和算法一起看。因为语言只是工具，算法才是核心。通过对算法的实现，了解语言特性，并掌握对其的应用。这样学起来才会有进步，有着落。可能并不需要在一个暑假内看完，约莫在11月看完前7章，12月看完前八章就够了。甚至，可以去看OI常推荐的算法竞赛入门经典。这些都是可选项。如果你读了觉得失落，并不是你的问题，只是教材并不适合你。但是，HTCS是要看的，并要认真研读。这也是进入图灵班的最低门槛（下文会讲）。参见： 打造华南师范大学计算机科学的铁军–图灵班 华南师范大学计算机学院图灵班工作计划–2017年 &emsp;BTW, 谭浩强的《c++程序设计》，太坑了……期末了检查自己学得如何，就看能从其中挑出多少错误了。。。（一家之言，一家之言，没有老师说过）。 另外的，就是着手线性代数的学习。大家可以去看Gilbert Strang的Introduction to Linear Algebra 这里是书本链接, 可以暑假就开始看。非常有益，细致入微地介绍线性代数，是最为经典的线性代数教材。这也是图灵班第一学期的着重书目。同时，也不要忘记看学校发的课本，要认真学习。作为一门重要的基础数学科目，它具有着举足轻重的地位。关于数学，同样可以参阅： CS2013第6章选译： 计算机科学的数学要求 《高等数学》导读–CS版本 以下就是一些相对离散的东西了，不知道如何归纳，但所以也就堆在一起。。😂 &emsp;首先是图灵班。关于图灵班的介绍，在上文中的链接中有了。这是一个非常考验意志力与执行力，但没有任何强制约束力的集体。以学术交流为核心，为的就是打造华师计机体制之外的铁军。其长期的主要学习任务，就是上文指出的核心教材。进入的要求： 完成HTCS（How to think like a computer scientist: C version）的阅读，并撰写读书报告，在国庆放假前提交给老师。（具体时间，提交方式另外安排） 学习GS的LA，并看MIT线性代数公开课的视频。网易公开课上对应的视频 国庆前后，完成面试。 &emsp;Then，眺望窗外，拥抱世界。接触、学习使用Linux操作系统，熟悉命令行。对于计算机系的学生而言，Linux是更好的开发平台。它的开放性更加对开发者友好，而且有更丰富的资源与文档。以前总有人会问，好端端的在windows下 ，干嘛要切换到别的系统上去。其实，以开源操操作系统GNU/Linux为中心的开源文化才是进步与发展的源泉。就如鲤鱼跳龙门一样。只有从MS的窗口看出去，才能看到更美好的风景。一开始会不习惯，因为会接触大量的命令行。但慢慢就会熟悉，会发现命令行效率对于大多数熟悉者而言比鼠标高。建议新手从ubuntu这个发行版入手，可以在虚拟机上先试着安装，安装好系统后，在上面用atom、vim或者其他的编辑器写自己的一个“Hello, world”，并用gcc或clang编译。但是，虚拟机终究不是你的选择，你应该把它以双系统的形式安装在自己的电脑上，并用它来高效地开发（百度可以告诉你怎么做）。这只是针对新人，对于熟悉的人，早就已经有自己各种各样的玩法。;&emsp;其次，对于学院教学安排的一点点意见。如果你仅仅跟着老师学，按部就班，那是远远不够的。计算机科学是一门自主性非常强的学科。要锻炼自己的自学能力。很多东西，老师甚至不讲，就会叫你做。你需要查大量的资料，询问不同的人。所以，学会查资料，学会问问题，学会自主学习，比什么都重要。大道至简，知易行难。需要慢慢摸索与积累。（关于如何使用Go0g1e,之类的，如果不懂，可以询问群里的dalao。你需要lift）同样的，在图灵班的学习也是如此。大部分都是靠自己。坐得住冷板凳，才会有收获。&emsp;然后，不要沉溺与社团、社交活动，不要被社团宣传的过度渲染而迷住。比如，不要每日忙于学*会的工作，也不要在那圈子里每日麻将打牌大保健。另外，不要为社团熬夜。如果你能从社团里头获得乐趣，学得知识，那当然是最好的。我从ISCNU学到了不少的知识，并且应用到了自己的“搞事”中。还有很多人玩CTF，体验当黑客的乐趣（当然，我顾不来没有参加）。大家一起交流，挺好。&emsp;Furthermore，权衡好兼职与学习。兼职是不错的锻炼，应该处理好时间安排问题。不要因为兼职而影响了学业。得不偿失。同时，权衡比赛与学习，不要参加没有意义的比赛。不要当赛棍。学院每年都会宣传一大堆的比赛，你应该好好考量。&emsp;多学习，多交流。多多提升自我，这样你才可以跟更厉害的人在一起。想要和大佬交流，首先要有成为大佬的想法。如果你只会喊“哇大佬好厉害”，那也是为人鄙薄的。不要过了半年一年的，一些人水群就是游戏打牌大保健，另一些人却是各种技术游戏。同样是娱乐，差别却那么大。人自然而然地就被划分了。 &emsp;Last but not least, 少熬夜，做没有黑眼圈的大熊猫。。。：） &emsp;总说是大0准大学生，其实，录进了大学，就是堂堂正正的大学生了。本文以非常文科的形式阐述了计机在大学中的一些方面，可今后你们的学习，甚至你们的生活，都要以非常理科的方式进行。希望大家，学会学习，学会反思，学会交流。大学既不是象牙塔，也不是职业学校，但它与社会紧密融合在了一起，需要各位慢慢体会，常常回想，细细反思。看清自我，看清社会。遭遇多少，领悟多少。最后，祝大家收获无憾的大学生活。 ping: 1008 2017.7.18","link":"/2017/09/03/for-freshman/"},{"title":"Effective C++ 笔记","text":"This is a piece of individual notes of effect c++, which contains personal opinion and example. 签名，声明，定义签名指代函数返回值+变量的类型，size_t (int) 声明指代函数的返回值、变量名、名称的说明，size_t rtt(int proj); 定义指代函数的具体内容， 123size_t rtt(int a){ return sqrt(pow(a, 2)+pow(a, 2));} item 6: 必要时阻止拷贝，阻止默认构造/析构/拷贝行为 若要编译期阻止拷贝/构造，将拷贝/构造函数写入 private 然后不实现（单例类常用实现） 循环引用会导致non-local行为，使得单例也面临不一致问题。 derived class阻止拷贝，继承 uncopyable 12345678class uncopyable { protected: uncopyable() {} ~uncopyable() {} private: uncopyable(const uncopyable&amp;); uncopyable&amp; operator=(const uncopyable&amp;);} item 7: 多态基类声明virtual析构函数 虚析构函数：用于多态基类 虚析构函数防止derived class局部销毁： 12345678910111213141516171819202122class A { public: A() {} ~A() {} int AB; private: int a;}class B : public A { public: B() : A() {} ~B(){} private: int b;}// -----B* hi = new B;A* well = hi;delete well; // 只有 A 的部分会被析构，B 的private b 不会被析构！ // 行为未定义，内存泄漏，数据（内存）结构破坏 虚析构函数生成的vtbl会加大内存占用量： 如果class不含析构函数，意味着不被用为一个base class 当class中带有虚函数，才需要有虚析构函数 pure virtual: 纯虚函数，阻止初始化； 构造纯虚类：纯虚析构函数，同时需要提供析构函数实现：最深层派生的class先被调用，然后才是base class。如果pure virtual destructor没有实现，则该类无法析构，连接器报错。 12345class AMOV { public: virtual ~AMOV() = 0;}AMOV::~AMOV() {} item 8: 析构函数不可流出异常 如果不需要处理，try...catch...，然后吸收或者结束程序 如果需要处理，单独成立一个函数让用户handle异常 item 9​ 构造/析构函数中，如果出现虚函数，被构造/析构的时候派生类会调用基类构造/析构实现。导致未定义错误。pure virtual函数同理。 item 10: operator=​ operator=返回*this，可以使得行为与基础类型一致。 item 11 =的自我赋值​ 解决 = 自我赋值问题：copy-and-swap 12345widget &amp; widget::operator=(const widget&amp; rhs) { widget tmp(rhs); swap(tmp); return *this;} item 12 继承、拷贝问题​ 继承-拷贝问题：派生类赋值需要考虑基类的数据继承问题，可以考虑用基类的operator=进行赋值操作。 12345class D : public B { D(const D&amp; d){ B::Operator=(d); }} item 17​ 独立生成new语句，放入智能指针，以避免顺序生成异常造成的内存泄漏。 12345678910void processWidget(std::share_ptr&lt;int&gt;(new int[12]), priority());/* 如果new出错，priority已完成，那priority可能内存泄漏 如果priority出错，new完成但未进入share_ptr, new int[12] 将内存泄漏*//* 正确示范 */std::share_ptr&lt;int&gt; tmp(new int[12]);void processWidget(tmp, priority()); item 19 ~ 25: 提高封装性，可用性，代码清晰度 面向对象的三特性：封装性，继承性，多态性 封装性越高，底层实现的灵活度越高； 声明成员变量为private，并用getter、setter，以防止直接操作：成员变量描述内部状态，公共成员函数提供接口； non-member non-friend 函数替代 member 函数：降低外部访问度，提高封装性 operator，等函数：对于类，pass-by-reference-to-const，减少可能的复制(c++17 有优化，编译器也会进行一定的优化) argument dependent lookup: 对于不同命名空间内的函数，根据argument dependent lookup 原则，首先会调用本全局函数，再（自身）命名空间内的函数。例如： 123456789template&lt;typename T&gt;void doS(T&amp; l, T&amp; r) { using namespace std; // ... swap(l, r);}// 编译器首先搜寻全局域，看是否有l，r的全特化；然后寻找l，r所属类所属命名空间，查找是否有// 全特化，最后再调用标准的swap. 成员函数swap特化具有STL的一致性，但依旧需要提供非成员函数swap，以提高封装性与可操作性。（个人见解） item 26：尽可能延后定义式的出现，避免不必要的构造/析构成本当函数定义了一个对象后，会调用默认（或给定）构造函数，并在区域结束时会调用析构函数；一般情况下，非到对象初值确定，不对其进行定义；若在循环体中，应考量构造、析构、赋值的开销。 123456789101112131415161718192021void doSTH(std::string a) { /* 如果if内抛出异常，则b的构造、析构开销是无用的 */ std::string b; if (a) { // ... } return b;}// 方法1Widget w;for (int i = 0; i &lt; n; ++i) { w = impl; // ...}// 方法2for (int i = 0; i &lt; n; ++i) { Widget w(impl); // ...} item 29: 异常安全 （important）线程安全函数的保证： 基本承诺：如果异常被抛出，程序内任何事物仍然处于有效状态。所有原有状态不改变。 强烈保证：程序状态不改变：commit or rollback nothrow保证：函数不抛出异常 异常安全具有随后性，如果一个函数中包含基本安全函数、强烈安全函数，那该函数的安全性为基本安全。 item 31: 编译壁垒The PIMPL idiom item 32-33: public inherit: is-a继承关系，is-a; 避免derived class的作用域覆盖问题： 若derived class中复写base class中的方法，则基类同名方法不可用。 不管base class里是否virtual，都会因为覆写而被屏蔽。 1234567891011121314151617class B { private: int a; float b; public: void mt1(); void mt1(double);}class D : public B { public: void mt1();}////////D dm;dm.mt1() // dm.D::mt1()dm.mt1(x); // 错误！overwrite！ 解决方案： 123456class D : public B { public: using B::mf1; // 此处只能用mf1不能mf1(double), // 名称与命名空间的引用。 void mf1();} 关键字：using 另外方法：forwarding： 123virtual void mf1() { Base::mf1();} Item 34: 区分接口继承与实现继承 成员函数的接口总会被继承 pure virtual func是为了继承接口 impure virtual func继承的同时提供了缺省实现 non-virtual func继承提供了强实现，不允许重写 接口有限继承，避免默认基类方法：（显式指定缺省方法） protected default function: 123456789101112131415class A { public: virtual void echo() = 0; protected: defaultEcho() { std::cout &lt;&lt; \"echo::A\" &lt;&lt; std::endl; }}class B : public A { public: virtual void echo() { defaultEcho(); }} instantiation for pure virtual function: 123456789101112131415class A { public: virtual void echo() = 0;}void A::echo() { std::cout &lt;&lt; \"echo::A\" &lt;&lt; std::endl;}class B : public A { public: virtual void echo() { A::echo(); }} Item 37：virtual 函数参数缺省值问题不要重复定义一个继承而来的缺省参数值，会导致派生类的缺省值失效。 动态类型与静态类型动态类型绑定(dynamically bound)与静态类型绑定(statically bound)问题：声明中所采用的类型，成为静态类型；实际使用中的类型，称为动态类型。e.g.:123456789101112131415161718192021222324252627class Shape {public: virtual void echo(int i = 0) { std::cout &lt;&lt; i &lt;&lt; \"Shape\" &lt;&lt; std::endl; }; // ...private: // ...}class Circle : public Shape {public: virtual void echo(int i = 2) { std::cout &lt;&lt; i &lt;&lt; \"Circle\" &lt;&lt; std::endl; }}/** * ps为Shape*类型，静态类型为Shape* * ps指向了Circle，其动态类型为Circle * ps调用virtual函数会使用Circle的实现 */Shape* ps = new Circle; 为提升运行期效率，在编译期决定缺省参数值，C++会使用基类中virtual函数的缺省参数值。e.g.:1234// 此命令会使用Shape提供的 i = 0;ps-&gt;echo();// 输出的结果是：// 0Circle\\n 为解决上述问题，并降低派生类中的代码重复，防止一个缺省值出现多次，可以采用item35提及的NVI方法或者其他替代方案。例如NVI，将实际运行函数置于private中，然后基类中使用non-virtual public函数调用private函数。12345678910111213141516171819202122class Shape {public: void echo(int i = 0) { doEcho(i); }private: virtual void doEcho(int i) { //... }}class Circle : public Shape {public: //...private: virtual void doEcho(int i) { //... }}Shape* ps = new Circle;ps-&gt;echo(); // 此处使用的i = 0;","link":"/2019/01/01/effective-cpp-notes/"},{"title":"HAProxy实现前-后端热调试","text":"由于前端用了vue，后端用了go，webpack的proxy是一种策略，可是vue create构建的应用似乎找不到入口，加上对webpack的不熟悉，便用haproxy进行反代调试。前后端任意调试的过程中都不需要停机-构建-启动-看情况的过程，实现了热调试。 代码如下123456789101112131415161718192021222324252627282930global maxconn 4000 daemon # turn on stats unix socketdefaults mode http option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 4000frontend http-in bind *:80 mode http acl url_backend path_beg -i /api use_backend backend_servers if url_backend default_backend front_serversbackend backend_servers server imgsrv1 127.0.0.1:4000 check maxconn 1000backend front_servers cookie srv insert nocache server websrv1 127.0.0.1:8080 check maxconn 1000 cookie websrv1 通过如上设置，服务端映射到/api路由下，是4000端口-80端口；客户端映射到/路由下，是8080-80端。这样调试的时候就避开了跨域问题，对往后的部署有更好的非侵入性。","link":"/2018/12/15/haproxy/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" $$ e = mc^2 $$ More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2017/08/09/hello_world/"},{"title":"LeetCode T15 - 3Sum","text":"LeetCode T 15: 3Sum是一个比较普通的问题，考验一定的思维和编程能力。 描述：给定一个长为$n$的数组nums，请问数组中是否包含三个元素a, b, c, 使得 a + b + c = 0? 找到数组中所有这类元素的三元组。注意：解决方案中不得包含重复的三元组。 例子：1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 从题目我们可以知道，需要找到所有不重复的$(a, b, c)$，使得$a + b + c = 0$。这里有一个关键点：不重复。 为达到这个目标，首先我们需要对原数组进行排序，以进行序列的比较筛除重复的元素。如：[0, 0, 0, 0]，如果不进行筛除，将会得到[[0, 0, 0], [0, 0, 0]]，这是不符合规范的。同时，我们需要进行搜索，需要一定的时间优化。如果用暴力，将是$O(n^3)$的时间复杂度，这将是非常令人不满的。因为LeetCode会报TLE。于是，设计了一个思路：指针i, j, k分别指向三个元素，i从0开始迭代到len(nums)-2，j从i+1开始迭代到len(nums)-1，k采用二分查找。 最后代码是这样(Golang)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func threeSum(nums []int) [][]int { // 排序 sort.Ints(nums) lens := len(nums) var matrix [][]int // 长度不够，返回空 if len(nums)&lt;=2 { return matrix } for i := 0; i &lt; lens-2; i++ { // 第一个元素就&gt;0, 意味着所有元素&gt;0 if nums[0] &gt; 0 { break } for j := i + 1; j &lt; lens-1; j++ { l := j + 1 r := lens - 1 // 二分查找 for l &lt; r { if l == r-1 { if nums[i]+nums[j]+nums[l] == 0 { matrix = append(matrix, []int{nums[i], nums[j], nums[l]}) } else if nums[i]+nums[j]+nums[r] == 0 { matrix = append(matrix, []int{nums[i], nums[j], nums[r]}) } break } mid := (l + r) / 2 if nums[i]+nums[j] &lt; -nums[mid] { l = mid } else if nums[i]+nums[j] &gt; -nums[mid] { r = mid } else { matrix = append(matrix, []int{nums[i], nums[j], nums[mid]}) for j &lt; lens-1 &amp;&amp; nums[j] == nums[j+1] { j++ } break } } // 只有1个元素的特殊情况 if l == r { if nums[i]+nums[j]+nums[l] == 0 { matrix = append(matrix, []int{nums[i], nums[j], nums[r]}) } } // 迭代完成，去除重复元素 for j &lt; lens-1 &amp;&amp; nums[j] == nums[j+1] { j++ } } // i迭代完成，去除重复元素 for i &lt; lens-2 &amp;&amp; nums[i] == nums[i+1] { i++ } } return matrix} 这个答案依然不是最好的，时间已经是1024ms，超过了一般规定的1000ms。其实，3Sum问题本质上是2Sum问题。因为a = -(b+c)，所以a从0迭代到len(nums)-2，只要保证j，k构成的2Sum和a加起来是0就正确。这就是最优的解决方案。","link":"/2018/12/20/leetcode15/"},{"title":"坐标地址拾取器","text":"国赛模就这样愉快地结束了，用了一大堆的工具和语言。做了很多繁琐的工作。从C语言到R到Matlab，做了不少图。 其中有一个很有意思的东西，利用百度地图的坐标拾取系统获取经纬度对应的地址。是一个被爬取出来的地图API。 http://api.map.baidu.com/?qt=rgc&amp;x=13407612.87&amp;y=3550364.78&amp;dis_poi=1参考saitjr的博客获取的消息，将经纬度坐标转换成墨卡托坐标，然后向百度发请求，就可以get到了具体的地理位置了。 然后呢，我给它套了个壳。以方便快捷地使用。不过还是有点害怕。万一appending mode把别人的文档搞坏了呢。。（逃 仓库在这里～ （开发完成。。。）","link":"/2017/09/22/lla/"},{"title":"LeetCode T17 - Phone Number","text":"刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c++写：“哇靠，垃圾程序的典范！😭”第17题是一个典型选择问题，要求从给定的数字中选择几个需要的字母。解法存在优化，但基本上就是DFS。leetcode 17 题的一个解法如下。 这里是递归的做法，非常好理解： base case：如果最后一个数字，则逐一添加每个字母到需要被添加的子串中； recurrence case：如果非最后一个，则遍历当前的所有字母，进入下一个循环。 其实，这种类似尾递归的做法，编译器可以优化。但做题的时候，leetcode好像出了问题，不管怎么优化都没法做到0ms。。。 123456789101112131415161718192021222324252627282930string mapping[8]{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};class Solution { public: Solution() {} ~Solution() {} vector&lt;string&gt; letterCombinations(string digits) { if (digits.length()&lt;=0) return vector&lt;string&gt;{}; vector&lt;string&gt; m; for (char&amp; i : digits) { m.push_back(getString(i - '0')); } solve(m, \"\", 0, digits.length()); return this-&gt;s; } void solve(vector&lt;string&gt; &amp;m, string candidate, int ptr, int len) { if (ptr == len - 1) { for (char&amp; i : m[ptr]) { s.push_back(candidate + i); } } else { for (char&amp; i : m[ptr]) { solve(m, candidate+i, ptr+1, len); } } } private: vector&lt;string&gt; s; inline string getString(const int a) { return mapping[a - 2]; };}; 递归改迭代： 12345678910111213141516171819202122232425262728293031class Solution { public: Solution() {} ~Solution() {} vector&lt;string&gt; letterCombinations(string digits) { unordered_map&lt;char, string&gt; mapping{ {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"}}; if (digits.empty()) return {}; vector&lt;int&gt; steps{1}; int sum = 1; for (auto&amp; i : digits) { sum *= mapping[i].length(); steps.push_back(sum); } vector&lt;string&gt; m(sum); for (size_t i = 0; i &lt; digits.length(); i++) { string&amp; s = mapping[digits[i]]; int j = 0; while (j &lt; sum) { for (int k = j; k &lt; j + sum / steps[i + 1]; k++) { m[k] += s[(k / (sum / steps[i + 1])) % s.length()]; } j += sum / steps[i + 1]; } } return m; }};","link":"/2019/02/05/leetcode17/"},{"title":"华为笔试 - 占位符替换","text":"2020春招华为出了3道算法题。两道搜索一道没看。其中第一道是Linux Shell占位符替换。用了深搜解决。 题目大意在Linux Shell中，常用${xx}的形式做命令的占位替换。当shell的字符串中局部需要其他变量替换的时候，就用此占位符来代表变量的代入。例如：12a=1234b=/abc/${a}/ 则b变量最终数据为：1/abc/1234/ 现在有一组（可能）包含占位符的变量，他们的占位符替换不循环引用。问这组变量最后的变量应该被替换为怎么样的字符串？如：123a=abcb=de/${a}/fgc=/hj/${b}/${a} a替换如b变量中的占位符，得：/de/abc/fgb替换c变量中的占位符，得：/hj/de/abc/fg/abc如此，最后一行得输出为：/hj/de/abc/fg/abc 输入一共$N$行。第1行为一个整数$n$，即后继拥有得变量数。第2到第$N-1$一共$n$行，为每个变量式的表达；12343a=abb=cd/${a}c=/def/${b}/${a} 输出一行，为第n行的替换后的结果。上述输入结果：1/def/cd/ab/ab Write Up此题解法多，深搜最好理解：用一个串来记录结果。假设为字符串$S$。从头到尾搜索最后一个变量的串。遇到占位符，立即搜索该占位符，然后加上去。三种形式： 如果没有${xxx}这种形式，则后续字符串没有变量，附加上去就好；如：a=ab，没有任何东西。S += &quot;ab&quot; =&gt; &quot;ab&quot;；这是递归结束情况。因为原题描述，该图为DAG。 如果第1个字符为$，则说明开头即变量，搜索。如：a=ab, b=${a}，需要搜索变量a附加上去； 其余情况：先附加一部分，截取子串；如：current -&gt; /ab/${a}，则先S += &quot;/ab/&quot;，再搜索${a} 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct thePair { string first; string second; thePair(string a, string b) : first(a), second(b) {}};vector&lt;thePair&gt; p;string finalRes = \"\";void dfs(string cur) { while (cur.size() &gt; 0) { int pos = cur.find_first_of(\"$\"); if (pos == string::npos) { finalRes += cur; return; } if (pos != 0) finalRes += cur.substr(0, pos); pos = cur.find_first_of(\"{\"); int left = cur.find_first_of(\"}\"); string next = cur.substr(pos + 1, left - pos - 1); for (thePair&amp; j : p) { if (j.first == next) { dfs(j.second); break; } } cur = cur.substr(left + 1); }}thePair split(string n) { int i = 0; for (; i &lt; n.size(); i++) { if (n[i] == '=') { break; } } return thePair(n.substr(0, i), n.substr(i + 1));}int main(int argc, char const* argv[]) { int n; cin &gt;&gt; n; vector&lt;string&gt; vec; for (int i = 0; i &lt; n; i++) { string m; cin &gt;&gt; m; p.push_back(split(m)); } string target = p[p.size() - 1].second; dfs(target); cout &lt;&lt; finalRes &lt;&lt; endl; return 0;} finalRes为最终需要的结果。thePair为分割变量与字符串所用。不断缩短cur，即目前状态，最后清零。finalRes为全局变量，在oi中很习惯使用。","link":"/2020/03/15/mask-huawei/"},{"title":"Manacher 算法：求最长回文子串","text":"网络上关于最长回文子串的文章很多，这里只是为了记录一下思路与过程。 概述manacher算法是一个高效的寻找最长回文子串的算法，时间复杂度和空间复杂度均为$O(n)$，相比于朴素算法有很高的优势。它利用了回文串镜像对称的性质，通过不断（间接）记录以每一个字符为中心的回文串长度，找到最大的回文子串。 回文串定义回文串，就是对称的串。比如：aba，abcba。最大回文子串，就是一个字符串中存在一个子串，使得它的长度是所有回文子串中最长的。例如：abcbac最长的，abcba，长度为5，是最大的回文子串。 为了方便讨论，我们假设总字符串为$S$, 回文串为$s$, 对于一个回文串，定义：1234s.center # 回文串的中心位置，暂不区分奇偶s.st # 回文串开始的位置s.nd # 回文串结束的位置s.mx # 在s.center右方，离s.center最远的下标 性质对称性对称，最基本的特性。str = abcba，那么str[i] == str[len(str)-i-1]。就是，第一个a和最后一个a，第二个b和倒数第二个b，都跟串的中心，c，对称。 推论在一个回文串$s, s.size == n$中，若以i为中心的字符串a[i]（i != s.center），是一个回文串，那么，对应的s的中心对称的位置也是一个回文串。 e.g.: 1str = \"a b a a b a\" 在str中，若以str[1]为中心，可以得到一个回文串aba。在str[1]以str.center对称的位置上，str[4]也是一个回文串，aba. 这幅图阐述了这个性质。以id为中心，mx为边界，是一个回文串。同时，以j为中心存在一个回文串$s_1$。那么，以id对称的位置，也会有一个一样的字符串$s_2$存在。i就是这个串的中心。 然而，并非i处的回文串一定和j处的相同。有可能会有更长的情况，但这种情况只在i出现，不在j出现，于是乎需要从原始的$s_2$边界开始，向外搜索，就可以得到以i为中心的最长串。 算法设计利用这写特性，我们来设计算法：go的代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// min 求两个int的最小值func min(a, b int) int { if a &lt; b { return a } return b}// longestPalindrome 主要函数func longestPalindrome(s string) string { var buf bytes.Buffer // 用来拼接字符串的buffer // predo for i := 0; i &lt; len(s); i++ { buf.WriteByte('#') buf.WriteByte(byte(s[i])) } buf.WriteByte('#') // 给字符串每一个字符之间加一个#，例如： // abcbac，--&gt; #a#b#c#b#a#c# // 这样做的好处是，无论原来的字符串是奇数串还是偶数串， // 都可以格式化为奇数串，这样s.center就不会是一个 // 的间隙 format := buf.String() p := make([]int, len(format)) center, mx := 0, 0 for i := 1; i &lt; len(format); i++ { if i &lt; mx { p[i] = min(mx-i, p[2*center-i]) } else { p[i] = 1 } for i-p[i] &gt;= 0 &amp;&amp; i+p[i] &lt; len(format) &amp;&amp; format[i+p[i]] == format[i-p[i]] { p[i] += 1 } if mx-center &lt; p[i] { mx = i + p[i] center = i } } var resBuf bytes.Buffer st := center - (p[center] - 1) for i := st; i &lt; p[center]+center; i++ { if format[i] != '#' { resBuf.WriteByte(format[i]) } } return resBuf.String()} 实现步骤预处理：转换为奇字符串对字符串$S$，利用#填充字符之间的空隙，以达到将其转换为奇数串的目的。这样的好处是，任意下标的字符串都是一个奇数串，中心是可以由下标确定的，而不是像abba这样，中心在间隙中。证明：任意串s，设 l = s.length()，那包括两端，l的间隙包含l+1个空位。那么，填充之后的字符串$S’$就包含$2l+1$个字符，是一个奇串。即使存在偶数回文串，那也可以以#为中心向两端扩张搜索。e.g.:1234567s = \"abcdcbac\"s1 = \"#a#b#c#d#c#b#a#c#\"// center == s1[7] == 'd's = \"abbac\"s1 = \"#a#b#b#a#c#\"// center == s1[4] == '#' 回文串搜索Manacher算法的基础步骤是，从头到尾，以每一个字符为中心，向两端搜索，以获得最大的回文子串的中心点及边界。在这个基础上，算法还记录每个下标的字符所拥有的最长子串从中心到边界的长度。也就是说，存在标记mx，右边界，center，中心，p []int, 每个下标对应的回文子串长度。例如：12345678910111213141516171819202122232425262728init:mx = 0 // 最大回文子串的最右边界：0为初始值center = 0 // 最大回文子串的中心，0 inits1 = \"#a#b#c#b#a#c#\" // 处理过的字符串// 用于记录每一个下标对应的最大子串p = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]iterate:for i := 1; i &lt; len(s1); i++ { if i &lt; mx { p[i] = min(mx-i, p[2*center-i]) } else { p[i] = 1 } // 若i，即当前中心在回文串里时，有可能以这个中心包含一个回文串， // 那么这个中心的最大偏移数就是对称点的最大偏移数； for i-p[i] &gt;= 0 &amp;&amp; i+p[i] &lt; len(format) &amp;&amp; format[i+p[i]] == format[i-p[i]] { p[i] += 1 } // 从基础值开始，寻找在最大偏移外部的串 if mx-center &lt; p[i] { mx = i + p[i] center = i } // 记录最大的回文串} 通过这三个步骤，最终得到最大子串的中心和边界，这样就可以从中过滤出最大回文子串了。","link":"/2018/12/01/manacher/"},{"title":"新的学期","text":"&emsp;&emsp;时间过得很快的。一下子就二年级了。不过心态还和以前差不多。感觉一切还是按部就班地走，没有特别的好，也没有特别的坏。一直又预感这个学期会不好过，也许会如此吧。&emsp;&emsp;上个学期最大的收获即阅读了大部分的CLRS。获得了许多算法与数据结构知识。CLRS是计算机学习中的一个小小的里程碑，这样，一个坎又勉勉强强过去了。这个学期处理的是 CS:APP, 相对而言对动手的要求会多一点。实践性非常强。做了两个lab，觉得有挑战性。值得好好学习，但我并不怎么认为这是一本里程碑式的书籍。真正的下一个里程碑，应该是ITOC，SICP，以及LADR。&emsp;&emsp;虽然预料这个学期会有很多事件发生，但有些还是猝不及防。还是应该处处小心，处处谨慎。遭遇多少，领悟多少。 &emsp;&emsp;我们别无选择，只能在黑夜中的道路上前行。即便四周像白昼一样明亮，那也只是不真实的白昼。对此我们早已任命。","link":"/2017/09/03/new-semester/"},{"title":"洛谷P1481：最长不下降子序列","text":"P1481是最长不下降子序列的中二版。一个词是否为另一个词的序列，看是否为他的前缀。这里有点小坑的问题在于DP的一些特性。 此处的坑在于，DP（记忆化搜索）的特性需求： 数据被使用之前需要已经被算出来 递归子式不能有后效性 所以，第二层递归从小到大，会遇到未计算的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n;int* dp;string* strs;int common(string a, string b) { int res = 0; int len = (a.size() &lt; b.size()) ? a.size() : b.size(); for (size_t i = 0; i &lt; len; i++) { if (a[i] == b[i]) { res++; } else { return 0; } } return res;}int main() { ios::sync_with_stdio(0); cin &gt;&gt; n; strs = new string[n + 1]; dp = new int[n + 1]; memset(dp, 0, sizeof(int) * (n + 1)); int ans = 1; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; strs[i]; } dp[1] = 1; for (int i = 2; i &lt;= n; i++) { for (int j = i; j &gt;= 1; j--) { if (strs[i].find(strs[j]) == 0) { dp[i] = max(dp[i], dp[j] + 1); ans = max(ans, dp[i]); } } } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; dp[i + 1] &lt;&lt; ' '; } cout &lt;&lt; ans &lt;&lt; endl; delete[] strs; return 0;}","link":"/2020/01/29/non-decrease-sequence/"},{"title":"OS Lab FTP客户端实现中踩过的坑","text":"概述今年大二下OS lab从HTTP转变为FTP，要求实现客户端与服务端。参考文档为RFC 959，语言不限（LJJ老师啥都没说），做法不限（兴许不要import ftp就行。。。），这里细数一下客户端编写过程中踩过的坑。由于还没有提交作业，就不贴ugly的代码了。。。样例FTP客户端基于C++及Poco编写，利用Poco的StreamSocket或者DialogSocket与远端FTP服务器交互。FTP是一个有状态协议，但对于状态，大部分的工作只要服务器记住就行。客户端就可以乱来了。FTP与远端包含两个连接，ctrl-connection 和 data-connection。大部分的命令通过ctrl走response，小部分（LIST，RETR，等数据交互）通过data走。对于一个用户一个会话，所有工作几乎都是阻塞的（ABOR命令除外）。因此，若实现minimum implementation，只要同步的模型就可以完成。ctrl-connection和data-connection由同一个线程发起，天然地保证N，N+1端口与远端交互。 problems一个基本的控制交互过程是，本地生成socket，向远端建立连接，利用socket进行实时通信。所有的交互都是明文交互，因此可以读取、解析回复是什么东西。至于各个回复，RFC959说得就很清楚了。123456789101112131415161718int Session::pasv() { ob buf; string format = \"PASV\\r\\n\"; RegularExpression pasv(\"(\\\\d{1,3}),(\\\\d{1,3})\\\\)\"); ctrl_cnn.sendBytes(format.c_str(), format.length()); ctrl_cnn.receiveBytes(buf, buf.length()); reply rp = replyParser(buf.read()); CHECK(rp, StatusPassiveMode); vector&lt;string&gt; filter; pasv.split(rp.des, filter); desDataPort = (stoi(filter[1]) &lt;&lt; 8) | stoi(filter[2]); data_cnn.connect(Net::SocketAddress(addr.host(), desDataPort)); return rp.code;} 在这过程中，有一些让人卡壳的事情，总是导致it works, why? 这里例举了一下。 CMAKE找不到库我以及一些同学的项目中使用了CMAKE，所谓makefile for makefile。。。然鹅引用第三方库，是需要通过find_library和target_link_library才能找到相应的东西。CMAKE会给makefile添加特定的链接参数，这样才可以找到我们使用的库文件。单句的命令如下：1clang++ -g file.cpp -o -file -lPocoNet -lPocoFoundation -lm 如果没有添加链接参数，0ops，头文件找不着了。最后CMakeList.txt大概长这样：12345678910111213141516171819202122232425cmake_minimum_required(VERSION 3.0.0)project(final_lab_v2 VERSION 0.1.0)set(CMAKE_CXX_STANDARD 17)include(CTest)enable_testing()add_executable(final_lab_v2 main.cpp FrontEnd.cpp Connector.cpp Session.cpp OnceBuffer.cpp Buffer.cpp)find_library(POCO_NET PocoNet)find_library(POCO_FD PocoFoundation)target_link_libraries(final_lab_v2 ${POCO_NET} ${POCO_FD})add_definitions(-I/usr/local/opt/openssl/include)set(CPACK_PROJECT_NAME ${PROJECT_NAME})set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})include(CPack) socket数据传输的完整性问题这里涉及的，就包括什么时间传输完，什么时间接收完，以及粘包问题。在socket编程中，我们底层调用的函数为recv和send，而这两个函数可以设置为阻塞/非阻塞，利用多线程技术可以实现同步/异步。使用过程中发现，每次send一句命令，读的时候总能完整地读到相应的response。It works，why？ 这里就要涉及阻塞、非阻塞的行为：阻塞情况下:在阻塞条件下，read/recv/msgrcv的行为: 如果没有发现数据在网络缓冲中会一直等待， 当发现有数据的时候会把数据读到用户指定的缓冲区，但是如果这个时候读到的数据量比较少，比参数中指定的长度要小，read 并不会一直等待下去，而是立刻返回。read 的原则:是数据在不超过指定的长度的时候有多少读多少，没有数据就会一直等待。所以一般情况下:我们读取数据都需要采用循环读的方式读取数据，因为一次read 完毕不能保证读到我们需要长度的数据，read 完一次需要判断读到的数据长度再决定是否还需要再次读取。非阻塞情况下:在非阻塞的情况下，read 的行为: 如果发现没有数据就直接返回， 如果发现有数据那么也是采用有多少读多少的进行处理．所以:read 完一次需要判断读到的数据长度再决定是否还需要再次读取。对于读而言: 阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回． recv 中有一个MSG_WAITALL 的参数:1recv(sockfd, buff, buff_size, MSG_WAITALL), 在正常情况下recv 是会等待直到读取到buff_size 长度的数据，但是这里的WAITALL 也只是尽量读全，在有中断的情况下recv 还是可能会被打断，造成没有读完指定的buff_size的长度。所以即使是采用recv + WAITALL 参数还是要考虑是否需要循环读取的问题，在实验中对于多数情况下recv (使用了MSG_WAITALL)还是可以读完buff_size，所以相应的性能会比直接read 进行循环读要好一些。 So, 阻塞状态下，connect，send一句，receive一句，完整的，it works。正确性由Linux内核保证。参考书目：Unix网络编程。还有一个就是粘包问题。粘包问题在golang TCP编程中是一个典型的问题。比如你发了RETR命令，服务端首先会发一个150的回复，在data传输完成之后，会发一个226的回复。如果你没有正确的时间点读到，两条回复就会粘在一起。这时候你就尴尬了，如何parse也是个问题。所以，阻塞状态下，send一个RETR，读150的response，然后再开始data_connection传送数据，然后再ctrl_cnn.recv，这样就可以保证正确的时序。粘包问题在FTP中基本就遇不到了。 一些琐碎问题 每次发送/接收完数据，使用完毕后，buffer都要清空，因为上一次的数据会粘在\\0后面。一个字符串读完了，但\\0后面可能会保留上一次的东西，在数据写/ctrl parsing的时候，就容易出错。可以分装一个OnceBuffer。用memset去清空就行了。 发送/接收文件必须保证读完，另外写socket/文件的时候，不要固定buffer，要根据fread/receiveBytes的返回值来确定到底写多少。比如，固定buffer长度可能导致文件末尾多出了很多无用的0的问题。 #pragma once保证了不会重复包含。 多行回复（HELP）咱就不做了，反正也不会给用户裸命令（逃 我们客户端是connection，用TCPserver是不行的（这是fei hua。。） unique_ptr大幅度降低内存泄漏问题 用python写会更加快，会更加没有平台相关性，甚至可以用来写GUI。 坑都是一起踩的坑，这里感谢沉迷MC的黄板桥同学，沉迷WOW的向日葵同学，和吃麦当劳的ZLT同学hhhhhh","link":"/2018/07/15/os_lab_ftp/"},{"title":"奠逝去的好战友","text":"2020年4月5日凌晨，曾经的好友，共同学习成长的战士，离开了人世。官方说辞是，发生了意外。 Hwong与我们虽然常在一个讨论班学习，也是其中最优秀的一员。但他在4月5日永远离开了我们。我们怎么也不能想到的是，这样一个优秀的同学，多次斩获腾讯、pingcap、头条Offer的同学，会做出如此让人惋惜的事情。根据我们对他的理解，发生意外也许只是官方为了大事化小的说辞。毕竟，在西三生活了4年，环境如此熟悉，会有什么意外，是想不到的呢。也许Hwong只是做出了自己最无奈的选择罢了。至于为何会让他觉得走投无路，我们不得而知。也许是家庭，也许是别的，什么都不好说。希望它能够在另一个世界安息，不要再当程序员了。","link":"/2020/05/05/rip_hwang/"},{"title":"LeetCode 54 - Spiral Order","text":"这道题，触及我很多伤痛。高中OI，大学ACM，面试，今天终于完整写完了。。。 上下左右搭建4面墙，作为哨兵条件。每跳出一边，墙就向中间移动一次。记得每次都确认是否墙越界了。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (matrix.length == 0) return list; int up = 0, down = matrix.length - 1, left = 0, right = matrix[0].length - 1; int i = left; while (up &lt;= down) { i = left; while (i &lt; right + 1) { list.add(matrix[up][i++]); } i = up + 1; up++; if (up &gt; down) break; while (i &lt; down + 1) { list.add(matrix[i++][right]); } i = right - 1; right--; if (left &gt; right) break; while (i &gt;= left) { list.add(matrix[down][i--]); } i = down - 1; down--; if (up &gt; down) break; while (i &gt;= up) { list.add(matrix[i--][left]); } left++; if (left &gt; right) break; } return list; }}","link":"/2020/03/06/spiral-order/"},{"title":"CS: APP CH5：编译器/处理器视角的程序优化","text":"借banner以表达对MC的热爱。。。(￣▽￣)v0.1: initial commitv0.1.1: 感谢小神师兄的提醒与指导！ CS: APP 第五章从编译器与处理器的角度，利用c语言实现，描述了程序通用的优化方法。这种通用的方法的度量因不同处理器而异，但策略是相似的。除开算法上的优化，基于机器的系数级优化是本章的重点。我们利用CPE(Cycle Per Element)来度量程序的执行效率，以4代 core i7-47x0 以及 GCC4.8.x 为样例机器，通过多种方式来对程序进行系数级优化。没有书的同学点这里……（第二版与第三版类似，尽管我们用的是第三版） 概述&emsp;&emsp;对程序进行系数级的优化，如书中所说，是一件非常magic的事情。有些看上去可能有所优化的东西，其实对程序并没有太大的影响；而有些微不足道的动作，可能就带来巨大的性能提升。因此，我们需要不断尝试，不断寻找最优解，最后判定优化的瓶颈在哪里。这是算法理论与实现细节的结合，需要多方面的寻找最佳的解决方案。&emsp;&emsp;理解编译器与处理器的运行特点，从而进行程序优化是本章的主题。书中针对编译器与处理器两个方面提出了不同的解决方案。这两个方案在实践中同等重要，各自有不同的意义。通过对编译器动作的了解，我们可以了解哪里可以让编译器产生优秀的汇编指令，减少PC跳转，以及不必要的内存访问或其他操作，这种操作是不取决于机器种类的；通过对处理器的了解，我们可以减少数据依赖，以达到最大的数据平行计算(parallelism)，追求最高的运行速度。我们通过不断修改自己的代码，从而达到一个模块化与高效性之间的平衡。 程序效率的表达&emsp;&emsp;由于程序效率跟处理数据的速度有关，对于程序的效率，书中用了“CPE”的单位来表达。即”Cycles per element”。取处理每个元素所需的处理器周期作为指标。通常，我们会取一组数字进行曲线拟合，获取一次多项式拟合的斜率作为衡量指标：CPE。(Figure5.2)&emsp;&emsp;这里的周期，是指完成一个元素处理所需要的平均周期。在对这个元素进行处理的时候，需要的周期越短，速度就越快。$$CPE = \\frac{cycles}{element}$$&emsp;&emsp;在图5.2中，psum1的CPE是9.0， psum2的是6.0。可见，面对不同的策略，显然效率有所不同。&emsp;&emsp;这里的周期，是指完成一个元素处理所需要的平均周期。在对这个元素进行处理的时候，需要的周期越短，速度就越快。同时，衡量一个程序是否优化到瓶颈，还需要更多的衡量标准。现有的衡量标准，是在一定的CPU指标的基础上进行度量。我们的样例CPU(Core i7 4e)的性能进行分析也是如此。度量的方法有： 单位耗时(latency): 做连续同一种运算时，每次运算所需消耗的时间。 吞吐量极限(throuput bound): 跟CPU的吞吐能力有关 处理时间(issue time): 每条指令处理时间 处理容量(capability): 与CPU功能单元有关的能力 例如：（单位：CPE） op Latency Issue capacity float addition 3 1 1 int addition 3 1 4 float multiplication 5 1 2 这些指标跟CPU以及程序的运行状态息息相关，因为它们标志着处理器的能力极限。也就是说，越接近处理器本身的极限，程序优化得就越好。其中latency bound是一个常用的极限，然后throughput bound是最终得极限。有了这样的基准之后，我们就可以测试程序的运行效率了。同时，在编译的时候我们开启 -O1 优化开关，利用优化前后的比较观察优化效果。 编译器视角的优化&emsp;&emsp;从编译器的视角优化，意思是写出能让编译器能产生更高效的汇编指令的代码。在这个层面上，我们就需要理解编译器所做的工作。 编译器的能力与障碍&emsp;&emsp;现代编译器大多数情况下会用复杂的算法分析我们的代码并进行优化。同时，它通常附带有-Og,-O1等优化开关，允许我们决定优化的激进程度。这种编译编译器取决的优化工作我们很难进行处理。然而，许多工作都是原有的优化无法完成的，这些无法完成的工作称之为“优化障碍”( optimization blockers )。这种优化障碍在编译器层面是无可避免的，因为只它会在安全的基础上优化我们的代码，使其在汇编层面上更加高效。for example:12345678void twiddle1(long *xp, long *yp) { *xp += *yp; *xp += *yp;}void twiddle2(long *xp, long *yp) { *xp += 2 * *yp;} &emsp;&emsp;显然，twiddle1相对于twiddle2低效，因为第一个进行了6次内存访存，第二个进行了3次。然编译编译器并不会把第一种优化成第二种，因为涉及到了内存别名(memory aliasing)问题。若第一次输入的参数为(xp, xp), 则两次运算都只是对xp进行操作。这样产生的效果，或副作用(side effact)就与twiddle2不一致。这种改变行为的优化，编译器不会做。&emsp;&emsp;不仅如此，在函数调用方面，大多数编译器也不会判断一个函数是否造成了副作用。因此在优化的时候总是以最坏情况来做，即保留原有的函数调用。如：12345678long f();long func1() { return f()+ f()+ f()+ f();}long func2() { return 4 * f();} &emsp;&emsp;编译器不会把第一种优化以达到第二种的效果，它会保留函数调用，每次触发就进行一次跳转，返回。因为它不会预测f()是否改变了什么。 &emsp;&emsp;不过，其中的一个小插曲是，尽管编译器通常有优化开关，例如在优化参数为-O2的甚至更高时候，编译器就会更加激进地修饰代码，但这样就提高了潜在的副作用上的风险。&emsp;&emsp;举个书本外的例子：12345678910111213141516171819202122232425262728#include &lt;cstdint&gt;#include &lt;iostream&gt;#ifndef count#define count 2000#endif__inline__ uint64_t perf_counter(void) { uint32_t lo, hi; // take time stamp counter, rdtscp does serialize by itself, and is much // cheaper than using CPUID __asm__ __volatile__(\"rdtscp\" : \"=a\"(lo), \"=d\"(hi)); return ((uint64_t)lo) | (((uint64_t)hi) &lt;&lt; 32);}int main() { int i = 0; int a[count]; uint64_t t1 = perf_counter(); while (i++ &lt; count / 3) { a[3 * i - 3] = 11; a[3 * i - 2] = 11; a[3 * i - 1] = 111; a[3 * i] = 121; } uint64_t t2 = perf_counter(); std::cout &lt;&lt; t2 - t1 &lt;&lt; std::endl; return 0;} &emsp;&emsp;这个程序嵌入了一段汇编代码，以读取执行while循环前后的CPU周期差值。当默认优化或者为-O1的时候，程序正常输出周期差；但如果开启了-O2（在Apple clang 8.0.0 下），情况就不一样了。输出的并不是我们想要的结果。 &emsp;&emsp;鉴于此，我们就有在编译器层面上优化的思路了。 在书中我们多次使用了下面这个程序样本：这是一个向量的实现，效果类似于c++ STL里面的vector：12345678910111213141516171819202122#define OP *#define IDENT 1/* Create vector of specified length */vec_ptr new_vec(long len);/* Retrieve vector element and store at dest */int get_vec_element(vec_ptr v, long index, data_t *dest);/* Return lenght of */long vec_length(vec_ptr v);void combine1(vec_ptr v, data_t *dest) { long i; *dest = IDENT; for(i = 0; i &lt; vec_length(v); i++) { data_t val; get_vec_element(v, i, &amp;val); *dest = *dest OP val; }} &emsp;&emsp;全章基本上都沿用这样的个例子的延伸，所以我们的阐述也围绕它进行。 在这里，我们可以做的工作有： 优化循环效率 降低过程调用 去除不必要的内存访问 这三项工作是相辅相成的，它们的结合才会有最优的结果。 1.1 优化循环效率&emsp;&emsp;从combine1中我们不难观察到，对整个combine函数影响最大的是 for 循环。因为它是函数的功能主题。通过观测可以得到书本上的值： Function Page Method + (int) * (int) +(float) * (float) combine1 507 -Og 22.68 20.02 19.98 20.18 combine1 507 -O1 10.12 10.12 10.17 11.14 也就是说，combine1在开启O1的时候，CPE是10.12到11.17之间。但如果改变了循环的方式，就可以得到更好的结果。 123456789101112131415161718192021/* * Retrieve vector element and store at dest. * Return 0 (out of bounds) or 1 (successful) */int get_vec_element(vec_ptr v, long index, data_t *dest) { if (index &lt; 0 || index &gt;= v-&gt;len) return 0; *dest = v-&gt;data[index]; return 1;}/* Move call to vec_length out of loop */void combine2(vec_ptr v, data_t *dest) { int i; int length = vec_length(v); for(i = 0; i &lt; length; i++){ data_t val; get_vec_element(v, i, &amp;val); *dest = *dest OP val; }} 在这种策略下，这个函数的CPE可以得到一定的提升。 Function Page Method + (int) * (int) +(float) * (float) combine1 507 -O1 10.12 10.12 10.17 11.14 combine2 509 Move vec_length 7.02 9.03 9.02 11.03 这里的函数和combine1()明显不同的是，每次循环调用的vec_length()移到了外部。这是一种代码移动(code motion)工作，意图将循环无关变量vec_length(v)在外部进行初始化以达到优化效果，因而又称为loop invariant code motion。 Loop-invariant code which has been hoisted out of a loop is executed less often, providing a speedup. We can therefore move the computation to an earlier section of the code that does not get evaluated as often. wikipedia: Loop-invariant code motion 在这里感谢小神师兄的指正。此处因为代码移动而非代码修饰，修饰可以参阅ECMAScript 6的【修饰器】部分 &emsp;&emsp;这种编译器因为可能的副作用问题不会而不会做的优化需要我们自己做。在此，就需要辨别一些循环中被计算多遍但却不会变的过程计算。第一个过程中，对于每次循环，都会调用一次vec_length() 函数。修改后的代码只调用了一次 vec_length 。这样，循环就减少了函数调用，去除了重复的长度计算，降低了耗时。 这种排除循环无关变量重复迭代的方法有时候效果是显著的。甚至极端情况下可以避免潜在的渐近时间复杂度提升。一个极端的例子：string.h 中有叫strlen()的函数，它通过遍历每一个字符来获取字符串的长度。如果我把函数调用放在循环里：12345const char str[]=\"VeryGG!!!\";for(int i = 0; i &lt; strlen(str); i++) { // statement // O(n)} &emsp;&emsp;虽然看上去没毛病，但其实这里就已经有个潜在的 $O(n^2)$ 。因为strlen()的机制，每次循环都要遍历整个字符串，加上原始的 $O(n)$ ，那就成了一个指数渐进的循环。而这种低效对程序效率的影响是致命的，它会严重拉低程序的效率。 &emsp;&emsp;两种循环的效率大概如下图： &emsp;&emsp;为何这样渺小的修改可以得到效率的提高呢？这就需要理解编译器的工作。编译器在编译第一个函数的时候，对于每次循环，都会调用一次 vec_length() 函数。修改后的代码只调用了一次 vec_length 函数。这样，循环就减少了函数调用，降低了耗时。&emsp;&emsp;这种做法确实加快了运行速度。然而，这种代码移动并非编译器都会为开发者完成。因为修改前后可能面临着结果不同的问题，也就是副作用(site effact)问题。如果一个函数在优化前和优化后对于预料，或者说任何结果都是没有差异的，那优化就是有效的。但面对这种做法的时候，遇到指针别名问题(Pointer Aliasing)等问题时，结果是会出现差异的。尽管编译器试图采用代码移动，但局限性导致其采取了保守的策略。在优化参数为-O2的甚至更高时候，编译器就会更加激进移动代码，但这样就提高了潜在的副作用上的风险。 降低过程调用降低过程调用的意图非常明显。过程调用中因常出现重复计算或检索问题(overhead)而导致低效。例如下列过程调用：123456789101112131415/* get_vec_start */data_t *get_vec_start(vec_ptr v) { return v-&gt;data;}/* Direct access to vector data */void combine3(vec_ptr v, data_t *dest) { long i; long length = vec_length(v); data_t *data = get_vec_start(v); *dest = IDENT; // identical element for (i = 0; i &lt; length; i++) { *dest = *dest OP data[i]; // OP refer to + or * }} combine3的for 比combine2中的高效，因为combine2中每次检索数据都要将向量遍历一遍（成功或失败都类似）。此处通过将读取容器元素的过程改写为直接访问地址，从而降低过程调用，提高了效率。这种直接的地址访问降低了过程运行的成本。类似的降低过程调用的工作几近优化程序的瓶颈。 1.3 减少内存访问&emsp;&emsp;内存访问的速度比寄存器访问慢很多，这是……正常人都知道的常识。减少内存访问，即利用临时(循环)变量来替代直接的指针迭代。如果每一次迭代都通过指针解引用来更改所指的数据，那即意味着每次都要从内存读取写入（这只是通用的直观的说法，更复杂的情况应该在处理器视角参数）。这样相对于直接的变量迭代效率一定是低下的。&emsp;&emsp;有几种很常见的状况： 指针作为迭代变量 指针搜索与位移 &emsp;&emsp;在这里就不举例子了，自己意会哈～ 小结&emsp;&emsp;通过了解编译器的能力与限制，我们就可以对症下药，而不是盲目地降低程序的可读性与模块化程度，给自己和他人的理解带来困扰，破坏软件工程的基本原则。在现代足够智能的编译器的情况下，认识到在这个视角能干什么显得非常必要。 处理器视角的优化&emsp;&emsp;处理器视角优化，相对于前者而言，是在机器层面上的优化。不同的机器有不同的特点，所以要根据机器来处理细节。但是，在不失一般性的情况下，具有相似的策略。所以，我们就根据样本机器来分析。不同机器就要有细节上的修饰。&emsp;&emsp;现代处理器和第四章的流水线模型也有很大的不同。现代乱序处理器更复杂。现代乱序处理器简单区分呢ICU（Instruction Control Unit）和EU（Executive Unit）。&emsp;&emsp;总的来说，现代CPU有能力超前地获取即将运行的数据与指令，并利用分支预测，进行提前演算，在分支语句被执行的时候决定是否运行、写入。存储与加载在cache存在的情况下，也有能力超前地fetch数据。在此其中，在数据处理的速度方面，最主要关系的就是EU中的功能单元——处理单一state的基础模块。一个CPU中可能有多个这样的模块，而这些模块能否最大化并行地运作，运作结果是否有效，很大程度上决定了程序能否高效运行。而数据能否在处理器层面并行地运算，又与数据的依赖程度有关。数据超前运算是否生效，又与分支预测的结果相关。因此， 尽量在数据上降低依赖程度，实现并行处理的最大化， 降低分支预测错误概率，避免误判的时间高消耗， 我们就有机会写出高效运行的代码。 &emsp;&emsp;我们在这一章节上的讨论，基于 Intel i7 Haswell 这一样本机器。它拥有8个功能单元，基本情况是： Integer arithmetic, floating-point multiplication, integer and floating-point division, branches Integer arithmetic, floating-point addition, integer multiplication, floating-point multiplication Load, address computation Load, address computation Store Integer arithmetic Integer arithmetic, branches Store address computation 在这样的情况下，可以实现的效果： Operation Latency Issue Capacity (integer) Addition 1 1 4 Multiplication 3 1 1 Division 3-30 3-30 1 (floating point) Addition 3 1 1 Multiplication 5 1 2 Capacity 3-15 3-15 1 &emsp;&emsp;根据这样详细的定义，排除cache方面可能的干扰，我们就可以在样本机上量化计算了。 书中对于降低依赖程度有如下方法： 循环解元(loop unrolling) 提高平行性(enhancing Parallelism) 对于降低跳转误判概率，解释比较简略，即尽量让编译器生成CMOV的代码，而不是JMP。 在此之前，我们要有一定的语言与方法来判断数据（指令）的依赖性，以及指令的执行流程。因此运用了数据流程图(Data-flow graph)这么个方法解释。如，对于书中的combine4，汇编的结果为：1234567combine4: data_t = float, OP = *i in %rdx, data in %rax, limit in %rbp, acc in %xmm0.L488: mulss (%rax, %rdx, 4), %xmm0 # Multiply acc by data[i] addq $1, %rdx # Increment i cmpq %rd, %rbp # Compare limit:i jg .L488 # If &gt;, goto loop 得到的data-flow graph为：![屏幕快照 2017-11-03 下午10.12.35.png][5]经过重新编排，我们就可以知晓数据之间的依赖性。![20171103.png][6]所以在这个函数里头，load-&gt;mul是一条主要时间线，这一次迭代的主要影响就跟乘法相关。 在这样的语言表示下，我们就有办法解释为什么循环解元与平行增强对程序起优化作用了。 循环解元(loop unrolling)&emsp;&emsp;loop unrolling的思路是，通过在计算上的分步运行并最终合并结果，实现提高一次循环中CPE的效果。简而言之，就是将一次循环所能做的元素修改提高。其实在这个方法上与增强平行性是相辅相成的，因为分开进行运算意味着更充分地使用了有效的function unit。 举个🌰：1234567int combine(int arr[10]) { int i, acc = 0; for(i = 0; i &lt; 10; i++) { acc += arr[i]; } return acc;} 这种情况下，效率是1x线性的，因为每次处理一个元素。稍加修饰，就可以变得约为2倍。123456789101112int combine(int arr[n]) { int it = n / 2 * 2; int i, acc = 0, acc1 = 0; for(i = 0; i &lt; it; i+=2) { acc += arr[i]; acc1 += arr[i+1]; } for(;i &lt; n; i++) { acc += arr[i]; } return acc + acc1;} &emsp;&emsp;这样的代码修饰，实现了一次迭代中并行地处理2个数据。因为acc与acc1没有耦合，处理器可以并行地进行计算。如此修改，提高了处理单元上的并行性，因为样本机器一次可处理的4个加法，大于目前的所需并行计算数目，速度约为原来的2x。然这种k-degree并非越大越好，因为unrolling后如果degree太高，会产生加载、计算上的等待，造成debuff。 依赖解绑&emsp;&emsp;依赖解绑的意思是，可以分开算的数据，就不要使其出现依赖关系。因为一旦没有依赖，可以并行地计算。for example， 12345678int calcu(int arr1[n], int x) { int tmp = 1; int acc = arr1[0]; for(int i = 1; i &lt; n; i++) { tmp *= x; acc += arr[i] * tmp; } return acc; &emsp;&emsp;这是经典的输入一个多项式以及x，输出运算结果的函数。它没有经过解元的操作，以便我们的讲解。因此，它的效率是较为一般的。然而，另一种，依据秦九韶算法: $$a_0 + x(a_1 + x(a_2+…+ x(a_{n-1} + xa_n)…))$$即：123456789int calcu1(int arr1[n], int x) { int i; // int tmp = x; int acc = arr1[n]; for ( i = n - 1; i &gt;= 0; i--) { acc = arr1[i] + x * acc; } return acc;} 这种写法是及其低效的！现代处理器在cache的帮助下，可以在上一次循环的时候就加载下一次循环中所需要的数据；而修改后的代码每一次的运算都基于上一次的结果，产生了一个load-use dependency; 而前一个函数中，tmp 和 acc 是独立开来的，他们的运算是并行的，而且每次算好只要加载进入下一次循环即可立即使用。。这样，就会把load的时间插在了use的前面，而不是独立开来。也就是说：123456789101112131415161718192021222324252627282930313233改变之前：(运行时间）+-----+ +----+| cal | | ld || | | || | | || | +----+| | +----+| | | ld |+-----+ | |+-----+ | || cal | +----+| | | || | | || |+-----+改变之后：(运行时间）+-----+| cal || || || || || |+-----++-----+| || ld || |+-----+ 1234567891011121314151617 || arr[n] x || || | |+-----+ +--------+ +-----+| acc | | arr[n] | | x || | | (load) | | |+-----+ +--------+ +-----+ || ||________| | || |___________| || || | | ||_____(calcu)___|| | | |_________________| | | || | | || | |+-----+ +--------+ +-----+| acc | | arr[n] | | x || | | (load) | | |+-----+ +--------+ +-----+ load-use独立开来，时间就取决于use，而不是 load + use。这就是高效之处。由此可知，上述两种方法相互依赖。结合使用，才能有效地进行系数级别的优化。 减少跳转&emsp;&emsp;减少跳转的关键在于，使得代码尽量使用CMOV, 而不是JMP。因为JMP涉及了PC更改以及预运算清空问题，产生了时延（参考第4章中PIPE的实现）。例如，可以用三目运算符处理的，不用if...else；尽量用inline等。现代处理器已经可以90%做出准确判断，例如循环的实现，不必产生任何跳转。只有在循环结束、条件函数调用的时候，才可能产生跳转。因此，这方面我们能做的比较少。 优化的限制因素寄存器个数限制&emsp;&emsp;寄存器的个数决定了一次可以load的数量。一旦 loop unrolling 过度，超过了寄存器可以承载的数量，就会产生penalties。这个比较好理解。 跳转问题&emsp;&emsp;跳转问题通常无法解决，因为取决于处理器的算法问题。但我们可以尽量使得其产生CMOV的代码，处理器会分别计算然后加载所需要的数值。这样就免除了跳转中产生的时延。 未竟之处书本对优化的阐述依然留下了一些问题。例如，我们假设处理器是单核的，而现代处理器一般都有多核运行；同时，也没有考虑多线程、多进程问题。然在我们阐述的模型基础上，我们可以预测可以做到的更多的操作。 总结&emsp;&emsp;CS:APP 第5章根据编译器和处理器的特性，描述了一个完整的程序优化蓝图。现代的编译器已经足够智能，善于尽可能地产生最优的代码；现代处理器也同样如此，会尽量地跑满所有的功能单元。而我们需要做的，就是完成编译器、处理器无法完成的工作，解决数据搜寻中的低效问题，解绑数据依赖，从而让机器能够在数据安全的情况下，在 function unit 层面上并行地计算。如此针对性地进行优化，而不是做类似于 i / 2 改成 i &gt;&gt; 2 ，以及将函数融合到一起之类的的动作，我们就可以在尽量不降低程序模块与可读性上，真正达到优化的目的，而不是既没有提高效率，又使得代码不必要地丑陋。","link":"/2017/09/27/opt-program-perf/"},{"title":"CS: APP chapter 3 notes: (variable) stack frame","text":"IntroductionChapter III of CS: APP mainly describes x86_64 assembly in details, which gives a dictionary-like introduction. Nevertheless, the reason why performming this chapter is to give a vivid adhere of chapter V. In this post, I just elaborate a small part introduced by a few of section, that is the runtime stack.Refers to section 3.7~3.10, Stack frame is a major part in procedure calling and manipulation. It stores variables, procedure return address, and any thing may be pushed in according to complier’s flavor. Big picture Stack frame is a memory structure holds procedure. The main function of it is similar to the figure delivered above: control transfer, data transfer, local variables storage. Notes: Regarding the array and struct or union, however, they are just stored in memory, without being specified whether should be stored in stack or heap file. Every function refers to a particular interval of stack. As figured in the picture above, stack stores arguments for the calling of next procedure, caller preserve variable in register and memory and return address of the caller, which note as the PC back point. When we combine control and data together, it will be more complex than before. That is what we refer as variable stack frame, and another miscellaneous. Control transferControl transfer of procedure refers to the function calling. Suppose that function P() wonna call function Q(), once you embody this process, the program should pass some arguments, transfer the PC of %rip to the function Q(), then it go through the instructions in Q(), at last go back to the origin address of %rip when meet ret, which means that return the funtion P(). In x86_64 instruction set, there are three control instructions: Instruction Description call Label Procedure call call *Operand ;; ret Return from call The call instruction has a target indicating the address of the instruction where the called procedure starts. Its operand, which is the address, could be direct or indirect. Go back to figure 3.3 could get more details. Suppose we have details of function below: 1234567891011121314151617181920212223Q: 0x400540 addq %rdi, %rdi 0x400543 movq %rdi, %rax 0x400546 ret P: 0x400560 movq $-1, %rdi 0x400563 call Q 0x400568 ret-------Origin status before call-------%rsp: 0x7fffffffe888 --&gt; 0x0%rip: 0x400560----------------------------------------------After execute call--------------%rsp: 0x7fffffffe880 --&gt; 0x400568(The address of the next ins of call)%rip: 0x400540 (The atart of Q)---------------------------------------------------After ret------------------%rsp: 0x7fffffffe888 --&gt; 0x0%rip: 0x400568 (last ins of P)--------------------------------------- In this simple case, once P call Q, P push its next instruction address as its return address to the stack, then %rip gets start address of Q. When meeting ret, %rip get that address from stack then add address of %rsp according to the size of the cell. It is easy, right? Data transferWhen passing control to another procedure, we usually pass arguments to the callee one, so as to evaluate the data then get target result. As is mentioned before, we refer %rdi as the 1st argument, %rsi the second, and so on. It is a convention of how x86-64 pass arguments. Marked in details, as below: Argument sequence Registers notes 1st %rdi few bits portable 2nd %rsi could be accept 3rd %rdx 4th %rcx 5th %r8 6th %r9 more than 6 STORE IN STACK The point here is, also combine the control transmission, the caller should push it’s variable stored in callee saved registers, set the argument registers into target arguments, after preparing for the function call, the PC go to the target procedure. As an example: 123456789101112131415161718192021222324252627282930proc: pushq %rbp movq %rsp, %rbp # %rbp is a caller saved register add %edi, %esi # add %rdi to %rsi add %rsi, %rdx # --- add %rdx, %rcx # --- sub %rcx, %r8 # --- movq %r8, %rax # --- popq %rbp ret # return call_proc: sub $16, %rsp movq %edi, 8(%rsp) xorq %edi, %edi add $0x8, %edi movq $0x10, %esi movq %0x43(%rsp), %rdx movq $0x125 %rcx call proc movq (%rsp), %edi addq %edi, %rax ret # -------- stack result ---------# | | orig %edi | 8# | (unused) | 0# | return address | -# | orig rbp: 0x0 | callee - 8# ------------------------------- Notes: the unused space is prepare for SIMD usage. On this stage, we can ignore it. The caller saved register %rbp is pushed and set it as origin stack start position. Local variable storageThere many example that variable are stored in registers, but at times that local variable should be load in memory. The common cases is: There are not enough registers to hold all of the local data The address operator ‘&amp;’ is applied to local variable, and hense we must be able to generate an address for it Some of the local variables are arrays or structures so that it should be accessed as array or structure references. As for example code, please refer Figure 3.32 In convention, the former variable should be pushed in the higher address of stack and the later ones could be set in the lower ones. Such as: 1234|_____________________||___x2____|____x1_____| 16|_________x3__________| 8|_______________|__x4_| 0 AlignmentMany computer systems place restrictions on the allowable addresses for primitive data types, requiring that the address for some objects must be a multiple of some value K. Such restrictions simplify the design of hardware forming the interface between the processor and the memory system. Also, address of stack frame do the same thing, so as to be refered in a correct way. As an example of Practice Problem 3.49, 123456789101112131415+------------------------++ return address + 8+------------------------++ saved %rbp + 0+------------------------++ (Unused) + -8+------------------------++ + e1+------------------------++ ++ P + 8n bytes+ ++------------------------++ + e2+------------------------+ Every part of the stack frame should be a multiple of 8, so that e1+P+e2 should be a multiple of 16, hense we could embed a slot of memory which address is a multiple of 8. Variable-Size Stack FramesThe variable-size stack frames means that the size of stack frame could not be determined at compile time. Further more, the variable, maybe array of struct, should be referenced by its address. Therefore, we should use a technique of managing such condition. As Figure 3.43 : 12345678long vframe(long n, long idx, long *q) { long i; long *p[n]; p[0] = &amp;i; for (i = 1; i &lt; n; i++) p[i] = q; return *p[idx];} Portions of generated assembly code: 1234567891011121314151617181920212223242526vframe: pushq %rbp # Set old %rbp movq %rsp, %rbp # Set frame pointer subq $16, %rsp # Allocate space for array p leaq 22(, %rdi, 8), %rax # Make it to be a multiple of 16 andq $-16, %rax subq %rax, %rsp # Allocate space for array p leaq 7(%rsp), %rax shrq $3, %rax leaq 0(, %rax, 8), %r8 movq %r8, %rcx # ..... .L3: movq %rdx, (%rcx, %rax, 8) # Set p[i] to q addq $1, %rax # Increment i movq %rax, -8(%rbp) # Store on the stack.L2: movq -8(%rbp), %rax # Retrieve i cmpq %rdi, %rax jl .L3 # ..... leave ret Note the way to refer the array is that, it refer it by pointer register %rbpAt last of the program, it restore the original pointer to the %rsp, then pop %rbp to restore the caller’s frame. 12movq %rbp, %rsp # Set stack pointer to beginning of framepopq %rbp # Restore This instruction combination has the effect of deallocating the entire stack frame.","link":"/2017/09/05/stack-frame/"},{"title":"计网-静态路由实验解析","text":"网络架构拓扑结构 根据实验手册的规定，拓扑结构如上图： 整个拓扑结构被划分为3个网段：10，11，12。其中10段为路由器之间的段，11段为Router1与PCA之间的段，12段为Router2与PCB之间的段。路由器为多端设备，因此每个端口都有一个IP地址；PC为单端设备，只有一个IP地址。 根据实验的设置，整个结构包含三个网，网络地址分别为： 10.0.0.0 11.0.0.0 12.0.0.0 三个地址对应三个网的划分。主机PCA想要到达PCB，途中必须经过两个路由器，vice versa。 路由器命令解释 1234567891011121314sys # 进入系统设置模式sysname RT1 # 设置系统名字为RT1int e 0/0 # 进入以太网0号端口进行设置ip addr 10.0.0.1 24 # 设置该端口(0号)IP地址为10.0.0.1，子网掩码包含24位(e 0/1 类似)display ip routing-table # 显示，IP协议的设置，路由表# 设置静态路由，三个参数分别为：目标地址，子网掩码，下一跳地址ip route-static &lt;destinaton&gt; &lt;subnet mask&gt; &lt;nexthop&gt;ip route-static 10.0.0.0 255.255.255.0 10.0.0.2# 去往10.0.0.0网路，子网掩码为3个255，需要的下一个路由为10.0.0.2undo ... # 撤销某条命令 路由表状态解释 12345Destination/Mask Protocol Pre Cost Nexthop Interface(目标地址) 协议 下一跳 网络接口需要前去的目标主机 路由协议 这两个不知道 前往该主机， 对应的网口（或者回环） 需要向哪个 回环就是自己 端口发送数据 例如： 12310.0.0.0/24 Direct 0 0 10.0.0.2 Ethernet0/0前往10.0.0.0这个网，需要向10.0.0.2发送数据。这个路由是接口直接连接得来的，所以协议为Direct（直接） ![未命名文件 (3).png][1] 因此，在这个拓扑内： PCA ping Router1是可以ping通的，在设置了PCA的IP地址后；Router1 对 Router2是可以ping通的，其他直连路亦然。因为他们直接连起来了。 然鹅，PCA是不可以ping通PCB的，Router2也不可以ping通PCA的。R1同样ping不通PCB的。Why？这里就要解释一下ping的原理和路由的原理。 路由 路由，route，意思是，路径，即从某点a到某点b的一条道路。路由包含了目标地址，下一跳地址。也就是说，以上面的为例子，去往10.0.0.0这个网，路由器需要发往10.0.0.2这个地址。也就是说，然鹅，在没有设置路由的情况下，PCB想要到PCA，它把包发给Router2，（因为只有一个口可以发出去），然鹅router2不知道该发给谁，它就把包丢掉了。所以设置之前，PCA和PCB是不互联的。 在后续的实验步骤中，包含了设置路由的操作，目的就是告诉路由器，前往11，或者12这两个网段，需要把包发给谁。例如，在Router1设置： 1ip route-static 12.0.0.0 255.255.255.0 10.0.0.2 就是告诉路由器，若11段要前往12段，需要把数据包发给10.0.0.2这个口。子网掩码是为了确认两个网是平行的，不属于谁的子网。 设置完这个选项后，当PCA发送包出去，发送给路由器时，路由器就会发送给10.0.0.2这个口。于是Router2就会把数据包根据目标地址，发出去了。于是乎PCA就可以到达PCB。 在Router2的设置是类似的，为了让12段可以到达11段。 然鹅，只设置一边是不可以ping通的。Why？这里解释一下ping的原理。 ping program ping常用来检测路径的连通情况。需要双向可达，这样才可以ping通。这是因为ping利用的ICMP协议，ping的主机发送请求，被ping的主机收到请求后回复。至于ICMP是什么，超出了我们要讨论的范围。我们知道这是一种IP层协议，以及ping的过程需要主机向目标发送请求，目标返回一个信号。 ping的工作过程如下： ping程序以目标IP为地址，发送一个ICMP包(echo request)。ICMP通过一定的路径，到达了目标。目标收到后，立刻返回一个信号(echo reply)。ping主机收到信号后，就确定，在两台主机之间，存在一条通路，可以从一端到达另一端。如果这个包在中途被丢掉了，不管是在哪儿丢的，最后ping的主机都无法收到回复，超出了一定的时间无法收到回复后，发送端便认为，目标不可达。 ping的过程就是如此。若不存在一条路由，使得两端双向可达，哪怕存在链路，也是不可以ping通的。这就解释了为什么设置一端ping不通。假设ping的数据包从A主机发出，在Router1的指引下去到了Router2，然后Router2分发给了B。B立刻对A的地址进行回复，然鹅到了Router2后，Router2不知道发给谁，就把这个包视为非法包(invalid)，对其丢弃。因此B的回复永远到不了A，A就会超时，自然会不通了。 设置过程 设置路由器端口IP、主机IP（略） 查看路由表（略） 第十步：添加静态路由。这里就是把路由器添加一条静态路由，目标网络为12.0.0.0，下一跳地址为10.0.0.2。回到上图，就是Router2的en0/0。因为对于路由器1，想要到达12网，就必须从10.0.0.2这个口进去。然后发生了什么，路由器1就不需要知道了。这样，一切从11段发出去的，以及路由器1发出去的，都会被发往10.0.0.2。 从PCA ping Router2的10.0.0.2以及ping PCB 这里，结论是，ping 10.0.0.2不可以通，PCB也通不了。原因是，Router2和Router1直接相连，因此Router1知道去往10段需要发给Router1的10.0.0.2口。因此，ping 10.0.0.2时，数据包从A主机跳到Router1，Router1查表，发现目标是router2的一个口，而且是直连的，就发出去了。router2的10.0.0.2收到后，立刻响应，然而路由2没有一条通往11段的记录，就无法把包回给11网段，因此被丢弃。ping B主机的原理类似，包到达Router1，Router1发给Router2，Router2分发给PCB，PCB回复，但Router2不知道发给谁，丢弃，A主机就永远收不到回复了。GG！ 在Router2添加一条到11段的路由 Router2添加完这条路由，跟上文阐述的类似，它就知道了去往11段是要发给10.0.0.1了。所以，从A主机ping B，或者Router2，当B主机或者Router2回复的时候，回复的数据包到了Router2，就被发往10.0.0.1。然后Router1收到，分发给自己或者A主机。收到请求，ping成功。 删除RT1添加的路由，添加默认路由 默认路由的意思是，当路由器找不到目标主机相应的下一跳，就会发给这个地址。例如，A发往B，经过路由器1，路由器1不知道发给谁，就发给默认的那个口。至于结果，路由器不管。 在这里，我们添加的路由是： 10.0.0.0 0.0.0.0 10.0.0.2 全0，代表任意IP地址，意思是，当找不到一条特殊约定的路由，就使用它。而由于默认路由的规定，发给了10.0.0.2。也就是说，找不到该发给谁，统统发给这个地址，10.0.0.2。 这样，第三次ping是可以ping通的。A发给了Router1，Router1找不到目标，发给了10.0.0.2，然鹅10.0.0.2就是我们要的目标，所以B可以收到，也可以回复。回复的数据包由于先前的设置，也会发回去。于是，ping成功。 一些其他的设置： 交换机与主机、路由器之间用直连线，路由器、主机之间用交叉线。交叉线就是两头线序不一样的线，比如棕色的那条，一个在一边，一个在另一边 设置交换机IP，也需要手动设置主机IP 从超级终端ping，是利用路由器ping出去。从cmd ping，才是从主机ping出去 交叉线不够，可以把直连线插交换机，交换机再接路由器，然后再从路由器连交换机，然后连路由器。（具体看操作吧，说不清楚了——）","link":"/2018/05/05/static_route_lab/"},{"title":"简注 - Differential Fault Analysis on AES","text":"Differential Fault Analysis, a.k.a DFA, 是一种侧信道分析手段。通过对二进制进行注入故障，将结果与原始运行时做差，在特定的平衡下可获得一轮的轮密钥。在最近的研究中，可被用来做白盒算法的密码分析。 简述本文为如下工作的总结： https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html Differential Computation Analysis: Hiding Your White-Box Designs is Not Enough. Joppe W. Bos, Charles Hubain, Wil Michiels and Philippe Teuwen, CHES 2016 Differential Fault Analysis on A.E.S. Pierre Dusart, Gilles Letourneux and Olivier Vivolo, ACNS 2003, pages 293-306 DFA攻击试图通过注入错误-与对照组求差求得轮密钥中的字节。针对一个状态注入时，每注入一个故障，可以扰乱4个轮密钥字节。重复此过程，就可以得到所有的状态轮密钥。DFA并不是最近才出现的一个新技术，而配合Deadpool，利用Tracer跟踪加密器整个运行过程，从中得到running trace, 经过计算可以针对性地得到攻击的某一环。获得一轮的密钥，是DFA攻击的目的。 执行过程差分故障的攻击执行过程大致如下： 通过一定的工具，判断AES每一轮状态的位置 针对特定轮状态，以及特定故障点： 状态正常运行一遍，得到状态$O$ 注入一个故障，运行，得到$O’$ 利用两次执行的差，针对每个差对进行计算，得到candidate fault的集 多次插入故障，得到不同解集，求交集。最后得到固定的结果 详述在AES（AES-128）的DFA中，最主要的是得到最后一轮$K_{10}$的值。因为一轮可以倒推出所有轮，这样就相当于得到了密钥。其主要内容就是在最后两轮MixColumn之间插入一个错误，观察错误的扩散情况，然后求值。从FIPS192知道，最后三轮的过程大约为： SubBytes ShiftRows MixColumns AddRoundKey $K_8$ SubBytes ShiftRows MixColumns AddRoundKey $K_9$ SubBytes ShiftRows AddRoundKey $K_{10}$ 由于故障插入位于两次MixColumn之间，所以只有一轮MixColumn会被执行。最终这个错误会被扩散到4个字节上。为方便讨论，我们在第9轮的MixColumn前插入故障，观察其扩散情况。以插入故障的运行过程为实验组，与未插入故障的运行为对照组。插入故障$X$。插入前后的对比：$$\\begin{pmatrix} A &amp; E &amp; I &amp; M \\\\ B &amp; F &amp; J &amp; N \\\\ C &amp; G &amp; K &amp; O \\\\ D &amp; H &amp; L &amp; P \\end{pmatrix} \\text{和} \\begin{pmatrix} X &amp; E &amp; I &amp; M \\\\ B &amp; F &amp; J &amp; N \\\\ C &amp; G &amp; K &amp; O \\\\ D &amp; H &amp; L &amp; P \\end{pmatrix}$$在此之后，实验组（插入故障组）与对照组将会同样进行以下操作： MixColumns AddRoundKey $K_9$ SubBytes ShiftRows AddRoundKey $K_{10}$ Mixcolumn后：$$\\begin{pmatrix} 2A+3B+C+D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ A+2B+3C+D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ A+B+2C+3D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ 3A+B+C+2D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\end{pmatrix} \\text{and} \\begin{pmatrix} 2X+3B+C+D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ X+2B+3C+D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ X+B+2C+3D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ 3X+B+C+2D &amp; \\cdots &amp; \\cdots &amp; \\cdots \\end{pmatrix}$$加入第9轮密钥：$$\\begin{pmatrix} 2A+3B+C+D+K_{9,0} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ A+2B+3C+D+K_{9,1} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ A+B+2C+3D+K_{9,2} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ 3A+B+C+2D+K_{9,3} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\end{pmatrix} \\text{and} \\begin{pmatrix} 2X+3B+C+D+K_{9,0} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ X+2B+3C+D+K_{9,1} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ X+B+2C+3D+K_{9,2} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ 3X+B+C+2D+K_{9,3} &amp; \\cdots &amp; \\cdots &amp; \\cdots \\end{pmatrix}$$ SubBytes:$$\\begin{pmatrix} S(2A+3B+C+D+K_{9,0}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ S(A+2B+3C+D+K_{9,1}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ S(A+B+2C+3D+K_{9,2}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ S(3A+B+C+2D+K_{9,3}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\end{pmatrix} \\text{and} \\begin{pmatrix} S(2X+3B+C+D+K_{9,0}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ S(X+2B+3C+D+K_{9,1}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ S(X+B+2C+3D+K_{9,2}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ S(3X+B+C+2D+K_{9,3}) &amp; \\cdots &amp; \\cdots &amp; \\cdots \\end{pmatrix}$$ ShiftRows:$$\\begin{pmatrix} S(2A+3B+C+D+K_{9,0}) \\qquad \\cdots \\qquad \\cdots \\qquad \\cdots \\\\ \\cdots \\qquad \\cdots \\qquad \\cdots \\qquad S(A+2B+3C+D+K_{9,1})\\\\ \\cdots \\qquad \\cdots \\qquad S(A+B+2C+3D+K_{9,2}) \\qquad \\cdots \\\\ \\cdots \\qquad S(3A+B+C+2D+K_{9,3}) \\qquad \\cdots \\qquad \\cdots \\end{pmatrix}\\\\ \\text{and} \\\\\\begin{pmatrix} S(2X+3B+C+D+K_{9,0}) \\qquad \\cdots \\qquad \\cdots \\qquad \\cdots \\\\ \\cdots \\qquad \\cdots \\qquad \\cdots \\qquad S(X+2B+3C+D+K_{9,1})\\\\ \\cdots \\qquad \\cdots \\qquad S(X+B+2C+3D+K_{9,2}) \\qquad \\cdots \\\\ \\cdots \\qquad S(3X+B+C+2D+K_{9,3}) \\qquad \\cdots \\qquad \\cdots \\end{pmatrix}$$ AddRoundKey $K_{10}$:$$\\begin{pmatrix} S(2A+3B+C+D+K_{9,0})+K_{10,0} \\qquad \\cdots \\qquad \\cdots \\qquad \\cdots \\\\ \\cdots \\qquad \\cdots \\qquad \\cdots \\qquad S(A+2B+3C+D+K_{9,1})+K_{10,13}\\\\ \\cdots \\qquad \\cdots \\qquad S(A+B+2C+3D+K_{9,2})+K_{10,10} \\qquad \\cdots \\\\ \\cdots \\qquad S(3A+B+C+2D+K_{9,3})+K_{10,7} \\qquad \\cdots \\qquad \\cdots \\end{pmatrix}\\\\ \\text{and}\\\\ \\begin{pmatrix} S(2X+3B+C+D+K_{9,0})+K_{10,0} \\qquad \\cdots \\qquad \\cdots \\qquad \\cdots \\\\ \\cdots \\qquad \\cdots \\qquad \\cdots \\qquad S(X+2B+3C+D+K_{9,1})+K_{10,13}\\\\ \\cdots \\qquad \\cdots \\qquad S(X+B+2C+3D+K_{9,2})+K_{10,10} \\qquad \\cdots \\\\ \\cdots \\qquad S(3X+B+C+2D+K_{9,3})+K_{10,7} \\qquad \\cdots \\qquad \\cdots \\end{pmatrix}$$ So，未修改过的结果为$O_0$, 修改过的结果为$O_0’$。(第0个字节，为0)$$O_0 = S(2A+3B+C+D+K_{9,0})+K_{10,0} \\\\O_0’ = S(2X+3B+C+D+K_{9,0})+K_{10,0}$$ 作差：（$GF(2^8)$，加即为减） $$O_0 + O’_0 = S(2A+3B+C+D+K_{9,0})+K_{10,0} + S(2X+3B+C+D+K_{9,0})+K_{10,0} \\\\O_0 + O’_0 = S(2A+3B+C+D+K_{9,0}) + S(2X+3B+C+D+K_{9,0})$$ 在后排的Sbox操作构造两个$2A$:$$O_0 + O’_0 = S(2A+3B+C+D+K_{9,0}) + S(2X+\\mathbf{2A+2A}+3B+C+D+K_{9,0})$$ 就可以得到：$$Y_0=2A+3B+C+D+K_{9,0}\\\\Z=A+X$$原式转换为：$$O_0 + O’_0 = S(Y_0) + S(2Z+Y_0)$$其他被影响的字节也类似：$$O_7 + O’_7 = S(Y_1) + S(3Z+Y_1) \\\\Y_1 = 3A+B+C+2D+K_{9,3} \\\\O_{10} + O’_{10} = S(Y_2) + S(Z+Y_2) \\\\Y_2 = A+B+2C+3D+K_{9,2} \\\\O_{13} + O’_{13} = S(Y_3) + S(Z+Y_3) \\\\Y_3 = A+2B+3C+D+K_{9,1} \\\\$$这4个等式联立。针对Z，只有给定的故障集合$x\\in X$才能联立。针对给定的故障X，存在一个求K解集。多次插入不同故障，最后求得交集，就是所需要的单一值。 问题注入点问题以chow’s implementation为例。如果所有的表被集成起来，那就无法区分出哪里是MixColumn了。无法从MixColumn注入。但是，根据Dusart et al的说明，只要注入点在两轮MixColumn之间，就可以完成。对于这个问题，作者菲利普·吐温用了对key file进行注入的方法来避开。也就是说，作者并没有直接把注入作用于二进制。它针对的地址空间是文件的地址空间。通过改写其中的一些字节，实现静态注入。 倘若是从第8轮完毕的state开始进行注入， 初始状态：$$\\left(\\begin{matrix}A &amp; E &amp; I &amp; M\\\\B &amp; F &amp; J &amp; N\\\\C &amp; G &amp; K &amp; O\\\\D &amp; H &amp; L &amp; P\\end{matrix}\\right)$$ SubBytes:$$\\left(\\begin{matrix}S{\\left(A \\right)} &amp; S{\\left(E \\right)} &amp; S{\\left(I \\right)} &amp; S{\\left(M \\right)}\\\\S{\\left(B \\right)} &amp; S{\\left(F \\right)} &amp; S{\\left(J \\right)} &amp; S{\\left(N \\right)}\\\\S{\\left(C \\right)} &amp; S{\\left(G \\right)} &amp; S{\\left(K \\right)} &amp; S{\\left(O \\right)}\\\\S{\\left(D \\right)} &amp; S{\\left(H \\right)} &amp; S{\\left(L \\right)} &amp; S{\\left(P \\right)}\\end{matrix}\\right)$$ ShiftRows:$$\\left(\\begin{matrix}S{\\left(A \\right)} &amp; S{\\left(E \\right)} &amp; S{\\left(I \\right)} &amp; S{\\left(M \\right)}\\\\S{\\left(F \\right)} &amp; S{\\left(J \\right)} &amp; S{\\left(N \\right)} &amp; S{\\left(B \\right)}\\\\S{\\left(K \\right)} &amp; S{\\left(O \\right)} &amp; S{\\left(C \\right)} &amp; S{\\left(G \\right)}\\\\S{\\left(P \\right)} &amp; S{\\left(D \\right)} &amp; S{\\left(H \\right)} &amp; S{\\left(L \\right)}\\end{matrix}\\right)$$ Mixcolumns:$$\\left(\\begin{matrix}K_{9} + 2 S{\\left(A \\right)} + 3 S{\\left(F \\right)} + S{\\left(K \\right)} + S{\\left(P \\right)} &amp; … &amp; … &amp; … \\\\ K_{9} + S{\\left(A \\right)} + 2 S{\\left(F \\right)} + 3 S{\\left(K \\right)} + S{\\left(P \\right)} &amp; … &amp; … &amp; …\\\\ … &amp; … &amp; … &amp; … \\\\ … &amp; … &amp; … &amp; …\\end{matrix}\\right)$$这就是State 9.简单带过一下，final state的state[0]为：$$K_{10} + S{\\left(K_{9} + 2 S{\\left(A \\right)} + 3 S{\\left(F \\right)} + S{\\left(K \\right)} + S{\\left(P \\right)} \\right)}\\\\K_{10} + S{\\left(K_{9} + 2 S{\\left(X \\right)} + 3 S{\\left(F \\right)} + S{\\left(K \\right)} + S{\\left(P \\right)} \\right)}$$两式相减：$$S{\\left(K_{9} + 2 S{\\left(A \\right)} + 3 S{\\left(F \\right)} + S{\\left(K \\right)} + S{\\left(P \\right)} \\right)} + S{\\left(K_{9} + 2 S{\\left(X \\right)} + 3 S{\\left(F \\right)} + S{\\left(K \\right)} + S{\\left(P \\right)} \\right)}$$设：$$Y_0 = K_9 + 2S(A)+ 3 S(F) + S(K) + S(P) \\\\Z = S(A) + S(X)$$ 同样地，对其他状态推导，只有符合特定条件的$S(X)$才能使得扩散的4个等式联立。 对WBAC-AES的影响内编码失效以chow’s implementation为例，包括encoding和Mixing Bijections。在encoding方面：$$T’ = g \\circ T \\circ f^{-1}$$对此类白盒实现的注入，相当于对lookup-table的注入。修改lookup-table的一个字节，其作用也可以在最后的结果反映出来。这并不影响以上描述的注入方式。 TODO 双路冗余的DFA 等效轮的DFA","link":"/2019/07/20/wbac_dfa/"},{"title":"洛谷P2803：带权中位数的思考","text":"带权中位数是CSP（NOIP）的一个常见问题。利用动态规划的方法寻找最佳落址。其中模板为邮局选址问题（post-office location problem）。这类问题有各种各样的衍生。这里我们讨论一道简单的变形：洛谷2803，小学生与小学选址。 原题目在洛谷P2803。 数学特性根据原题，虽然学校可以建在所有楼之间的任意一处，但可以证明，对于区间$[A, B]$中的一所小学，仅当小学位于某一楼的位置上，距离是最近的。这个假设可通过矛盾来证明。假设在两栋楼的区间$[A, B]$，拥有学校P，将所有的学生连线到这所学校。向左移动的连线为方向，向右移动的连线为正向，总长度为$P$。楼$A$有$a$人，楼$B$有$b$人:1A -- --&gt; B 设，有另一所小学在两栋楼之间，所有学生到该小学的总路程为$P’$。设这所小学从$A$出发，正向（向右）距离为$L$，则： $$P’ = P + L * a - L * b$$ 若$a &lt; b$，则必有向左移动到楼宇$A$，使得$P’$更小； 若$a &gt; b$，必有向右移动到楼宇$B$，使得$P’$更小； $a = b$，不管移动到A或B，都不劣。 于是得到结论：对于楼宇区间$[A, B]$，仅当学校处在某一楼宇处，所得的距离最短。 推论因为对于每个小学生，他们都需要走一定的路程到学校。对于拥有$a$人的楼$A$，到学校距离为$D$，所有小学生需要走的总路程为$a * D$。显然，我们可将每栋楼的小学生数量设置为该点的权值。 假设学校建设在楼A，其加权距离为$P$。则可以通过此距离推算其他点的距离，以找到区间$[A, B]$间的最优解：123456for (int mid = j + 1; mid &lt;= i; mid++) { // p for every position between A, B p = p + distance(mid - 1, mid) * weight(mid - 1, j) - distance(mid - 1, mid) * weight(i, mid); if (min &lt; p) min = p;} 推论 2根据上述代码，可知：当第一个位置，A到P人数&gt;=P到B人数时，此处为最佳位置。（p最小） 代码过程 处理输入，累计各点的位置和权值。-&gt; weight[i]，dis[i]如：权值为：24，18，32则：累计为：24，42，74距离为：10， 8累计为：0， 10， 18 记忆化搜索任意楼宇区间$[i, j]$ 找到区间i，j之间的权值中值 算这段区间的距离总长p 简单的背包问题改版，放学校 or 不放学校？ 假设n栋楼配备了 &gt;n 的学校，则距离为0 若n栋楼配备了1所学校，则跟2计算的结果相等 若对于区间$[a, b]$，算得最佳结果dp[a][b]，且仅剩一所学校跟一个区间，则加上这个区间的最小权值中值 可得，这道题用了DP，首先搜索最佳位置，然后放学校。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 105#define itn int#define INF 0x7fffffffint n, k;int dis[MAX];int weight[MAX];int best_sit[MAX][MAX];int dp[MAX][MAX];// calculate the distance between buildingsint distance(int a, int b) { return abs(dis[a] - dis[b]); }// calculate weight sum between buildingsint num(int a, int b) { int i = a, j = b; if (a &gt; b) { i = b; j = a; } return weight[j] - weight[i - 1];}int main() { using namespace std; ios::sync_with_stdio(); cin &gt;&gt; n &gt;&gt; k; memset(dp, 0, sizeof dp); memset(dis, 0, sizeof dis); memset(weight, 0, sizeof weight); memset(best_sit, 0, sizeof best_sit); for (int i = 1; i &lt;= n; i++) { int tmp; cin &gt;&gt; tmp; weight[i] = weight[i - 1] + tmp; } for (int i = 2; i &lt;= n; i++) { int tmp; cin &gt;&gt; tmp; dis[i] = dis[i - 1] + tmp; } int mid = 0; // 算爆每个区间仅有一座学校的情况 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { for (mid = j; mid &lt;= i; mid++) { if (num(j, mid) &gt;= num(mid + 1, i)) break; } if (mid &gt; i) mid = i; int p = 0; for (int l = j; l &lt;= i; l++) { p = p + distance(mid, l) * num(l, l); } best_sit[j][i] = p; } } // 求 i 栋楼，j 所学校情况下的最优子结构 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= k; j++) { if (j &gt;= i) dp[i][j] = 0; else if (j == 1) dp[i][j] = best_sit[1][i]; else { int min = INF; for (int l = 1; l &lt;= i; l++) { int tmp = dp[l - 1][j - 1] + best_sit[l][i]; if (tmp &lt; min) min = tmp; } dp[i][j] = min; } } } cout &lt;&lt; dp[n][k] &lt;&lt; endl; return 0;}","link":"/2020/01/25/weighted_medium/"},{"title":"关于个人小站的重建","text":"&emsp;&emsp;个人小站又打起来了，其实之前的域名 ping1008.me 可能更加有用些。然而由于操作的失误，一不小心把站点一股脑儿端掉了。而且这一次只用了hexo布设，部署在netlify中。 &emsp;&emsp;评论用了gitalk。小众，但是非常好用。而且管理是公开的。大家可以去相应的repo看。 &emsp;&emsp;也只是想到，一来我不常写博文，而来不常管理。应该不用怎么维护罢。233 &emsp;&emsp;另外，分享一个坚果云的链接。注册用户可以查看。里面有可能你需要的书籍。Here Update: 更新： 自有外链：Here 祝大家看得愉快。：）","link":"/2017/08/10/关于个人小站的重建/"},{"title":"简注 - A Tutorial on White-box AES","text":"白盒密码是对非可信平台下的密码算法安全实现的研究。其针对密码学算法在非可信平台设计实现，使得软件（数字内容）在具有完全操控（debugger，assembler）情况下获得安全保护。论文[^1]简要介绍AES在白盒攻击环境 (White-box Attack Context) 下AES的一种实现方式及其密码学分析。 简介白盒密码学 (White-box Cryptography) 意图设计特定实现，使得软件、数字资源等在不安全（非受信任）的环境下保护软件、资源的安全。白盒密码设计分析不同于像代码混淆[^2][^3]、控制流混淆这样的反逆向工程机制，它是纯粹针对算法安全性进行设计与分析[^4]。几乎所有的白盒密码学设计都针对对称加密算法，AES的设计就是典型之一。最初的白盒AES、DES由S. Chow，et.al 实现[^5]，后来该算法被攻破。随后不同的学者也相继发明了各种WBAC下的实现。根据Alex, et.al 对白盒的时间进行了分类：强白盒设计与弱白盒设计[^7]。弱白盒设计要求算法实现能保护密钥不可被发现与推导，保护密钥不受密钥恢复攻击(key recovery attack)。这种实现对于查表的逆向推导理论上是不可防护的。强白盒设计要求解密器不可从加密器推导，i.e.,plaintext-recovery attack。chow的实现是白盒的开篇，应该归类为弱白盒实现。 AES与矩阵查表操作AES拥有4个变换：轮钥加 (AddRoundKey)、行变换 (ShiftRows)、列混淆 (MixColumns)、字节替换 (SubBytes)[^6]。这些操作都可以归结为查表操作。查表操作的可逆转性是非常强的，很容易得到原生结果。其中，行变换是线性的，跟轮钥加可以进行位置上的替换。只要先对原有矩阵进行行变换，然后异或行变换过的轮密钥，这样这两个操作跟原有设计结果上没有差别。其次我们可以把第一轮异或加入到循环中，最后一轮异或移出循环。这种数学上的正确性有利于我们对AES查表操作 (table lookup) 性质的解析。得到的结果： 1234567891011state &lt;- plaintextfor r = 1 to 9: ShiftRows(state) AddRoundKey(state, k1[r-1]) SubBytes(state) MixColumns(state)ShiftRows(state)AddRoundKey(state, k1[9])SubBytes(state)AddRoundKey(state, k1[10])ciphertext &lt;- state 其中，k1[r-1]是进行行变换过的轮密钥。 上述算法描述中，AddRoundKey 和 SubBytes 可以对原有的S-Box合并： T-boxes$$T^r_i(x) = S(x \\oplus k1_{r-1}[i]), (i = 0…15, r=1…9)$$ $$T^{10}_i(x) = S(x \\oplus k1_9[i]) \\oplus k1_{10}[i], (i = 0…15)$$ 这又叫AddRoundKey SubBytes构成的 $T-boxes$，其中x代表一个4x4矩阵中的一个字节，i代表第0～15个字节，r是轮次，S是S-Box的查表操作。每轮16个表，一共160表。（矩阵变换）。 MixColumns推导成： $T_{y_{i}}$ 表列混淆是纯粹查表变换。将混淆矩阵作用于4x4状态的每一列。MixColumns表：$$MC = \\begin{bmatrix} 02 &amp; 03 &amp; 01 &amp; 01 \\\\ 01 &amp; 02 &amp; 03 &amp; 01 \\\\ 01 &amp; 01 &amp; 02 &amp; 03 \\\\ 03 &amp; 01 &amp; 01 &amp; 02 \\end{bmatrix}$$列混淆操作为混淆矩阵MC左乘状态矩阵中的每一列，对其进行行变换：$$\\begin{bmatrix} 02 &amp; 03 &amp; 01 &amp; 01 \\\\ 01 &amp; 02 &amp; 03 &amp; 01 \\\\ 01 &amp; 01 &amp; 02 &amp; 03 \\\\ 03 &amp; 01 &amp; 01 &amp; 02 \\end{bmatrix} \\begin{bmatrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix}$$其中$x_i$是一列中的一个字节。 这等同于MC中每一列在x$下$的线性组合:$$MC \\begin{bmatrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = x_0 \\begin{bmatrix} 02 \\\\ 01 \\\\ 01 \\\\ 03 \\end{bmatrix} \\oplus x_1 \\begin{bmatrix} 03 \\\\ 02 \\\\ 01 \\\\ 01 \\end{bmatrix} \\oplus x_2 \\begin{bmatrix} 01 \\\\ 02 \\\\ 02 \\\\ 01 \\end{bmatrix} \\oplus x_3 \\begin{bmatrix} 01 \\\\ 01 \\\\ 03 \\\\ 02 \\end{bmatrix}$$ 将每个字节的求积拆解，即为如下变换相异或：$$T_{y_0} (x) = x \\cdot \\begin{bmatrix} 02 &amp; 01 &amp; 01 &amp; 03 \\end{bmatrix} ^T \\\\T_{y_1}(x) = x \\cdot \\begin{bmatrix} 03 &amp; 02 &amp; 01 &amp; 01 \\end{bmatrix} ^T$$ 此处的entry x，对应着$x_0, x_1, x_2…$。剩下的好推。 最后结果应该为：$$T_{y_0}(x_0) \\oplus T_{y_1}(x_1) \\oplus T_{y_2}(x_2) \\oplus T_{y_3}(x_3)$$ 这里， XOR 表也是需要的。$$XOR(x, y) = x \\oplus y$$这里采用4比特表，即x、y为4比特。（为什么要这么做还不太清楚，也许8比特表太大？）则每一列需要32/4 = 8个XOR表，把$T_{y_i}$表变换来的4个32位字异或成32位的最终结果。 我们把前两个表合并，$f \\circ g = f(g(x))$ 就得到TBoxesTyiTables。 最后算法变成这样：12345678state &lt;- plaintextfor r = 1 to 9: ShiftRows TBoxesTyiTables XORTablesShiftRowsTboxesciphertext &lt;- state 至此，所有的AES矩阵操作归结为查表操作。而查表操作是一对一的，在运行全过程可被监控的情况下，轮密钥很容易被推导。 疑惑 内存中不直接暴露轮密钥吗（轮密钥不应该存在于内存中吗）？ 不，DRM的加解密操作中，内存中只有相关的表，以此实现加密解密。并非裸密钥（轮密钥）进行。如见OpenWhiteBox中，被序列化与被解析的是不同的表，在persistance.go中。key.txt其实是表的二进制表示。其中不包含任何的密钥的原始状态表示。密钥被混合在表中。 为什么原生AES-128不安全？ 轮密钥只要有一轮泄漏，就可以推导出整个密钥。根据我们的设定，原生AES中每一轮都可以得到任何读写中间结果。假设$a$是第一轮密钥第一个字节，那么仅有256种枚举方式，可向数据入口插入错误 ，例如0x00000000，只要枚举，或者 $a = S^{-1}\\circ T_{y_0}^{-1}\\circ (T_{y_0} \\circ T^1_0)(0)$，$S$已知，$T_{y_0}^{-1}$可求，这样就可得到这个字节。这样4x4都出来，原生密钥就都出现了。 保护性实现针对AES的白盒安全保护，自02年来有很多实现。github.com/OpenWhiteBox/AES中有各种实现与密码分析。文[^ 1]描述了最初始的实现：chow‘s implementation。 chow的实现以输入输出编码(input and output encoding)、mixing bijections的方式来保护AES在WBAC下的安全。这也是许多变种设计过程中使用的思路。 Encodings Mixing Bijections EncodingsEncodings 意图给原生的表加上内/外的保护，使得在AES做矩阵变换的时候，并不直接地产生裸结果。这可以使得疑惑2条件不成立。这是用来保护TboxTyiTable的。假设原生的$T-Box/T_{y_i}$表为$T$, 现在以$f$为输入编码，$g$为输出编码，构建$$T’ = g \\circ T \\circ f^{-1}$$内编码不暴露的情况下，攻击者无法从一轮中的中间数据得到相应的映射。或者说，攻击者没有办法从这个$T’$中获得关于T的信息。考虑非线性$f$对4比特(one nibble)数据进行encoding，并采用concat的形式联合：$$f(x_0 || x_1) = f_1(x_0) || f_2(x_1),\\ x_i\\ is\\ a\\ nibble$$设这种encoding为$O$。$OT$没有泄漏任何关于$T$的信息。4比特可以产生$16!$种不重复的数值变换。对应地，每个字节就是$(16!)^2$种encoding。若加上output encoding, 则为$(16!)^2 (16!)^8$。这枚举是非常困难的。对于目标T表，以及任意非目标的$T’$表，都存在一个非线性映射$O’$, 使得$O’T’ = OT$。爆破理论上是不可行的。 另外，这种encoding是可以被networked的。不同的表可以被串联起来。这使得内部的推导会更难。在Github.com/OpenWhiteBox/AES/的chow实现中：12345678910// tyiEncoding encodes the output of a T-Box/Tyi Table / the input of a HighXORTable.//// All randomness is derived from the random source; round is the current round; position is the byte-wise position in// the state matrix being stretched; subPosition is the nibble-wise position in the Word table's output.func tyiEncoding(rs *random.Source, round, position, subPosition int) encoding.Nibble { label := make([]byte, 16) label[0], label[1], label[2], label[3] = 'T', byte(round), byte(position), byte(subPosition) return rs.Shuffle(label)} 对T表的encoding就是4比特的。 在文[^ 1]的图里，是不包含了encoding部分的。在进行分析的时候我们有意抹去了encoding，因为encoding的安全性来自于外部。这不是算法安全性分析的范畴。 Mixing BijectionsMixing Bijections是加密过程中增加的一个线性变换。用于对TboxTyiTable的扩散。encoding 实现了对密钥的混淆，每一轮中插入的Mixing Bijections则强化了密钥的扩散。被随机选择的Mixing Bijection变换都能够提高AES原生表的复杂性。作用在代码中耦合，会使得查表环节无法从TboxTyiTable的求解依赖于混入双射变换矩阵MB。根据chow的实现，选择一个GF(2)内的可逆矩阵MB，于是我们是这样构造的。 由于第一轮，在输入的时候为明文/密文，这一轮应该用下文提及的外部编码（external encoding）来处理。这一轮的输入端不进行双射混合。 第2到10轮，选择8比特到8比特的变换矩阵，附加在T表输入之前。 1～9轮，在T表的输出端加上32-bit到32-bit的映射。 原来的TboxTyiTable表：$$T_{y_0}\\circ T^2_0 \\\\T_{y_1}\\circ T^2_1 \\\\T_{y_2}\\circ T^2_2 \\\\T_{y_3}\\circ T^2_3 \\\\$$ 现在的$T’$表：$$MB \\circ T_{y_0}\\circ T^2_0 \\circ {L^2_0}^{-1}\\ (1) \\\\MB \\circ T_{y_1}\\circ T^2_1 \\circ {L^2_1}^{-1}\\\\….$$$L$是8-bit到8-bit的输入mixing bijection, MB是32 -&gt; 32的输出mixing bijection。这些表的最终结果被XOR起来。为了下一轮计算可以进行，(1)中$MB$的效果需要被去除，而需要加上$L$。$MB^{-1}$作用于（1）产生的32bit结果，然后给每一个字节作用上$L^3$（此处为第三轮，所以为$L^3$），则结果可供给下一轮进行。所以，Mixing Bijection的运行过程是， 8bit$L{-1}$作用于输入$I$，得到$I_1$ TboxTyiTable作用于$I_1$，得到32bit值 将4个32bit值XOR，得到中间值$I_2$ 32bit的$I_2$每个字节被$MB^{-1}$作用得到32bit中间值，然后被32-&gt;32$L$进行Mixing Bijection 4个32bit值XOR成一个32bit，成为下一轮的state 外部编码为了防止裸（raw）的明文到密文，或密文到明文的映射，以保护加密/解密器在特定环境下使用，可以给加密/解密器加上特定的外部编码。假定原来的解密器为$D_k$，则构建$$D’_k = G \\circ D_k \\circ F^{-1}$$$F$是输入编码，$G$是输出编码。这种方式在特定条件下可以保护DFA攻击[^ 4]。 [^1]: James A. Muir, A Tutorial on White-box AES[^2]: S. Bhatkar, D. C. DuVarney, R. Sekar, Address obfuscation: an efficient approach to combat a broad range of memory error exploits, in Proceedings of the 12th USENIX Security Symposium. USENIX Association (2003)[^3]: C. Linn, S.K. Debray. Obfuscation of executable code to improve resistance to static disassembly, in S. Jajodia, V. Atluri, and T. Jaeger, editors, Proceedings of the 10th ACM Conference on Computer and Communications Security, CCS 2003. ACM (2003), pp. 290–299[^4]: White-Box Cryptography: Don’t Forget About Grey-Box Attacks[^5]: WHITE-BOX CRYPTOGRAPHY AND AN AES IMPLEMENTATION[^6]: 详见CANSv7[^7]: Biryukov A, Bouillaguet C, Khovratovich D. Cryptographic schemes based on the ASASA structure: black-box, white-box, and public-key[C]. In: Advances in Cryptology—ASIACRYPT 2014. Springer Berlin Heidelberg, 2014: 63–84.[^10]: https://gongzheng.github.io/","link":"/2019/07/05/wbac_tutorial/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Algorithms","slug":"Algorithms","link":"/tags/Algorithms/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"网盘系统","slug":"网盘系统","link":"/tags/网盘系统/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"水货软文","slug":"水货软文","link":"/tags/水货软文/"},{"name":"HAProxy","slug":"HAProxy","link":"/tags/HAProxy/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"坐标拾取","slug":"坐标拾取","link":"/tags/坐标拾取/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"发发小癫","slug":"发发小癫","link":"/tags/发发小癫/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"lab","slug":"lab","link":"/tags/lab/"},{"name":"computer system","slug":"computer-system","link":"/tags/computer-system/"},{"name":"homework","slug":"homework","link":"/tags/homework/"}],"categories":[{"name":"CLRS","slug":"CLRS","link":"/categories/CLRS/"},{"name":"CS:APP","slug":"CS-APP","link":"/categories/CS-APP/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"文学杂感","slug":"文学杂感","link":"/categories/文学杂感/"},{"name":"Cryptography","slug":"Cryptography","link":"/categories/Cryptography/"},{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"miscellaneous","slug":"miscellaneous","link":"/categories/miscellaneous/"},{"name":"Test Page","slug":"Test-Page","link":"/categories/Test-Page/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"Huawei","slug":"Huawei","link":"/categories/Huawei/"},{"name":"Algorithms","slug":"Algorithms","link":"/categories/Algorithms/"},{"name":"networking","slug":"networking","link":"/categories/networking/"}]}