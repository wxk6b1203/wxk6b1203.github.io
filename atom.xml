<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>improvedNPC</title>
  
  <subtitle>认真工作，热爱生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.wxk.me/"/>
  <updated>2020-06-02T05:52:26.923Z</updated>
  <id>https://blog.wxk.me/</id>
  
  <author>
    <name>improvedNPC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>奠逝去的好战友</title>
    <link href="https://blog.wxk.me/2020/05/05/rip_hwang/"/>
    <id>https://blog.wxk.me/2020/05/05/rip_hwang/</id>
    <published>2020-05-05T06:59:59.000Z</published>
    <updated>2020-06-02T05:52:26.923Z</updated>
    
    <content type="html"><![CDATA[<p>2020年4月5日凌晨，曾经的好友，共同学习成长的战士，离开了人世。官方说辞是，发生了意外。</p><a id="more"></a><p>Hwong与我们虽然常在一个讨论班学习，也是其中最优秀的一员。但他在4月5日永远离开了我们。我们怎么也不能想到的是，这样一个优秀的同学，多次斩获腾讯、pingcap、头条Offer的同学，会做出如此让人惋惜的事情。根据我们对他的理解，发生意外也许只是官方为了大事化小的说辞。毕竟，在西三生活了4年，环境如此熟悉，会有什么意外，是想不到的呢。也许Hwong只是做出了自己最无奈的选择罢了。至于为何会让他觉得走投无路，我们不得而知。也许是家庭，也许是别的，什么都不好说。希望它能够在另一个世界安息，不要再当程序员了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年4月5日凌晨，曾经的好友，共同学习成长的战士，离开了人世。官方说辞是，发生了意外。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>华为笔试 - 占位符替换</title>
    <link href="https://blog.wxk.me/2020/03/15/mask-huawei/"/>
    <id>https://blog.wxk.me/2020/03/15/mask-huawei/</id>
    <published>2020-03-15T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.802Z</updated>
    
    <content type="html"><![CDATA[<p>2020春招华为出了3道算法题。两道搜索一道没看。其中第一道是Linux Shell占位符替换。用了深搜解决。</p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>在Linux Shell中，常用<code>${xx}</code>的形式做命令的占位替换。当shell的字符串中局部需要其他变量替换的时候，就用此占位符来代表变量的代入。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1234</span><br><span class="line">b=/abc/$&#123;a&#125;/</span><br></pre></td></tr></table></figure></p><p>则b变量最终数据为：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/abc/<span class="number">1234</span>/</span><br></pre></td></tr></table></figure></p><p>现在有一组（可能）包含占位符的变量，他们的占位符替换不循环引用。问这组变量最后的变量应该被替换为怎么样的字符串？<br>如：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span>=abc</span><br><span class="line"><span class="attr">b</span>=de/<span class="variable">$&#123;a&#125;</span>/fg</span><br><span class="line"><span class="attr">c</span>=/hj/<span class="variable">$&#123;b&#125;</span>/<span class="variable">$&#123;a&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>a</code>替换如b变量中的占位符，得：<code>/de/abc/fg</code><br><code>b</code>替换c变量中的占位符，得：<code>/hj/de/abc/fg/abc</code><br>如此，最后一行得输出为：<code>/hj/de/abc/fg/abc</code></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>一共$N$行。<br>第1行为一个整数$n$，即后继拥有得变量数。<br>第2到第$N-1$一共$n$行，为每个变量式的表达；<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line"><span class="attribute">a</span>=ab</span><br><span class="line"><span class="attribute">b</span>=cd/$&#123;a&#125;</span><br><span class="line"><span class="attribute">c</span>=/def/$&#123;b&#125;/<span class="variable">$&#123;a&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>一行，为第<code>n</code>行的替换后的结果。上述输入结果：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/def/<span class="keyword">cd</span>/<span class="keyword">ab</span>/<span class="keyword">ab</span></span><br></pre></td></tr></table></figure></p><h3 id="Write-Up"><a href="#Write-Up" class="headerlink" title="Write Up"></a>Write Up</h3><p>此题解法多，深搜最好理解：用一个串来记录结果。假设为字符串$S$。从头到尾搜索最后一个变量的串。遇到占位符，立即搜索该占位符，然后加上去。三种形式：</p><ul><li>如果没有<code>${xxx}</code>这种形式，则后续字符串没有变量，附加上去就好；如：<code>a=ab</code>，没有任何东西。<code>S += &quot;ab&quot; =&gt; &quot;ab&quot;</code>；这是递归结束情况。因为原题描述，该图为<code>DAG</code>。</li><li>如果第1个字符为<code>$</code>，则说明开头即变量，搜索。如：<code>a=ab, b=${a}</code>，需要搜索变量<code>a</code>附加上去；</li><li>其余情况：先附加一部分，截取子串；如：<code>current -&gt; /ab/${a}</code>，则先<code>S += &quot;/ab/&quot;</code>，再搜索<code>${a}</code></li></ul><p>完整代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thePair</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> first;</span><br><span class="line">  <span class="built_in">string</span> second;</span><br><span class="line">  thePair(<span class="built_in">string</span> a, <span class="built_in">string</span> b) : first(a), second(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;thePair&gt; p;</span><br><span class="line"><span class="built_in">string</span> finalRes = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> cur)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cur.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = cur.find_first_of(<span class="string">"$"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">      finalRes += cur;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">0</span>) finalRes += cur.substr(<span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    pos = cur.find_first_of(<span class="string">"&#123;"</span>);</span><br><span class="line">    <span class="keyword">int</span> left = cur.find_first_of(<span class="string">"&#125;"</span>);</span><br><span class="line">    <span class="built_in">string</span> next = cur.substr(pos + <span class="number">1</span>, left - pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (thePair&amp; j : p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j.first == next) &#123;</span><br><span class="line">        dfs(j.second);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur.substr(left + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thePair <span class="title">split</span><span class="params">(<span class="built_in">string</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n[i] == <span class="string">'='</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> thePair(n.substr(<span class="number">0</span>, i), n.substr(i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">string</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    p.push_back(split(m));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> target = p[p.size() - <span class="number">1</span>].second;</span><br><span class="line">  dfs(target);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; finalRes &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>finalRes</code>为最终需要的结果。thePair为分割变量与字符串所用。不断缩短cur，即目前状态，最后清零。finalRes为全局变量，在oi中很习惯使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020春招华为出了3道算法题。两道搜索一道没看。其中第一道是Linux Shell占位符替换。用了深搜解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Huawei" scheme="https://blog.wxk.me/categories/Huawei/"/>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/tags/Algorithms/"/>
    
      <category term="DFS" scheme="https://blog.wxk.me/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 54 - Spiral Order</title>
    <link href="https://blog.wxk.me/2020/03/06/spiral-order/"/>
    <id>https://blog.wxk.me/2020/03/06/spiral-order/</id>
    <published>2020-03-06T06:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.809Z</updated>
    
    <content type="html"><![CDATA[<p>这道题，触及我很多伤痛。高中OI，大学ACM，面试，今天终于完整写完了。。。</p><a id="more"></a><p>上下左右搭建4面墙，作为哨兵条件。每跳出一边，墙就向中间移动一次。记得每次都确认是否墙越界了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, down = matrix.length - <span class="number">1</span>, left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (up &lt;= down) &#123;</span><br><span class="line">            i = left;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; right + <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(matrix[up][i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            i = up + <span class="number">1</span>;</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; down)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; down + <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(matrix[i++][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            i = right - <span class="number">1</span>;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= left) &#123;</span><br><span class="line">                list.add(matrix[down][i--]);</span><br><span class="line">            &#125;</span><br><span class="line">            i = down - <span class="number">1</span>;</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; down)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= up) &#123;</span><br><span class="line">                list.add(matrix[i--][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题，触及我很多伤痛。高中OI，大学ACM，面试，今天终于完整写完了。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://blog.wxk.me/categories/LeetCode/"/>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 43 - 大数乘法</title>
    <link href="https://blog.wxk.me/2020/03/05/big_num_mul/"/>
    <id>https://blog.wxk.me/2020/03/05/big_num_mul/</id>
    <published>2020-03-05T06:57:59.000Z</published>
    <updated>2020-06-02T05:40:16.797Z</updated>
    
    <content type="html"><![CDATA[<p>模拟算乘法，实现大整数乘法。仅限整数，负数要加点判断条件。<br><a id="more"></a></p><p>这个方法虽然不是最快的，但比较好理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// trivial case</span></span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"1"</span>))</span><br><span class="line">            <span class="keyword">return</span> num2;</span><br><span class="line">        <span class="keyword">if</span> (num2.equals(<span class="string">"1"</span>))</span><br><span class="line">            <span class="keyword">return</span> num1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// method call optimition</span></span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = num2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// target result;</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// multiply single numbers</span></span><br><span class="line">                <span class="keyword">int</span> tmp = (num1.charAt(i) - <span class="string">'0'</span>) * (num2.charAt(j) - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">// len - i - 1 means indentation</span></span><br><span class="line">                <span class="comment">// add up two single num</span></span><br><span class="line">                res[(len1 - i - <span class="number">1</span>) + len2 - j - <span class="number">1</span>] += tmp % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// carry</span></span><br><span class="line">                <span class="keyword">int</span> add = res[(len1 - i - <span class="number">1</span>) + len2 - j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">                res[(len1 - i - <span class="number">1</span>) + len2 - j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">                res[(len1 - i - <span class="number">1</span>) + len2 - j] += add;</span><br><span class="line">                res[(len1 - i - <span class="number">1</span>) + len2 - j] += tmp / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fin = res.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (res[fin] == <span class="number">0</span>)</span><br><span class="line">            fin--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// reverse order to append as string</span></span><br><span class="line">        <span class="keyword">while</span> (fin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) (res[fin--] + <span class="string">'0'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟算乘法，实现大整数乘法。仅限整数，负数要加点判断条件。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://blog.wxk.me/categories/LeetCode/"/>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>DCA - 对AES侧信道分析的总结</title>
    <link href="https://blog.wxk.me/2020/03/01/dca/"/>
    <id>https://blog.wxk.me/2020/03/01/dca/</id>
    <published>2020-03-01T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DCA计算原理与实现中的局限性"><a href="#DCA计算原理与实现中的局限性" class="headerlink" title="DCA计算原理与实现中的局限性"></a>DCA计算原理与实现中的局限性</h3><p>DCA采用与硬件上DPA相近的从trace到relationship computation的操作方案，通过采集样本-样本分类-样本相关性对比的方法，分析给出的猜测是否正确，得出结论。目前的情况是，处于中间的noisy round，无法抵御或完全抵御DCA攻击。</p><a id="more"></a><h4 id="踪迹采集"><a href="#踪迹采集" class="headerlink" title="踪迹采集"></a>踪迹采集</h4><p>踪迹采集器TracerGrind是一个valgrind的插件，他会记录每一次应用中的读写及其读写周期、外部调用、指令地址、数据地址、数据区域及长度等。一般我们需要采集的为数据的读写情况。每一次加密采集都会形成一个(明文，密文，读写上下文)三元组。不同的三元组有利于最终后期做CPA时不同的覆盖情况。根据算法内部的长度不同，需要采用不同的监视长度。如noisy_round是8-128的，两个64拼成一个128。这意味着大概率CPA所需要的读写踪迹分布在长度为8的部分上。这也是一开始分析8-128不成功的原因。</p><h4 id="踪迹汇总"><a href="#踪迹汇总" class="headerlink" title="踪迹汇总"></a>踪迹汇总</h4><p>采集后的踪迹会汇总形成一个独立的有一定格式的二进制文件上，供Daredevil进行CPA分析。Daredevil一般采用一阶相关关系分析来做密钥的匹配工作。相关配置会写在config文件上。如</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Traces]</span></span><br><span class="line"><span class="attr">files</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">trace_type</span>=i</span><br><span class="line"><span class="attr">transpose</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">index</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">nsamples</span>=<span class="number">492096</span></span><br><span class="line"><span class="attr">trace</span>=stack_data_rw<span class="number">8_201_492096</span>.trace <span class="number">201</span> <span class="number">492096</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Guesses]</span></span><br><span class="line"><span class="attr">files</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">guess_type</span>=u</span><br><span class="line"><span class="attr">transpose</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">guess</span>=stack_data_rw<span class="number">8_201_492096</span>.input <span class="number">201</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="section">[General]</span></span><br><span class="line"><span class="attr">threads</span>=<span class="number">8</span></span><br><span class="line"><span class="attr">order</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">return_type</span>=double</span><br><span class="line"><span class="attr">algorithm</span>=AES</span><br><span class="line"><span class="attr">position</span>=LUT/AES_BEFORE_SBOX</span><br><span class="line"><span class="attr">round</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">bitnum</span>=all</span><br><span class="line"><span class="attr">bytenum</span>=all</span><br><span class="line"><span class="attr">correct_key</span>=<span class="number">0</span>x000102030405060708090a0b0c0d0e0f</span><br><span class="line"><span class="attr">memory</span>=<span class="number">4</span>G</span><br><span class="line"><span class="attr">top</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>就代表了，踪迹的数据为整型，踪迹矩阵（时间为列，数据为行）需要经过转置（这里是固定参数），踪迹汇总名为<code>stack_data_rw8_201_492096.trace</code>，猜测推导输入是利用明文输入，名为<code>stack_data_rw8_201_492096.input</code>，一共进行了201此追踪，产生了492096个读写样本点，算法每轮长度为16字节（即针对0~15轮进行破解），用AES的在sbox之前的表来进行比对（这个通常要after sbox才能成功），针对round 0 进行破解，给出前20个最高可能的待选样本。</p><p><img src="https://i.loli.net/2020/04/10/y7EkFrGpiuD28Q4.png" alt="tracegraph 得到的chow-m4ri结果"></p><h4 id="构建猜想"><a href="#构建猜想" class="headerlink" title="构建猜想"></a>构建猜想</h4><p>构建猜想的过程进行选择函数的过程。选择函数会将每一个明文输入对应到字节一个映射过的字节，这个过程我们称之为猜想表对换。输入明文会被对换，然后按照16字节的对换后结果进行汇总。通常选择函数会将一个字节对应到一个对换过的汉明距离（当数据有缺陷的时候）或每一比特位置对应到0-1上，成为选择分类的依据。这里的矩阵结构比较不明显，他是一个$n \times m$的矩阵，n是采样次数，m是16，固定长度。代表输入的明文被合并到一个矩阵上。这些矩阵每个明文通过一个选择，就得到猜想。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; nrows; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j &lt; n_keys; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">bit</span> == <span class="number">-1</span>) &#123; <span class="comment">/* No individual bits. */</span></span><br><span class="line">        (*guess)[j][i] = HW ((TypeGuess) sbox[ (<span class="keyword">uint8_t</span>) mem[i][bytenum] ^ j ]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">bit</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">bit</span> &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        (*guess)[j][i] = (TypeGuess) ((sbox[ (<span class="keyword">uint8_t</span>) mem[i][bytenum] ^ j ] &gt;&gt; <span class="built_in">bit</span>)&amp;<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="样本关系计算"><a href="#样本关系计算" class="headerlink" title="样本关系计算"></a>样本关系计算</h4><p>这一步会将每一个样本点与上一步骤的猜想进行比对。每读写16个字节的样本，就与目标猜想进行一次比对。这也是为什么noisy round会成功的原因：如果你的选择函数有效，且你的有效区间被采样了，如果相关关系正确，你就必然会在后续的关系比对上产生一个峰值。但这也是为什么noisy round会导致部分出错的原因：我们攻击的是第0轮到第一轮之间的数据。如果这个16字节noisy round被拆开了有一半被当作下一个16字节样本，后续的所有过程会有连锁反应。这也是第一轮noisy round能部分阻挡DCA的原因。这也侧面证明了，noisy round在实现上与我们所想的，有一定的差别。他的结构跟正常AES轮次不太一样。</p><h4 id="按照相关关系，给出Top-K符合的字节"><a href="#按照相关关系，给出Top-K符合的字节" class="headerlink" title="按照相关关系，给出Top K符合的字节"></a>按照相关关系，给出Top K符合的字节</h4><p>并不是每一次都能获取到最佳的比对字节。有可能有一个比对达标，但又有可能没有。其中，peek最接近0.25，0.5，0.75，1的，被认为是最佳选择。</p><h4 id="常见的操作失败"><a href="#常见的操作失败" class="headerlink" title="常见的操作失败"></a>常见的操作失败</h4><ol><li>目标数据长度不同。如：8-128的表必定对应长度为8字节，即64bit的读写区间。（因为8字节是目前最长的基础数据）如果使用了1、2、4字节，即char，short，int，会错误采样。默认进行4字节的采样。</li><li>目标地址不能精准定位。这tracegraph，也确实是吹牛。因为几乎不可能看出来地址在哪里。</li><li>动态库有自己的地址空间，必须采取其他措施。</li></ol><h4 id="WBSM4可能存在的隐患"><a href="#WBSM4可能存在的隐患" class="headerlink" title="WBSM4可能存在的隐患"></a>WBSM4可能存在的隐患</h4><ol><li>仿射变换的计算过程会直接干扰到对换关系的比对，这会导致cpa无法进行或误判。这点日后深入拓展。</li><li>主密钥的情况，会有更多出入。aes和des的第一轮密钥都是原生密钥没有改变，所以第一轮就给出master key。sm4的情况？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DCA计算原理与实现中的局限性&quot;&gt;&lt;a href=&quot;#DCA计算原理与实现中的局限性&quot; class=&quot;headerlink&quot; title=&quot;DCA计算原理与实现中的局限性&quot;&gt;&lt;/a&gt;DCA计算原理与实现中的局限性&lt;/h3&gt;&lt;p&gt;DCA采用与硬件上DPA相近的从trace到relationship computation的操作方案，通过采集样本-样本分类-样本相关性对比的方法，分析给出的猜测是否正确，得出结论。目前的情况是，处于中间的noisy round，无法抵御或完全抵御DCA攻击。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Cryptography" scheme="https://blog.wxk.me/categories/Cryptography/"/>
    
    
      <category term="crypto" scheme="https://blog.wxk.me/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1481：最长不下降子序列</title>
    <link href="https://blog.wxk.me/2020/01/29/non-decrease-sequence/"/>
    <id>https://blog.wxk.me/2020/01/29/non-decrease-sequence/</id>
    <published>2020-01-29T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.803Z</updated>
    
    <content type="html"><![CDATA[<p>P<a href="https://www.luogu.com.cn/problem/P1481">1481</a>是最长不下降子序列的中二版。一个词是否为另一个词的序列，看是否为他的前缀。这里有点小坑的问题在于DP的一些特性。<br><a id="more"></a></p><p>此处的坑在于，DP（记忆化搜索）的特性需求：</p><ul><li>数据被使用之前需要已经被算出来</li><li>递归子式不能有后效性</li></ul><p>所以，<strong>第二层递归从小到大，会遇到未计算的情况</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>* dp;</span><br><span class="line"><span class="built_in">string</span>* strs;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">common</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> len = (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()) ? a.<span class="built_in">size</span>() : b.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[i]) &#123;</span><br><span class="line">      res++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  strs = <span class="keyword">new</span> <span class="built_in">string</span>[n + <span class="number">1</span>];</span><br><span class="line">  dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; strs[i];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strs[i].<span class="built_in">find</span>(strs[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[i + <span class="number">1</span>] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] strs;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;P&lt;a href=&quot;https://www.luogu.com.cn/problem/P1481&quot;&gt;1481&lt;/a&gt;是最长不下降子序列的中二版。一个词是否为另一个词的序列，看是否为他的前缀。这里有点小坑的问题在于DP的一些特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/categories/Algorithms/"/>
    
    
      <category term="动态规划" scheme="https://blog.wxk.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2803：带权中位数的思考</title>
    <link href="https://blog.wxk.me/2020/01/25/weighted_medium/"/>
    <id>https://blog.wxk.me/2020/01/25/weighted_medium/</id>
    <published>2020-01-25T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.811Z</updated>
    
    <content type="html"><![CDATA[<p>带权中位数是CSP（NOIP）的一个常见问题。利用动态规划的方法寻找最佳落址。其中模板为邮局选址问题（<em>post-office location problem</em>）。这类问题有各种各样的衍生。这里我们讨论一道简单的变形：洛谷<a href="https://www.luogu.com.cn/problem/P2803">2803</a>，小学生与小学选址。<br><a id="more"></a></p><p>原题目在洛谷<a href="https://www.luogu.com.cn/problem/P2803">P2803</a>。</p><h2 id="数学特性"><a href="#数学特性" class="headerlink" title="数学特性"></a>数学特性</h2><p>根据原题，虽然学校可以建在所有楼之间的任意一处，但可以证明，对于区间$[A, B]$中的一所小学，仅当小学位于某一楼的位置上，距离是最近的。这个假设可通过矛盾来证明。<br>假设在两栋楼的区间$[A, B]$，拥有学校P，将所有的学生连线到这所学校。向左移动的连线为方向，向右移动的连线为正向，总长度为$P$。楼$A$有$a$人，楼$B$有$b$人:<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">A</span> --  --&gt; <span class="comment">B</span></span><br></pre></td></tr></table></figure></p><p>设，有另一所小学在两栋楼之间，所有学生到该小学的总路程为$P’$。设这所小学从$A$出发，正向（向右）距离为$L$，则：</p><p>$$<br>P’ = P + L * a - L * b<br>$$</p><ul><li>若$a &lt; b$，则必有向左移动到楼宇$A$，使得$P’$更小；</li><li>若$a &gt; b$，必有向右移动到楼宇$B$，使得$P’$更小；</li><li>$a = b$，不管移动到A或B，都不劣。</li></ul><p>于是得到结论：<strong>对于楼宇区间$[A, B]$，仅当学校处在某一楼宇处，所得的距离最短。</strong></p><h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><p>因为对于每个小学生，他们都需要走一定的路程到学校。对于拥有$a$人的楼$A$，到学校距离为$D$，所有小学生需要走的总路程为$a * D$。显然，我们可将每栋楼的小学生数量设置为该点的<strong>权值</strong>。</p><p>假设学校建设在楼A，其加权距离为$P$。则可以通过此距离推算其他点的距离，以找到区间$[A, B]$间的最优解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = j + <span class="number">1</span>; mid &lt;= i; mid++) &#123;</span><br><span class="line">    <span class="comment">// p for every position between A, B</span></span><br><span class="line">    p = p + distance(mid - <span class="number">1</span>, mid) * weight(mid - <span class="number">1</span>, j) </span><br><span class="line">          - distance(mid - <span class="number">1</span>, mid) * weight(i, mid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span> &lt; p) <span class="built_in">min</span> = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="推论-2"><a href="#推论-2" class="headerlink" title="推论 2"></a>推论 2</h4><p>根据上述代码，可知：当第一个位置，A到P人数&gt;=P到B人数时，此处为最佳位置。（p最小）</p><h2 id="代码过程"><a href="#代码过程" class="headerlink" title="代码过程"></a>代码过程</h2><ol><li><p>处理输入，累计各点的位置和权值。-&gt; <code>weight[i]</code>，<code>dis[i]</code><br>如：权值为：24，18，32<br>则：累计为：24，42，74<br>距离为：10， 8<br>累计为：0， 10， 18</p></li><li><p>记忆化搜索任意楼宇区间$[i, j]$</p><ol><li>找到区间i，j之间的权值中值</li><li>算这段区间的距离总长p</li></ol></li><li><p>简单的背包问题改版，放学校 or 不放学校？</p><ol><li>假设n栋楼配备了 &gt;n 的学校，则距离为0</li><li>若n栋楼配备了1所学校，则跟<em>2</em>计算的结果相等</li><li>若对于区间$[a, b]$，算得最佳结果<code>dp[a][b]</code>，且仅剩一所学校跟一个区间，则加上这个区间的最小权值中值</li></ol></li></ol><p>可得，这道题用了DP，首先搜索最佳位置，然后放学校。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 105</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> weight[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> best_sit[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate the distance between buildings</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">abs</span>(dis[a] - dis[b]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate weight sum between buildings</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = a, j = b;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    i = b;</span><br><span class="line">    j = a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> weight[j] - weight[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  ios::sync_with_stdio();</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">  <span class="built_in">memset</span>(weight, <span class="number">0</span>, <span class="keyword">sizeof</span> weight);</span><br><span class="line">  <span class="built_in">memset</span>(best_sit, <span class="number">0</span>, <span class="keyword">sizeof</span> best_sit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">    weight[i] = weight[i - <span class="number">1</span>] + tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">    dis[i] = dis[i - <span class="number">1</span>] + tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算爆每个区间仅有一座学校的情况</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (mid = j; mid &lt;= i; mid++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num(j, mid) &gt;= num(mid + <span class="number">1</span>, i)) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mid &gt; i) mid = i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> l = j; l &lt;= i; l++) &#123;</span><br><span class="line">        p = p + distance(mid, l) * num(l, l);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      best_sit[j][i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求 i 栋楼，j 所学校情况下的最优子结构</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= i)</span><br><span class="line">        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">1</span>)</span><br><span class="line">        dp[i][j] = best_sit[<span class="number">1</span>][i];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= i; l++) &#123;</span><br><span class="line">          <span class="keyword">int</span> tmp = dp[l - <span class="number">1</span>][j - <span class="number">1</span>] + best_sit[l][i];</span><br><span class="line">          <span class="keyword">if</span> (tmp &lt; <span class="built_in">min</span>) <span class="built_in">min</span> = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[n][k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;带权中位数是CSP（NOIP）的一个常见问题。利用动态规划的方法寻找最佳落址。其中模板为邮局选址问题（&lt;em&gt;post-office location problem&lt;/em&gt;）。这类问题有各种各样的衍生。这里我们讨论一道简单的变形：洛谷&lt;a href=&quot;https://www.luogu.com.cn/problem/P2803&quot;&gt;2803&lt;/a&gt;，小学生与小学选址。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/categories/Algorithms/"/>
    
    
      <category term="动态规划" scheme="https://blog.wxk.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>简注 - Differential Fault Analysis on AES</title>
    <link href="https://blog.wxk.me/2019/07/20/wbac_dfa/"/>
    <id>https://blog.wxk.me/2019/07/20/wbac_dfa/</id>
    <published>2019-07-20T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.811Z</updated>
    
    <content type="html"><![CDATA[<p>Differential Fault Analysis, a.k.a DFA, 是一种侧信道分析手段。通过对二进制进行注入故障，将结果与原始运行时做差，在特定的平衡下可获得一轮的轮密钥。在最近的研究中，可被用来做白盒算法的密码分析。<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>本文为如下工作的总结：</p><blockquote><ol><li><a href="https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html">https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html</a></li><li>Differential Computation Analysis: Hiding Your White-Box Designs is Not Enough. Joppe W. Bos, Charles Hubain, Wil Michiels and Philippe Teuwen, CHES 2016</li><li>Differential Fault Analysis on A.E.S. Pierre Dusart, Gilles Letourneux and Olivier Vivolo, ACNS 2003, pages 293-306</li></ol></blockquote><p>DFA攻击试图通过注入错误-与对照组求差求得轮密钥中的字节。针对一个状态注入时，每注入一个故障，可以扰乱4个轮密钥字节。重复此过程，就可以得到所有的状态轮密钥。DFA并不是最近才出现的一个新技术，而配合<a href="https://github.com/SideChannelMarvels/Deadpool">Deadpool</a>，利用Tracer跟踪加密器整个运行过程，从中得到running trace, 经过计算可以针对性地得到攻击的某一环。获得一轮的密钥，是DFA攻击的目的。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>差分故障的攻击执行过程大致如下：</p><ol><li>通过一定的工具，判断AES每一轮状态的位置</li><li>针对特定轮状态，以及特定故障点：<ol><li>状态正常运行一遍，得到状态$O$</li><li>注入一个故障，运行，得到$O’$</li><li>利用两次执行的差，针对每个差对进行计算，得到candidate fault的集</li><li>多次插入故障，得到不同解集，求交集。最后得到固定的结果</li></ol></li></ol><h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>在AES（AES-128）的DFA中，最主要的是得到最后一轮$K_{10}$的值。因为一轮可以倒推出所有轮，这样就相当于得到了密钥。其主要内容就是在最后两轮MixColumn之间插入一个错误，观察错误的扩散情况，然后求值。从FIPS192知道，最后三轮的过程大约为：</p><ul><li>SubBytes</li><li>ShiftRows</li><li>MixColumns</li><li><p>AddRoundKey $K_8$</p></li><li><p>SubBytes</p></li><li>ShiftRows</li><li>MixColumns</li><li><p>AddRoundKey $K_9$</p></li><li><p>SubBytes</p></li><li>ShiftRows</li><li>AddRoundKey $K_{10}$</li></ul><p>由于故障插入位于两次MixColumn之间，所以只有一轮MixColumn会被执行。最终这个错误会被扩散到4个字节上。为方便讨论，我们在第9轮的MixColumn前插入故障，观察其扩散情况。以插入故障的运行过程为实验组，与未插入故障的运行为对照组。<br>插入故障$X$。插入前后的对比：<br>$$<br>\begin{pmatrix} A &amp; E &amp; I &amp; M \\ B &amp; F &amp; J &amp; N \\ C &amp; G &amp; K &amp; O \\ D &amp; H &amp; L &amp; P \end{pmatrix} \text{和} \begin{pmatrix} X &amp; E &amp; I &amp; M \\ B &amp; F &amp; J &amp; N \\ C &amp; G &amp; K &amp; O \\ D &amp; H &amp; L &amp; P \end{pmatrix}<br>$$<br>在此之后，实验组（插入故障组）与对照组将会同样进行以下操作：</p><ul><li>MixColumns</li><li><p>AddRoundKey $K_9$</p></li><li><p>SubBytes</p></li><li>ShiftRows</li><li>AddRoundKey $K_{10}$</li></ul><p>Mixcolumn后：<br>$$<br>\begin{pmatrix} 2A+3B+C+D &amp; \cdots &amp; \cdots &amp; \cdots \\ A+2B+3C+D &amp; \cdots &amp; \cdots &amp; \cdots \\ A+B+2C+3D &amp; \cdots &amp; \cdots &amp; \cdots \\ 3A+B+C+2D &amp; \cdots &amp; \cdots &amp; \cdots \end{pmatrix} \text{and} \begin{pmatrix} 2X+3B+C+D &amp; \cdots &amp; \cdots &amp; \cdots \\ X+2B+3C+D &amp; \cdots &amp; \cdots &amp; \cdots \\ X+B+2C+3D &amp; \cdots &amp; \cdots &amp; \cdots \\ 3X+B+C+2D &amp; \cdots &amp; \cdots &amp; \cdots \end{pmatrix}<br>$$<br>加入第9轮密钥：<br>$$<br>\begin{pmatrix} 2A+3B+C+D+K_{9,0} &amp; \cdots &amp; \cdots &amp; \cdots \\ A+2B+3C+D+K_{9,1} &amp; \cdots &amp; \cdots &amp; \cdots \\ A+B+2C+3D+K_{9,2} &amp; \cdots &amp; \cdots &amp; \cdots \\ 3A+B+C+2D+K_{9,3} &amp; \cdots &amp; \cdots &amp; \cdots \end{pmatrix} \text{and} \begin{pmatrix} 2X+3B+C+D+K_{9,0} &amp; \cdots &amp; \cdots &amp; \cdots \\ X+2B+3C+D+K_{9,1} &amp; \cdots &amp; \cdots &amp; \cdots \\ X+B+2C+3D+K_{9,2} &amp; \cdots &amp; \cdots &amp; \cdots \\ 3X+B+C+2D+K_{9,3} &amp; \cdots &amp; \cdots &amp; \cdots \end{pmatrix}<br>$$</p><p>SubBytes:<br>$$<br>\begin{pmatrix} S(2A+3B+C+D+K_{9,0}) &amp; \cdots &amp; \cdots &amp; \cdots \\ S(A+2B+3C+D+K_{9,1}) &amp; \cdots &amp; \cdots &amp; \cdots \\ S(A+B+2C+3D+K_{9,2}) &amp; \cdots &amp; \cdots &amp; \cdots \\ S(3A+B+C+2D+K_{9,3}) &amp; \cdots &amp; \cdots &amp; \cdots \end{pmatrix} \text{and} \begin{pmatrix} S(2X+3B+C+D+K_{9,0}) &amp; \cdots &amp; \cdots &amp; \cdots \\ S(X+2B+3C+D+K_{9,1}) &amp; \cdots &amp; \cdots &amp; \cdots \\ S(X+B+2C+3D+K_{9,2}) &amp; \cdots &amp; \cdots &amp; \cdots \\ S(3X+B+C+2D+K_{9,3}) &amp; \cdots &amp; \cdots &amp; \cdots \end{pmatrix}<br>$$</p><p>ShiftRows:<br>$$<br>\begin{pmatrix} S(2A+3B+C+D+K_{9,0}) \qquad \cdots \qquad \cdots \qquad \cdots \\ \cdots \qquad \cdots \qquad \cdots \qquad S(A+2B+3C+D+K_{9,1})\\ \cdots \qquad \cdots \qquad S(A+B+2C+3D+K_{9,2}) \qquad \cdots \\ \cdots \qquad S(3A+B+C+2D+K_{9,3}) \qquad \cdots \qquad \cdots \end{pmatrix}\\ \text{and} \\\begin{pmatrix} S(2X+3B+C+D+K_{9,0}) \qquad \cdots \qquad \cdots \qquad \cdots \\ \cdots \qquad \cdots \qquad \cdots \qquad S(X+2B+3C+D+K_{9,1})\\ \cdots \qquad \cdots \qquad S(X+B+2C+3D+K_{9,2}) \qquad \cdots \\ \cdots \qquad S(3X+B+C+2D+K_{9,3}) \qquad \cdots \qquad \cdots \end{pmatrix}<br>$$</p><p>AddRoundKey $K_{10}$:<br>$$<br>\begin{pmatrix} S(2A+3B+C+D+K_{9,0})+K_{10,0} \qquad \cdots \qquad \cdots \qquad \cdots \\ \cdots \qquad \cdots \qquad \cdots \qquad S(A+2B+3C+D+K_{9,1})+K_{10,13}\\ \cdots \qquad \cdots \qquad S(A+B+2C+3D+K_{9,2})+K_{10,10} \qquad \cdots \\ \cdots \qquad S(3A+B+C+2D+K_{9,3})+K_{10,7} \qquad \cdots \qquad \cdots \end{pmatrix}\\ \text{and}\\ \begin{pmatrix} S(2X+3B+C+D+K_{9,0})+K_{10,0} \qquad \cdots \qquad \cdots \qquad \cdots \\ \cdots \qquad \cdots \qquad \cdots \qquad S(X+2B+3C+D+K_{9,1})+K_{10,13}\\ \cdots \qquad \cdots \qquad S(X+B+2C+3D+K_{9,2})+K_{10,10} \qquad \cdots \\ \cdots \qquad S(3X+B+C+2D+K_{9,3})+K_{10,7} \qquad \cdots \qquad \cdots \end{pmatrix}<br>$$</p><p>So，未修改过的结果为$O_0$, 修改过的结果为$O_0’$。(第0个字节，为0)<br>$$<br>O_0 = S(2A+3B+C+D+K_{9,0})+K_{10,0} \\<br>O_0’ = S(2X+3B+C+D+K_{9,0})+K_{10,0}<br>$$</p><p><strong>作差：（$GF(2^8)$，加即为减）</strong></p><p>$$<br>O_0 + O’_0 = S(2A+3B+C+D+K_{9,0})+K_{10,0} + S(2X+3B+C+D+K_{9,0})+K_{10,0} \\<br>O_0 + O’_0 = S(2A+3B+C+D+K_{9,0}) + S(2X+3B+C+D+K_{9,0})<br>$$</p><p>在后排的Sbox操作构造两个$2A$:<br>$$<br>O_0 + O’_0 = S(2A+3B+C+D+K_{9,0}) + S(2X+\mathbf{2A+2A}+3B+C+D+K_{9,0})<br>$$</p><p>就可以得到：<br>$$<br>Y_0=2A+3B+C+D+K_{9,0}\\<br>Z=A+X<br>$$<br>原式转换为：<br>$$<br>O_0 + O’_0 = S(Y_0) + S(2Z+Y_0)<br>$$<br>其他被影响的字节也类似：<br>$$<br>O_7 + O’_7 = S(Y_1) + S(3Z+Y_1) \\<br>Y_1 = 3A+B+C+2D+K_{9,3} \\<br>O_{10} + O’_{10} = S(Y_2) + S(Z+Y_2) \\<br>Y_2 = A+B+2C+3D+K_{9,2} \\<br>O_{13} + O’_{13} = S(Y_3) + S(Z+Y_3) \\<br>Y_3 = A+2B+3C+D+K_{9,1} \\<br>$$<br><strong>这4个等式联立。针对Z，只有给定的故障集合$x\in X$才能联立。针对给定的故障X，存在一个求K解集。多次插入不同故障，最后求得交集，就是所需要的单一值。</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="注入点问题"><a href="#注入点问题" class="headerlink" title="注入点问题"></a>注入点问题</h4><p>以chow’s implementation为例。如果所有的表被集成起来，那就无法区分出哪里是MixColumn了。无法从MixColumn注入。但是，根据Dusart et al的说明，只要注入点在两轮MixColumn之间，就可以完成。<br>对于这个问题，作者菲利普·吐温用了对key file进行注入的方法来避开。也就是说，作者并没有直接把注入作用于二进制。它针对的地址空间是<strong>文件</strong>的地址空间。<u>通过改写其中的一些字节，实现静态注入</u>。</p><p>倘若是从第8轮完毕的state开始进行注入，</p><p>初始状态：<br>$$<br>\left(\begin{matrix}A &amp; E &amp; I &amp; M\\B &amp; F &amp; J &amp; N\\C &amp; G &amp; K &amp; O\\D &amp; H &amp; L &amp; P\end{matrix}\right)<br>$$</p><p>SubBytes:<br>$$<br>\left(\begin{matrix}S{\left(A \right)} &amp; S{\left(E \right)} &amp; S{\left(I \right)} &amp; S{\left(M \right)}\\S{\left(B \right)} &amp; S{\left(F \right)} &amp; S{\left(J \right)} &amp; S{\left(N \right)}\\S{\left(C \right)} &amp; S{\left(G \right)} &amp; S{\left(K \right)} &amp; S{\left(O \right)}\\S{\left(D \right)} &amp; S{\left(H \right)} &amp; S{\left(L \right)} &amp; S{\left(P \right)}\end{matrix}\right)<br>$$</p><p>ShiftRows:<br>$$<br>\left(\begin{matrix}S{\left(A \right)} &amp; S{\left(E \right)} &amp; S{\left(I \right)} &amp; S{\left(M \right)}\\S{\left(F \right)} &amp; S{\left(J \right)} &amp; S{\left(N \right)} &amp; S{\left(B \right)}\\S{\left(K \right)} &amp; S{\left(O \right)} &amp; S{\left(C \right)} &amp; S{\left(G \right)}\\S{\left(P \right)} &amp; S{\left(D \right)} &amp; S{\left(H \right)} &amp; S{\left(L \right)}\end{matrix}\right)<br>$$</p><p>Mixcolumns:<br>$$<br>\left(\begin{matrix}K_{9} + 2 S{\left(A \right)} + 3 S{\left(F \right)} + S{\left(K \right)} + S{\left(P \right)} &amp; … &amp; … &amp; … \\ K_{9} + S{\left(A \right)} + 2 S{\left(F \right)} + 3 S{\left(K \right)} + S{\left(P \right)} &amp; … &amp; … &amp; …\\  … &amp; … &amp; … &amp; … \\  … &amp; … &amp; … &amp; …\end{matrix}\right)<br>$$<br>这就是State 9.<br>简单带过一下，final state的state[0]为：<br>$$<br>K_{10} + S{\left(K_{9} + 2 S{\left(A \right)} + 3 S{\left(F \right)} + S{\left(K \right)} + S{\left(P \right)} \right)}\\<br>K_{10} + S{\left(K_{9} + 2 S{\left(X \right)} + 3 S{\left(F \right)} + S{\left(K \right)} + S{\left(P \right)} \right)}<br>$$<br>两式相减：<br>$$<br>S{\left(K_{9} + 2 S{\left(A \right)} + 3 S{\left(F \right)} + S{\left(K \right)} + S{\left(P \right)} \right)} + S{\left(K_{9} + 2 S{\left(X \right)} + 3 S{\left(F \right)} + S{\left(K \right)} + S{\left(P \right)} \right)}<br>$$<br>设：<br>$$<br>Y_0 = K_9 + 2S(A)+ 3 S(F) + S(K) + S(P) \\<br>Z = S(A) + S(X)<br>$$</p><p>同样地，对其他状态推导，只有符合特定条件的$S(X)$才能使得扩散的4个等式联立。</p><h2 id="对WBAC-AES的影响"><a href="#对WBAC-AES的影响" class="headerlink" title="对WBAC-AES的影响"></a>对WBAC-AES的影响</h2><h4 id="内编码失效"><a href="#内编码失效" class="headerlink" title="内编码失效"></a>内编码失效</h4><p>以chow’s implementation为例，包括encoding和Mixing Bijections。<br>在encoding方面：<br>$$<br>T’ = g \circ T \circ f^{-1}<br>$$<br>对此类白盒实现的注入，相当于对lookup-table的注入。修改lookup-table的一个字节，其作用也可以在最后的结果反映出来。这并不影响以上描述的注入方式。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>双路冗余的DFA</li><li>等效轮的DFA</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Differential Fault Analysis, a.k.a DFA, 是一种侧信道分析手段。通过对二进制进行注入故障，将结果与原始运行时做差，在特定的平衡下可获得一轮的轮密钥。在最近的研究中，可被用来做白盒算法的密码分析。&lt;br&gt;
    
    </summary>
    
    
      <category term="Cryptography" scheme="https://blog.wxk.me/categories/Cryptography/"/>
    
    
      <category term="crypto" scheme="https://blog.wxk.me/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>简注 - A Tutorial on White-box AES</title>
    <link href="https://blog.wxk.me/2019/07/05/wbac_tutorial/"/>
    <id>https://blog.wxk.me/2019/07/05/wbac_tutorial/</id>
    <published>2019-07-05T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.811Z</updated>
    
    <content type="html"><![CDATA[<p>白盒密码是对非可信平台下的密码算法安全实现的研究。其针对密码学算法在非可信平台设计实现，使得软件（数字内容）在具有完全操控（debugger，assembler）情况下获得安全保护。论文[^1]简要介绍AES在白盒攻击环境 (White-box Attack Context) 下AES的一种实现方式及其密码学分析。<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>白盒密码学 (White-box Cryptography) 意图设计特定实现，使得软件、数字资源等在不安全（非受信任）的环境下保护软件、资源的安全。白盒密码设计分析不同于像代码混淆[^2][^3]、控制流混淆这样的反逆向工程机制，它是纯粹针对算法安全性进行设计与分析[^4]。几乎所有的白盒密码学设计都针对对称加密算法，AES的设计就是典型之一。最初的白盒AES、DES由S. Chow，et.al 实现[^5]，后来该算法被攻破。随后不同的学者也相继发明了各种WBAC下的实现。<br>根据Alex, et.al 对白盒的时间进行了分类：<u>强白盒设计</u>与<u>弱白盒设计</u>[^7]。弱白盒设计要求算法实现能保护密钥不可被发现与推导，保护密钥不受密钥恢复攻击(<em>key recovery attack</em>)。这种实现对于查表的逆向推导理论上是不可防护的。强白盒设计要求解密器不可从加密器推导，i.e.,<em>plaintext-recovery attack</em>。chow的实现是白盒的开篇，应该归类为弱白盒实现。</p><h2 id="AES与矩阵查表操作"><a href="#AES与矩阵查表操作" class="headerlink" title="AES与矩阵查表操作"></a>AES与矩阵查表操作</h2><p>AES拥有4个变换：轮钥加 (AddRoundKey)、行变换 (ShiftRows)、列混淆 (MixColumns)、字节替换 (SubBytes)[^6]。这些操作都可以归结为查表操作。查表操作的可逆转性是非常强的，很容易得到原生结果。<br>其中，行变换是线性的，跟轮钥加可以进行位置上的替换。只要先对原有矩阵进行行变换，然后异或行变换过的轮密钥，这样这两个操作跟原有设计结果上没有差别。其次我们可以把第一轮异或加入到循环中，最后一轮异或移出循环。这种数学上的正确性有利于我们对AES查表操作 (table lookup) 性质的解析。<br>得到的结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">state &lt;- plaintext</span><br><span class="line">for r = <span class="number">1</span> <span class="keyword">to</span> <span class="number">9</span>:</span><br><span class="line"><span class="constructor">ShiftRows(<span class="params">state</span>)</span></span><br><span class="line"><span class="constructor">AddRoundKey(<span class="params">state</span>, <span class="params">k1</span>[<span class="params">r</span>-1])</span></span><br><span class="line"><span class="constructor">SubBytes(<span class="params">state</span>)</span></span><br><span class="line"><span class="constructor">MixColumns(<span class="params">state</span>)</span></span><br><span class="line"><span class="constructor">ShiftRows(<span class="params">state</span>)</span></span><br><span class="line"><span class="constructor">AddRoundKey(<span class="params">state</span>, <span class="params">k1</span>[9])</span></span><br><span class="line"><span class="constructor">SubBytes(<span class="params">state</span>)</span></span><br><span class="line"><span class="constructor">AddRoundKey(<span class="params">state</span>, <span class="params">k1</span>[10])</span></span><br><span class="line">ciphertext &lt;- state</span><br></pre></td></tr></table></figure><p>其中，<u>k1[r-1]是进行行变换过的轮密钥</u>。</p><p>上述算法描述中，<code>AddRoundKey</code> 和 <code>SubBytes</code> 可以对原有的S-Box合并：</p><h4 id="T-boxes"><a href="#T-boxes" class="headerlink" title="T-boxes"></a>T-boxes</h4><p>$$<br>T^r_i(x) = S(x \oplus k1_{r-1}[i]), (i = 0…15, r=1…9)<br>$$</p><p>$$<br>T^{10}_i(x) = S(x \oplus k1_9[i]) \oplus k1_{10}[i], (i = 0…15)<br>$$</p><p>这又叫<code>AddRoundKey</code> <code>SubBytes</code>构成的 $T-boxes$，其中x代表一个4x4矩阵中的一个字节，i代表第0～15个字节，r是轮次，S是S-Box的查表操作。每轮16个表，一共160表。（矩阵变换）。</p><p><code>MixColumns</code>推导成：</p><h4 id="T-y-i-表"><a href="#T-y-i-表" class="headerlink" title="$T_{y_{i}}$ 表"></a>$T_{y_{i}}$ 表</h4><p>列混淆是纯粹查表变换。将混淆矩阵作用于4x4状态的每一列。<br>MixColumns表：<br>$$<br>MC = \begin{bmatrix} 02 &amp; 03 &amp; 01 &amp; 01 \\ 01 &amp; 02 &amp; 03 &amp; 01 \\ 01 &amp; 01 &amp; 02 &amp; 03 \\ 03 &amp; 01 &amp; 01 &amp; 02 \end{bmatrix}<br>$$<br>列混淆操作为混淆矩阵MC左乘状态矩阵中的每一列，对其进行行变换：<br>$$<br>\begin{bmatrix} 02 &amp; 03 &amp; 01 &amp; 01 \\ 01 &amp; 02 &amp; 03 &amp; 01 \\ 01 &amp; 01 &amp; 02 &amp; 03 \\ 03 &amp; 01 &amp; 01 &amp; 02 \end{bmatrix} \begin{bmatrix} x_0 \\ x_1 \\ x_2 \\ x_3 \end{bmatrix}<br>$$<br><strong>其中$x_i$是一列中的一个字节。</strong></p><p>这等同于MC中每一列在x$下$的线性组合:<br>$$<br>MC \begin{bmatrix} x_0 \\ x_1 \\ x_2 \\ x_3 \end{bmatrix} = x_0 \begin{bmatrix} 02 \\ 01 \\ 01 \\ 03 \end{bmatrix} \oplus x_1 \begin{bmatrix} 03 \\ 02 \\ 01 \\ 01 \end{bmatrix} \oplus x_2 \begin{bmatrix} 01 \\ 02 \\ 02 \\ 01 \end{bmatrix} \oplus x_3 \begin{bmatrix} 01 \\ 01 \\ 03 \\ 02 \end{bmatrix}<br>$$</p><p>将每个字节的求积拆解，即为如下变换相异或：<br>$$<br>T_{y_0} (x) = x \cdot \begin{bmatrix} 02 &amp; 01 &amp; 01 &amp; 03 \end{bmatrix} ^T \\<br>T_{y_1}(x) = x \cdot \begin{bmatrix} 03 &amp; 02 &amp; 01 &amp; 01 \end{bmatrix} ^T<br>$$</p><p>此处的entry x，对应着$x_0, x_1, x_2…$。<br>剩下的好推。</p><p>最后结果应该为：<br>$$<br>T_{y_0}(x_0) \oplus T_{y_1}(x_1) \oplus T_{y_2}(x_2) \oplus T_{y_3}(x_3)<br>$$</p><p>这里，</p><h4 id="XOR-表"><a href="#XOR-表" class="headerlink" title="XOR 表"></a>XOR 表</h4><p>也是需要的。<br>$$<br>XOR(x, y) = x \oplus y<br>$$<br>这里采用<u>4比特表</u>，即x、y为4比特。（为什么要这么做还不太清楚，也许8比特表太大？）则每一列需要32/4 = 8个XOR表，把$T_{y_i}$表变换来的4个32位字异或成32位的最终结果。</p><p>我们把前两个表合并，$f \circ g = f(g(x))$ 就得到TBoxesTyiTables。</p><p>最后算法变成这样：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">state</span> <span class="variable">&lt;- plaintext</span></span><br><span class="line"><span class="variable">for r = 1 to 9:</span></span><br><span class="line"><span class="variable">ShiftRows</span></span><br><span class="line"><span class="variable">TBoxesTyiTables</span></span><br><span class="line"><span class="variable">XORTables</span></span><br><span class="line"><span class="variable">ShiftRows</span></span><br><span class="line"><span class="variable">Tboxes</span></span><br><span class="line"><span class="variable">ciphertext &lt;- state</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/aes.png" alt="结构图"></p><p>至此，所有的AES矩阵操作归结为查表操作。而查表操作是一对一的，在运行全过程可被监控的情况下，轮密钥很容易被推导。</p><h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><ol><li><p>内存中不直接暴露轮密钥吗（轮密钥不应该存在于内存中吗）？</p><p>不，DRM的加解密操作中，内存中只有相关的表，以此实现加密解密。并非裸密钥（轮密钥）进行。如见<a href="https://github.com/OpenWhiteBox/AES">OpenWhiteBox</a>中，被序列化与被解析的是不同的表，在<code>persistance.go</code>中。<code>key.txt</code>其实是表的二进制表示。其中不包含任何的密钥的原始状态表示。密钥被混合在表中。</p></li><li><p>为什么原生AES-128不安全？</p><p>轮密钥只要有一轮泄漏，就可以推导出整个密钥。根据我们的设定，原生AES中每一轮都可以得到任何读写中间结果。假设$a$是第一轮密钥第一个字节，那么仅有256种枚举方式，可向数据入口插入错误 ，例如0x00000000，只要枚举，或者 $a = S^{-1}\circ T_{y_0}^{-1}\circ (T_{y_0} \circ T^1_0)(0)$，$S$已知，$T_{y_0}^{-1}$可求，这样就可得到这个字节。这样4x4都出来，原生密钥就都出现了。</p></li></ol><h2 id="保护性实现"><a href="#保护性实现" class="headerlink" title="保护性实现"></a>保护性实现</h2><p>针对AES的白盒安全保护，自02年来有很多实现。<a href="https://github.com/OpenWhiteBox/AES">github.com/OpenWhiteBox/AES</a>中有各种实现与密码分析。文[^ 1]描述了最初始的实现：chow‘s implementation。</p><p>chow的实现以输入输出编码(<em>input and output encoding</em>)、mixing bijections的方式来保护AES在WBAC下的安全。这也是许多变种设计过程中使用的思路。</p><blockquote><ul><li>Encodings</li><li>Mixing Bijections</li></ul></blockquote><h4 id="Encodings"><a href="#Encodings" class="headerlink" title="Encodings"></a>Encodings</h4><p>Encodings 意图给原生的表加上内/外的保护，使得在AES做矩阵变换的时候，并不直接地产生裸结果。这可以使得疑惑2条件不成立。这是用来保护TboxTyiTable的。假设原生的$T-Box/T_{y_i}$表为$T$, 现在以$f$为输入编码，$g$为输出编码，构建<br>$$<br>T’ = g \circ T \circ f^{-1}<br>$$<br>内编码不暴露的情况下，攻击者无法从一轮中的中间数据得到相应的映射。或者说，<strong>攻击者没有办法从这个$T’$中获得关于T的信息。</strong>考虑非线性$f$对4比特(one nibble)数据进行encoding，并采用concat的形式联合：<br>$$<br>f(x_0 || x_1) = f_1(x_0) || f_2(x_1),\ x_i\ is\ a\ nibble<br>$$<br>设这种encoding为$O$。$OT$没有泄漏任何关于$T$的信息。4比特可以产生$16!$种不重复的数值变换。对应地，每个字节就是$(16!)^2$种encoding。若加上output encoding, 则为$(16!)^2 (16!)^8$。这枚举是非常困难的。对于目标T表，以及任意非目标的$T’$表，都存在一个非线性映射$O’$, 使得$O’T’ = OT$。爆破理论上是不可行的。</p><p>另外，这种encoding是可以被networked的。不同的表可以被串联起来。这使得内部的推导会更难。<br>在Github.com/OpenWhiteBox/AES/的chow实现中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tyiEncoding encodes the output of a T-Box/Tyi Table / the input of a HighXORTable.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All randomness is derived from the random source; round is the current round; position is the byte-wise position in</span></span><br><span class="line"><span class="comment">// the state matrix being stretched; subPosition is the nibble-wise position in the Word table's output.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tyiEncoding</span><span class="params">(rs *random.Source, round, position, subPosition <span class="keyword">int</span>)</span> <span class="title">encoding</span>.<span class="title">Nibble</span></span> &#123;</span><br><span class="line">label := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">label[<span class="number">0</span>], label[<span class="number">1</span>], label[<span class="number">2</span>], label[<span class="number">3</span>] = <span class="string">'T'</span>, <span class="keyword">byte</span>(round), <span class="keyword">byte</span>(position), <span class="keyword">byte</span>(subPosition)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rs.Shuffle(label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对T表的encoding就是4比特的。</p><p>在文[^ 1]的图里，是不包含了encoding部分的。在进行分析的时候我们有意抹去了encoding，因为encoding的安全性来自于外部。这不是算法安全性分析的范畴。 </p><h4 id="Mixing-Bijections"><a href="#Mixing-Bijections" class="headerlink" title="Mixing Bijections"></a>Mixing Bijections</h4><p>Mixing Bijections是加密过程中增加的一个线性变换。用于对TboxTyiTable的扩散。encoding 实现了对密钥的混淆，每一轮中插入的Mixing Bijections则强化了密钥的扩散。被随机选择的Mixing Bijection变换都能够提高AES原生表的复杂性。作用在代码中耦合，会使得查表环节无法从TboxTyiTable的求解依赖于混入双射变换矩阵MB。根据chow的实现，选择一个GF(2)内的可逆矩阵MB，<br>于是我们是这样构造的。<br><!-- <img src="http://139.196.203.106:800/images/2020/04/09/chow.jpg" alt="chow's implementation" style="self-align:center; zoom:60%;" /> --><br><img src="/images/aes2.png" alt=""></p><ol><li>由于第一轮，在输入的时候为明文/密文，这一轮应该用下文提及的外部编码（external encoding）来处理。这一轮的输入端不进行双射混合。</li><li>第2到10轮，选择<u>8比特到8比特的</u>变换矩阵，附加在T表输入之前。</li><li>1～9轮，在T表的输出端加上32-bit到32-bit的映射。</li></ol><p>原来的TboxTyiTable表：<br>$$<br>T_{y_0}\circ T^2_0 \\<br>T_{y_1}\circ T^2_1 \\<br>T_{y_2}\circ T^2_2 \\<br>T_{y_3}\circ T^2_3 \\<br>$$</p><p>现在的$T’$表：<br>$$<br>MB \circ T_{y_0}\circ T^2_0 \circ {L^2_0}^{-1}\ (1) \\<br>MB \circ T_{y_1}\circ T^2_1 \circ {L^2_1}^{-1}\\<br>….<br>$$<br>$L$是8-bit到8-bit的输入mixing bijection, MB是32 -&gt; 32的输出mixing bijection。这些表的最终结果被XOR起来。<br>为了下一轮计算可以进行，(1)中$MB$的效果需要被去除，而需要加上$L$。$MB^{-1}$作用于（1）产生的32bit结果，然后给每一个字节作用上$L^3$（此处为第三轮，所以为$L^3$），则结果可供给下一轮进行。<br>所以，Mixing Bijection的运行过程是，</p><ol><li>8bit$L{-1}$作用于输入$I$，得到$I_1$</li><li>TboxTyiTable作用于$I_1$，得到32bit值</li><li>将4个32bit值XOR，得到中间值$I_2$</li><li>32bit的$I_2$每个字节被$MB^{-1}$作用得到32bit中间值，然后被32-&gt;32$L$进行Mixing Bijection</li><li>4个32bit值XOR成一个32bit，成为下一轮的state</li></ol><h4 id="外部编码"><a href="#外部编码" class="headerlink" title="外部编码"></a>外部编码</h4><p>为了防止裸（raw）的明文到密文，或密文到明文的映射，以保护加密/解密器在特定环境下使用，可以给加密/解密器加上特定的外部编码。假定原来的解密器为$D_k$，则构建<br>$$<br>D’_k = G \circ D_k \circ F^{-1}<br>$$<br>$F$是输入编码，$G$是输出编码。这种方式在特定条件下可以保护DFA攻击[^ 4]。</p><p>[^1]: <a href="https://eprint.iacr.org/2013/104.pdf">James A. Muir, A Tutorial on White-box AES</a><br>[^2]: <a href="http://home.eng.iastate.edu/~daji/seminar/papers/BVS03.UsenixSec.pdf">S. Bhatkar, D. C. DuVarney, R. Sekar, Address obfuscation: an efficient approach to combat a broad range of memory error exploits, in Proceedings of the 12th USENIX Security Symposium. USENIX Association (2003)</a><br>[^3]: C. Linn, S.K. Debray. Obfuscation of executable code to improve resistance to static disassembly, in S. Jajodia, V. Atluri, and T. Jaeger, editors, Proceedings of the 10th ACM Conference on Computer and Communications Security, CCS 2003. ACM (2003), pp. 290–299<br>[^4]: <a href="https://link.springer.com/article/10.1007/s00145-019-09315-1">White-Box Cryptography: Don’t Forget About Grey-Box Attacks</a><br>[^5]: <a href="http://www.bookmetrix.com/detail_full/chapter/de2269fa-625c-443e-9fe3-7ff35f2bc046#citations">WHITE-BOX CRYPTOGRAPHY AND AN AES IMPLEMENTATION</a><br>[^6]: 详见CANSv7<br>[^7]: <a href="https://eprint.iacr.org/2014/474.pdf">Biryukov A, Bouillaguet C, Khovratovich D. Cryptographic schemes based on the ASASA structure: black-box, white-box, and public-key[C]. In: Advances in Cryptology—ASIACRYPT 2014. Springer Berlin Heidelberg, 2014: 63–84.</a><br>[^10]: <a href="https://gongzheng.github.io/">https://gongzheng.github.io/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;白盒密码是对非可信平台下的密码算法安全实现的研究。其针对密码学算法在非可信平台设计实现，使得软件（数字内容）在具有完全操控（debugger，assembler）情况下获得安全保护。论文[^1]简要介绍AES在白盒攻击环境 (White-box Attack Context) 下AES的一种实现方式及其密码学分析。&lt;br&gt;
    
    </summary>
    
    
      <category term="Cryptography" scheme="https://blog.wxk.me/categories/Cryptography/"/>
    
    
      <category term="crypto" scheme="https://blog.wxk.me/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 二分查找</title>
    <link href="https://blog.wxk.me/2019/03/20/binary_search/"/>
    <id>https://blog.wxk.me/2019/03/20/binary_search/</id>
    <published>2019-03-20T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.797Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“90%的程序员不能写出正确的二分查找” – 不是我说的</p></blockquote><p>二分查找及其变种有很多种形式，例如查找第一个出现的、查找出现的区间，等。但都不能脱离一个宗旨：每次查找都要有下标的更迭。</p><a id="more"></a><p>一个经典的二分查找的错误是，出现了下标分别处在了i和i+1，而却判断<code>nums[l] &lt; nums[mid] ? l = mid : r = mid</code>。（这里是不规范的写法）。这会可能导致产生一个死循环，因为，(i + i + 1) // 2 = i。如果第一个判断条件被命中，则永远循环在了那儿。</p><p>另外一个不恰当的做法是，判断两边的值，进而判断是否到了边界，然后判断mid值。这种做法可能导致的错误是，l == i, r == i + 1 时，我的mid又要被判断了一次。这种做法是比较冗余的，而且可能导致insidious bug。</p><p>基本正确做法是，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bin_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function"><span class="comment">/* 判断是否存在，且数值不重复的情况 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">        <span class="comment">/* target在 mid左边 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* 因为 (i + i + 1) // 2 -&gt; i, r = mid就行了 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l] == target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些变种：</p><p>数值存在，找边界：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LeetCode p34 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 找小边界 */</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; l) &#123;</span><br><span class="line">            mid = (j + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 不存在，返回 */</span></span><br><span class="line">        <span class="keyword">if</span> (nums[j] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 找大边界 */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; r) &#123;</span><br><span class="line">            mid = (i + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[r] == target ? <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;l, r&#125; : <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;l, r - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>二分查找的边界条件十分值得注意。很容易出现查找缺漏、死循环的情况。</p><p>如有错误，恳请指正！ </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“90%的程序员不能写出正确的二分查找” – 不是我说的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二分查找及其变种有很多种形式，例如查找第一个出现的、查找出现的区间，等。但都不能脱离一个宗旨：每次查找都要有下标的更迭。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://blog.wxk.me/categories/LeetCode/"/>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode T17 - Phone Number</title>
    <link href="https://blog.wxk.me/2019/02/05/leetcode17/"/>
    <id>https://blog.wxk.me/2019/02/05/leetcode17/</id>
    <published>2019-02-05T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.801Z</updated>
    
    <content type="html"><![CDATA[<h6 id="刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c-写：“哇靠，垃圾程序的典范！😭”"><a href="#刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c-写：“哇靠，垃圾程序的典范！😭”" class="headerlink" title="刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c++写：“哇靠，垃圾程序的典范！😭”"></a>刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c++写：“哇靠，垃圾程序的典范！😭”</h6><p>第17题是一个典型选择问题，要求从给定的数字中选择几个需要的字母。解法存在优化，但基本上就是DFS。leetcode 17 题的一个解法如下。<br><a id="more"></a></p><p>这里是递归的做法，非常好理解：</p><ul><li>base case：如果最后一个数字，则逐一添加每个字母到需要被添加的子串中；</li><li>recurrence case：如果非最后一个，则遍历当前的所有字母，进入下一个循环。</li></ul><p>其实，这种类似尾递归的做法，编译器可以优化。但做题的时候，leetcode好像出了问题，不管怎么优化都没法做到0ms。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> mapping[<span class="number">8</span>]&#123;<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Solution() &#123;&#125;</span><br><span class="line">    ~Solution() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; i : digits) &#123;</span><br><span class="line">            m.push_back(getString(i - <span class="string">'0'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        solve(m, <span class="string">""</span>, <span class="number">0</span>, digits.length());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;m, <span class="built_in">string</span> candidate, <span class="keyword">int</span> ptr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span>&amp; i : m[ptr]) &#123;</span><br><span class="line">                s.push_back(candidate + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span>&amp; i : m[ptr]) &#123;</span><br><span class="line">                solve(m, candidate+i, ptr+<span class="number">1</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">getString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> mapping[a - <span class="number">2</span>]; &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归改迭代：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Solution() &#123;&#125;</span><br><span class="line">    ~Solution() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; mapping&#123;</span><br><span class="line">            &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;,  &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;, &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; steps&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : digits) &#123;</span><br><span class="line">            sum *= mapping[i].length();</span><br><span class="line">            steps.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">m</span><span class="params">(sum)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; digits.length(); i++) &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; s = mapping[digits[i]];</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + sum / steps[i + <span class="number">1</span>]; k++) &#123;</span><br><span class="line">                    m[k] += s[(k / (sum / steps[i + <span class="number">1</span>])) % s.length()];</span><br><span class="line">                &#125;</span><br><span class="line">                j += sum / steps[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c-写：“哇靠，垃圾程序的典范！😭”&quot;&gt;&lt;a href=&quot;#刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c-写：“哇靠，垃圾程序的典范！😭”&quot; class=&quot;headerlink&quot; title=&quot;刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c++写：“哇靠，垃圾程序的典范！😭”&quot;&gt;&lt;/a&gt;刷LeetCode的时候发现一个道理。用go语言写：“哇塞，我挺厉害的嘛”；用c++写：“哇靠，垃圾程序的典范！😭”&lt;/h6&gt;&lt;p&gt;第17题是一个典型选择问题，要求从给定的数字中选择几个需要的字母。解法存在优化，但基本上就是DFS。leetcode 17 题的一个解法如下。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://blog.wxk.me/categories/LeetCode/"/>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 笔记</title>
    <link href="https://blog.wxk.me/2019/01/01/effective-cpp-notes/"/>
    <id>https://blog.wxk.me/2019/01/01/effective-cpp-notes/</id>
    <published>2019-01-01T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.798Z</updated>
    
    <content type="html"><![CDATA[<p>This is a piece of individual notes of effect c++, which contains personal opinion and example.</p><a id="more"></a><h3 id="签名，声明，定义"><a href="#签名，声明，定义" class="headerlink" title="签名，声明，定义"></a>签名，声明，定义</h3><p>签名指代函数返回值+变量的类型，<code>size_t (int)</code></p><p>声明指代函数的返回值、变量名、名称的说明，<code>size_t rtt(int proj);</code></p><p>定义指代函数的具体内容，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">rtt</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a, <span class="number">2</span>)+<span class="built_in">pow</span>(a, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="item-6-必要时阻止拷贝，阻止默认构造-析构-拷贝行为"><a href="#item-6-必要时阻止拷贝，阻止默认构造-析构-拷贝行为" class="headerlink" title="item 6: 必要时阻止拷贝，阻止默认构造/析构/拷贝行为"></a>item 6: 必要时阻止拷贝，阻止默认构造/析构/拷贝行为</h3><ul><li><p>若要<strong>编译期</strong>阻止拷贝/构造，将拷贝/构造函数写入 <code>private</code> 然后不实现（单例类常用实现）</p><ul><li>循环引用会导致non-local行为，使得单例也面临不一致问题。</li></ul></li><li><p>derived class阻止拷贝，继承 <code>uncopyable</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">uncopyable</span> &#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    uncopyable() &#123;&#125;</span><br><span class="line">    ~uncopyable() &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    uncopyable(<span class="keyword">const</span> uncopyable&amp;);</span><br><span class="line">    uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> uncopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="item-7-多态基类声明virtual析构函数"><a href="#item-7-多态基类声明virtual析构函数" class="headerlink" title="item 7: 多态基类声明virtual析构函数"></a>item 7: 多态基类声明virtual析构函数</h3><ul><li><p>虚析构函数：用于<strong>多态基类</strong></p></li><li><p>虚析构函数防止derived class局部销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> AB;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    B() : A() &#123;&#125;</span><br><span class="line">    ~B()&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line">B* hi = <span class="keyword">new</span> B;</span><br><span class="line">A* well = hi;</span><br><span class="line"><span class="keyword">delete</span> well; <span class="comment">// 只有 A 的部分会被析构，B 的private b 不会被析构！</span></span><br><span class="line"> <span class="comment">// 行为未定义，内存泄漏，数据（内存）结构破坏</span></span><br></pre></td></tr></table></figure></li><li><p>虚析构函数生成的vtbl会加大内存占用量：</p><ul><li>如果class不含析构函数，意味着不被用为一个base class</li><li>当class中带有虚函数，才需要有虚析构函数</li></ul></li><li><p>pure virtual: 纯虚函数，阻止初始化；</p><ul><li><p>构造纯虚类：纯虚析构函数，同时需要提供析构函数实现：最深层派生的class先被调用，然后才是base class。如果pure virtual destructor没有实现，则该类无法析构，连接器报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMOV</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AMOV() = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">AMOV::~AMOV() &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="item-8-析构函数不可流出异常"><a href="#item-8-析构函数不可流出异常" class="headerlink" title="item 8: 析构函数不可流出异常"></a>item 8: 析构函数不可流出异常</h3><ul><li>如果不需要处理，<code>try...catch...</code>，然后吸收或者结束程序</li><li>如果需要处理，单独成立一个函数让用户handle异常</li></ul><h3 id="item-9"><a href="#item-9" class="headerlink" title="item 9"></a>item 9</h3><p>​    构造/析构函数中，如果出现虚函数，被构造/析构的时候派生类会调用基类构造/析构实现。导致未定义错误。pure virtual函数同理。</p><h3 id="item-10-operator"><a href="#item-10-operator" class="headerlink" title="item 10: operator="></a>item 10: operator=</h3><p>​    operator=返回*this，可以使得行为与基础类型一致。</p><h3 id="item-11-的自我赋值"><a href="#item-11-的自我赋值" class="headerlink" title="item 11 =的自我赋值"></a>item 11 =的自我赋值</h3><p>​    解决 = 自我赋值问题：copy-and-swap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">widget &amp; widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> widget&amp; rhs) &#123;</span><br><span class="line">    widget tmp(rhs);</span><br><span class="line">    swap(tmp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="item-12-继承、拷贝问题"><a href="#item-12-继承、拷贝问题" class="headerlink" title="item 12 继承、拷贝问题"></a>item 12 继承、拷贝问题</h3><p>​    继承-拷贝问题：派生类赋值需要考虑基类的数据继承问题，可以考虑用基类的<code>operator=</code>进行赋值操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">    D(<span class="keyword">const</span> D&amp; d)&#123;</span><br><span class="line">        B::Operator=(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="item-17"><a href="#item-17" class="headerlink" title="item 17"></a>item 17</h3><p>​    独立生成new语句，放入智能指针，以避免顺序生成异常造成的内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::share_ptr&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>]), priority())</span></span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   如果new出错，priority已完成，那priority可能内存泄漏</span></span><br><span class="line"><span class="comment">   如果priority出错，new完成但未进入share_ptr, new int[12]</span></span><br><span class="line"><span class="comment">   将内存泄漏</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正确示范 */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::share_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(tmp, priority())</span></span>;</span><br></pre></td></tr></table></figure><h3 id="item-19-25-提高封装性，可用性，代码清晰度"><a href="#item-19-25-提高封装性，可用性，代码清晰度" class="headerlink" title="item 19 ~ 25: 提高封装性，可用性，代码清晰度"></a>item 19 ~ 25: 提高封装性，可用性，代码清晰度</h3><ul><li><p><u>面向对象的三特性：封装性，继承性，多态性</u></p></li><li><p>封装性越高，底层实现的灵活度越高；</p></li><li><p>声明成员变量为private，并用getter、setter，以防止直接操作：成员变量描述内部状态，公共成员函数提供接口；</p></li><li><p>non-member non-friend 函数替代 member 函数：降低外部访问度，提高封装性</p></li><li><p>operator，等函数：对于类，pass-by-reference-to-const，减少可能的复制(c++17 有优化，编译器也会进行一定的优化)</p></li><li><p><strong>argument dependent lookup:</strong> 对于不同命名空间内的函数，根据argument dependent lookup 原则，首先会调用本全局函数，再（自身）命名空间内的函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doS</span><span class="params">(T&amp; l, T&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swap(l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器首先搜寻全局域，看是否有l，r的全特化；然后寻找l，r所属类所属命名空间，查找是否有</span></span><br><span class="line"><span class="comment">// 全特化，最后再调用标准的swap.</span></span><br></pre></td></tr></table></figure></li><li><p>成员函数swap特化具有STL的一致性，但依旧需要提供非成员函数swap，以提高封装性与可操作性。（个人见解）</p></li></ul><h3 id="item-26：尽可能延后定义式的出现，避免不必要的构造-析构成本"><a href="#item-26：尽可能延后定义式的出现，避免不必要的构造-析构成本" class="headerlink" title="item 26：尽可能延后定义式的出现，避免不必要的构造/析构成本"></a>item 26：尽可能延后定义式的出现，避免不必要的构造/析构成本</h3><p>当函数定义了一个对象后，会调用默认（或给定）构造函数，并在区域结束时会调用析构函数；一般情况下，非到对象初值确定，不对其进行定义；若在循环体中，应考量构造、析构、赋值的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSTH</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 如果if内抛出异常，则b的构造、析构开销是无用的 */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> b;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = impl;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(impl)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="item-29-异常安全-（important）"><a href="#item-29-异常安全-（important）" class="headerlink" title="item 29: 异常安全 （important）"></a>item 29: 异常安全 （important）</h3><p>线程安全函数的保证：</p><ul><li>基本承诺：如果异常被抛出，程序内任何事物仍然处于有效状态。所有原有状态不改变。</li><li>强烈保证：程序状态不改变：commit or rollback</li><li>nothrow保证：函数不抛出异常</li></ul><p>异常安全具有随后性，如果一个函数中包含基本安全函数、强烈安全函数，那该函数的安全性为基本安全。</p><h3 id="item-31-编译壁垒"><a href="#item-31-编译壁垒" class="headerlink" title="item 31: 编译壁垒"></a>item 31: 编译壁垒</h3><p><a href="https://cpppatterns.com/patterns/pimpl.html">The PIMPL idiom</a></p><h3 id="item-32-33-public-inherit-is-a"><a href="#item-32-33-public-inherit-is-a" class="headerlink" title="item 32-33: public inherit: is-a"></a>item 32-33: public inherit: is-a</h3><p>继承关系，<strong>is-a</strong>;</p><p>避免<code>derived class</code>的作用域覆盖问题：</p><p>若derived class中复写base class中的方法，则基类同名方法不可用。</p><p><strong>不管base class里是否virtual，都会因为覆写而被屏蔽。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mt1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mt1</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mt1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////</span></span><br><span class="line">D dm;</span><br><span class="line">dm.mt1() <span class="comment">// dm.D::mt1()</span></span><br><span class="line">dm.mt1(x); <span class="comment">// 错误！overwrite！</span></span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> B::mf1; <span class="comment">// 此处只能用mf1不能mf1(double),</span></span><br><span class="line">                      <span class="comment">// 名称与命名空间的引用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字：<code>using</code></p><p>另外方法：forwarding：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base::mf1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Item-34-区分接口继承与实现继承"><a href="#Item-34-区分接口继承与实现继承" class="headerlink" title="Item 34: 区分接口继承与实现继承"></a>Item 34: 区分接口继承与实现继承</h3><ul><li>成员函数的接口总会被继承</li><li>pure virtual func是为了继承接口</li><li>impure virtual func继承的同时提供了缺省实现</li><li>non-virtual func继承提供了强实现，不允许重写</li></ul><p>接口有限继承，避免默认基类方法：（显式指定缺省方法）</p><ol><li><p><code>protected</code> default function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    defaultEcho() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"echo::A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        defaultEcho();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>instantiation for pure virtual function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"echo::A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A::echo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Item-37：virtual-函数参数缺省值问题"><a href="#Item-37：virtual-函数参数缺省值问题" class="headerlink" title="Item 37：virtual 函数参数缺省值问题"></a>Item 37：virtual 函数参数缺省值问题</h3><p>不要重复定义一个继承而来的缺省参数值，会导致派生类的缺省值失效。</p><h5 id="动态类型与静态类型"><a href="#动态类型与静态类型" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h5><p>动态类型绑定(dynamically bound)与静态类型绑定(statically bound)问题：声明中所采用的类型，成为静态类型；实际使用中的类型，称为动态类型。e.g.:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i</span><br><span class="line">  &lt;&lt; <span class="string">"Shape"</span></span><br><span class="line">  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> i = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i</span><br><span class="line">  &lt;&lt; <span class="string">"Circle"</span></span><br><span class="line">  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ps为Shape*类型，静态类型为Shape*</span></span><br><span class="line"><span class="comment"> * ps指向了Circle，其动态类型为Circle</span></span><br><span class="line"><span class="comment"> * ps调用virtual函数会使用Circle的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Shape* ps = <span class="keyword">new</span> Circle;</span><br></pre></td></tr></table></figure></p><p>为提升运行期效率，<strong>在编译期决定缺省参数值</strong>，<u>C++会使用基类中virtual函数的缺省参数值</u>。e.g.:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此命令会使用Shape提供的 i = 0;</span></span><br><span class="line">ps-&gt;echo();</span><br><span class="line"><span class="comment">// 输出的结果是：</span></span><br><span class="line"><span class="comment">// 0Circle\n</span></span><br></pre></td></tr></table></figure></p><p>为解决上述问题，并降低派生类中的代码重复，防止一个缺省值出现多次，可以采用item35提及的NVI方法或者其他替代方案。例如NVI，将实际运行函数置于<code>private</code>中，然后基类中使用non-virtual public函数调用private函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">doEcho(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doEcho</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doEcho</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape* ps = <span class="keyword">new</span> Circle;</span><br><span class="line">ps-&gt;echo(); <span class="comment">// 此处使用的i = 0;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is a piece of individual notes of effect c++, which contains personal opinion and example.&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://blog.wxk.me/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode T15 - 3Sum</title>
    <link href="https://blog.wxk.me/2018/12/20/leetcode15/"/>
    <id>https://blog.wxk.me/2018/12/20/leetcode15/</id>
    <published>2018-12-20T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode T 15: 3Sum是一个比较普通的问题，考验一定的思维和编程能力。</p><p>描述：给定一个长为$n$的数组<code>nums</code>，请问数组中是否包含三个元素a, b, c, 使得 a + b + c = 0? 找到数组中所有这类元素的三元组。<br><a id="more"></a><br>注意：<br>解决方案中不得包含重复的三元组。</p><p>例子：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="built_in">array</span> nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>从题目我们可以知道，需要找到所有不重复的$(a, b, c)$，使得$a + b + c = 0$。这里有一个关键点：不重复。</p><p>为达到这个目标，首先我们需要对原数组进行排序，以进行序列的比较筛除重复的元素。如：<code>[0, 0, 0, 0]</code>，如果不进行筛除，将会得到<code>[[0, 0, 0], [0, 0, 0]]</code>，这是不符合规范的。<br>同时，我们需要进行搜索，需要一定的时间优化。如果用暴力，将是$O(n^3)$的时间复杂度，这将是非常令人不满的。因为LeetCode会报TLE。<br>于是，设计了一个思路：指针i, j, k分别指向三个元素，i从0开始迭代到len(nums)-2，j从i+1开始迭代到len(nums)-1，k采用二分查找。</p><p>最后代码是这样(Golang)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    lens := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> matrix [][]<span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 长度不够，返回空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lens<span class="number">-2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 第一个元素就&gt;0, 意味着所有元素&gt;0</span></span><br><span class="line">        <span class="keyword">if</span>  nums[<span class="number">0</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; lens<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            l := j + <span class="number">1</span></span><br><span class="line">            r := lens - <span class="number">1</span></span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">                <span class="keyword">if</span> l == r<span class="number">-1</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> nums[i]+nums[j]+nums[l] == <span class="number">0</span> &#123;</span><br><span class="line">                        matrix = <span class="built_in">append</span>(matrix, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[l]&#125;)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[r] == <span class="number">0</span> &#123;</span><br><span class="line">                        matrix = <span class="built_in">append</span>(matrix, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[r]&#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                mid := (l + r) / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j] &lt; -nums[mid] &#123;</span><br><span class="line">                    l = mid</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j] &gt; -nums[mid] &#123;</span><br><span class="line">                    r = mid</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    matrix = <span class="built_in">append</span>(matrix, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[mid]&#125;)</span><br><span class="line">                    <span class="keyword">for</span> j &lt; lens<span class="number">-1</span> &amp;&amp; nums[j] == nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                        j++</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有1个元素的特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> l == r &#123;</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[l] == <span class="number">0</span> &#123;</span><br><span class="line">                    matrix = <span class="built_in">append</span>(matrix, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[r]&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 迭代完成，去除重复元素</span></span><br><span class="line">            <span class="keyword">for</span> j &lt; lens<span class="number">-1</span> &amp;&amp; nums[j] == nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i迭代完成，去除重复元素</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; lens<span class="number">-2</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个答案依然不是最好的，时间已经是1024ms，超过了一般规定的1000ms。其实，<strong>3Sum问题本质上是2Sum问题</strong>。因为a = -(b+c)，所以a从0迭代到len(nums)-2，只要保证j，k构成的2Sum和a加起来是0就正确。这就是最优的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode T 15: 3Sum是一个比较普通的问题，考验一定的思维和编程能力。&lt;/p&gt;
&lt;p&gt;描述：给定一个长为$n$的数组&lt;code&gt;nums&lt;/code&gt;，请问数组中是否包含三个元素a, b, c, 使得 a + b + c = 0? 找到数组中所有这类元素的三元组。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://blog.wxk.me/categories/LeetCode/"/>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>HAProxy实现前-后端热调试</title>
    <link href="https://blog.wxk.me/2018/12/15/haproxy/"/>
    <id>https://blog.wxk.me/2018/12/15/haproxy/</id>
    <published>2018-12-15T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.799Z</updated>
    
    <content type="html"><![CDATA[<p>由于前端用了vue，后端用了go，webpack的proxy是一种策略，可是<code>vue create</code>构建的应用似乎找不到入口，加上对webpack的不熟悉，便用haproxy进行反代调试。前后端任意调试的过程中都不需要停机-构建-启动-看情况的过程，实现了热调试。</p><a id="more"></a><p>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">maxconn     4000</span><br><span class="line">daemon</span><br><span class="line"># turn on stats unix socket</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">mode                    http</span><br><span class="line">option                  redispatch</span><br><span class="line">retries                 3</span><br><span class="line">timeout http-request    10s</span><br><span class="line">timeout queue           1m</span><br><span class="line">timeout connect         10s</span><br><span class="line">timeout client          1m</span><br><span class="line">timeout server          1m</span><br><span class="line">timeout http-keep-alive 10s</span><br><span class="line">timeout check           10s</span><br><span class="line">maxconn                 4000</span><br><span class="line"></span><br><span class="line">frontend http-in</span><br><span class="line">bind *:80</span><br><span class="line">mode http</span><br><span class="line">acl url_backend path_beg       -i /api </span><br><span class="line">use_backend backend_servers         if url_backend</span><br><span class="line">default_backend front_servers</span><br><span class="line">backend backend_servers</span><br><span class="line">server imgsrv1 127.0.0.1:4000 check maxconn 1000</span><br><span class="line"></span><br><span class="line">backend front_servers</span><br><span class="line">cookie srv insert nocache</span><br><span class="line">server websrv1 127.0.0.1:8080 check maxconn 1000 cookie websrv1</span><br></pre></td></tr></table></figure></p><p>通过如上设置，服务端映射到/api路由下，是4000端口-80端口；客户端映射到/路由下，是8080-80端。这样调试的时候就避开了跨域问题，对往后的部署有更好的非侵入性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于前端用了vue，后端用了go，webpack的proxy是一种策略，可是&lt;code&gt;vue create&lt;/code&gt;构建的应用似乎找不到入口，加上对webpack的不熟悉，便用haproxy进行反代调试。前后端任意调试的过程中都不需要停机-构建-启动-看情况的过程，实现了热调试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellaneous" scheme="https://blog.wxk.me/categories/miscellaneous/"/>
    
    
      <category term="HAProxy" scheme="https://blog.wxk.me/tags/HAProxy/"/>
    
  </entry>
  
  <entry>
    <title>Manacher 算法：求最长回文子串</title>
    <link href="https://blog.wxk.me/2018/12/01/manacher/"/>
    <id>https://blog.wxk.me/2018/12/01/manacher/</id>
    <published>2018-12-01T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.801Z</updated>
    
    <content type="html"><![CDATA[<p>网络上关于最长回文子串的文章很多，这里只是为了记录一下思路与过程。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>manacher算法是一个高效的寻找最长回文子串的算法，时间复杂度和空间复杂度均为$O(n)$，相比于朴素算法有很高的优势。它利用了回文串镜像对称的性质，通过不断（间接）记录以每一个字符为中心的回文串长度，找到最大的回文子串。</p><h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>回文串，就是对称的串。比如：aba，abcba。最大回文子串，就是一个字符串中存在一个子串，使得它的长度是所有回文子串中最长的。例如：abcbac最长的，abcba，长度为5，是最大的回文子串。</p><p>为了方便讨论，我们假设总字符串为$S$, 回文串为$s$, 对于一个回文串，定义：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">s</span><span class="selector-class">.center</span> # 回文串的中心位置，暂不区分奇偶</span><br><span class="line"><span class="selector-tag">s</span><span class="selector-class">.st</span>     # 回文串开始的位置</span><br><span class="line"><span class="selector-tag">s</span><span class="selector-class">.nd</span>     # 回文串结束的位置</span><br><span class="line"><span class="selector-tag">s</span><span class="selector-class">.mx</span>     # 在<span class="selector-tag">s</span><span class="selector-class">.center</span>右方，离<span class="selector-tag">s</span><span class="selector-class">.center</span>最远的下标</span><br></pre></td></tr></table></figure></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><h6 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h6><p>对称，最基本的特性。<code>str = abcba</code>，那么<code>str[i] == str[len(str)-i-1]</code>。就是，第一个a和最后一个a，第二个b和倒数第二个b，都跟串的中心，c，对称。</p><h6 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h6><p>在一个回文串$s, s.size == n$中，若以i为中心的字符串<code>a[i]</code>（i != s.center），是一个回文串，那么，对应的s的中心对称的位置也是一个回文串。</p><p>e.g.:</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="comment">"a b a a b a"</span></span><br></pre></td></tr></table></figure><p>在str中，若以str[1]为中心，可以得到一个回文串<code>aba</code>。在str[1]以str.center对称的位置上，str[4]也是一个回文串，<code>aba</code>.</p><p><img src="/images/s1.jpeg" alt="阐述"></p><p>这幅图阐述了这个性质。以id为中心，mx为边界，是一个回文串。同时，以j为中心存在一个回文串$s_1$。那么，以id对称的位置，也会有一个一样的字符串$s_2$存在。i就是这个串的中心。</p><p>然而，并非i处的回文串一定和j处的相同。有可能会有更长的情况，但这种情况只在i出现，不在j出现，于是乎需要从原始的$s_2$边界开始，向外搜索，就可以得到以i为中心的最长串。</p><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p>利用这写特性，我们来设计算法：<br>go的代码实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// min 求两个int的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// longestPalindrome 主要函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer <span class="comment">// 用来拼接字符串的buffer</span></span><br><span class="line"><span class="comment">// predo</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">buf.WriteByte(<span class="string">'#'</span>)</span><br><span class="line">buf.WriteByte(<span class="keyword">byte</span>(s[i]))</span><br><span class="line">&#125; </span><br><span class="line">buf.WriteByte(<span class="string">'#'</span>)</span><br><span class="line">    <span class="comment">// 给字符串每一个字符之间加一个#，例如：</span></span><br><span class="line">    <span class="comment">// abcbac，--&gt; #a#b#c#b#a#c#</span></span><br><span class="line">    <span class="comment">// 这样做的好处是，无论原来的字符串是奇数串还是偶数串，</span></span><br><span class="line">    <span class="comment">// 都可以格式化为奇数串，这样s.center就不会是一个</span></span><br><span class="line">    <span class="comment">// 的间隙 </span></span><br><span class="line"></span><br><span class="line">format := buf.String()</span><br><span class="line">p := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(format))</span><br><span class="line">center, mx := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(format); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; mx &#123;</span><br><span class="line">p[i] = min(mx-i, p[<span class="number">2</span>*center-i])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i-p[i] &gt;= <span class="number">0</span> &amp;&amp; i+p[i] &lt; <span class="built_in">len</span>(format) &amp;&amp; format[i+p[i]] == format[i-p[i]] &#123;</span><br><span class="line">p[i] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mx-center &lt; p[i] &#123;</span><br><span class="line">mx = i + p[i]</span><br><span class="line">center = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resBuf bytes.Buffer</span><br><span class="line">st := center - (p[center] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := st; i &lt; p[center]+center; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> format[i] != <span class="string">'#'</span> &#123;</span><br><span class="line">resBuf.WriteByte(format[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resBuf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h4 id="预处理：转换为奇字符串"><a href="#预处理：转换为奇字符串" class="headerlink" title="预处理：转换为奇字符串"></a>预处理：转换为奇字符串</h4><p>对字符串$S$，利用#填充字符之间的空隙，以达到将其转换为奇数串的目的。这样的好处是，任意下标的字符串都是一个奇数串，中心是可以由下标确定的，而不是像abba这样，中心在间隙中。<br>证明：任意串<code>s</code>，设 l = s.length()，那包括两端，l的间隙包含l+1个空位。那么，填充之后的字符串$S’$就包含$2l+1$个字符，是一个奇串。即使存在偶数回文串，那也可以以#为中心向两端扩张搜索。<br>e.g.:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abcdcbac"</span></span><br><span class="line">s1 = <span class="string">"<span class="subst">#a</span><span class="subst">#b</span><span class="subst">#c</span><span class="subst">#d</span><span class="subst">#c</span><span class="subst">#b</span><span class="subst">#a</span><span class="subst">#c</span>#"</span></span><br><span class="line"><span class="regexp">// center == s1[7] == 'd'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">s = "abbac"</span></span><br><span class="line"><span class="regexp">s1 = "<span class="comment">#a#b#b#a#c#"</span></span></span><br><span class="line"><span class="regexp">//</span> center == s1[<span class="number">4</span>] == <span class="string">'#'</span></span><br></pre></td></tr></table></figure></p><h4 id="回文串搜索"><a href="#回文串搜索" class="headerlink" title="回文串搜索"></a>回文串搜索</h4><p>Manacher算法的基础步骤是，从头到尾，以每一个字符为中心，向两端搜索，以获得最大的回文子串的中心点及边界。在这个基础上，算法还记录每个下标的字符所拥有的最长子串从中心到边界的长度。也就是说，存在标记mx，右边界，center，中心，p []int, 每个下标对应的回文子串长度。例如：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">init:</span><br><span class="line">mx = <span class="number">0</span> <span class="comment">// 最大回文子串的最右边界：0为初始值</span></span><br><span class="line">center = <span class="number">0</span> <span class="comment">// 最大回文子串的中心，0 init</span></span><br><span class="line">s1 = <span class="string">"#a#b#c#b#a#c#"</span> <span class="comment">// 处理过的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于记录每一个下标对应的最大子串</span></span><br><span class="line">p = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">iterate:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(s1); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; mx &#123;</span><br><span class="line">         p[i] = min(mx-i, p[<span class="number">2</span>*center-i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若i，即当前中心在回文串里时，有可能以这个中心包含一个回文串，</span></span><br><span class="line">    <span class="comment">// 那么这个中心的最大偏移数就是对称点的最大偏移数；</span></span><br><span class="line">    <span class="keyword">for</span> i-p[i] &gt;= <span class="number">0</span> &amp;&amp; i+p[i] &lt; len(format) &amp;&amp; format[i+p[i]] == format[i-p[i]] &#123;</span><br><span class="line">        p[i] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从基础值开始，寻找在最大偏移外部的串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> mx-center &lt; p[i] &#123;</span><br><span class="line">        mx = i + p[i]</span><br><span class="line">        center = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录最大的回文串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这三个步骤，最终得到最大子串的中心和边界，这样就可以从中过滤出最大回文子串了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络上关于最长回文子串的文章很多，这里只是为了记录一下思路与过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://blog.wxk.me/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://blog.wxk.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>OS Lab FTP客户端实现中踩过的坑</title>
    <link href="https://blog.wxk.me/2018/07/15/os_lab_ftp/"/>
    <id>https://blog.wxk.me/2018/07/15/os_lab_ftp/</id>
    <published>2018-07-15T15:59:59.000Z</published>
    <updated>2020-06-02T05:40:16.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>今年大二下OS lab从HTTP转变为FTP，要求实现客户端与服务端。参考文档为<a href="https://tools.ietf.org/html/rfc959">RFC 959</a>，语言不限（LJJ老师啥都没说），做法不限（兴许不要import ftp就行。。。），这里细数一下客户端编写过程中踩过的坑。由于还没有提交作业，就不贴ugly的代码了。。。<br><a id="more"></a><br>样例FTP客户端基于C++及Poco编写，利用Poco的StreamSocket或者DialogSocket与远端FTP服务器交互。FTP是一个有状态协议，但对于状态，大部分的工作只要服务器记住就行。客户端就可以乱来了。<br>FTP与远端包含两个连接，ctrl-connection 和 data-connection。大部分的命令通过ctrl走response，小部分（LIST，RETR，等数据交互）通过data走。对于一个用户一个会话，所有工作几乎都是阻塞的（ABOR命令除外）。因此，若实现minimum implementation，只要同步的模型就可以完成。ctrl-connection和data-connection由同一个线程发起，天然地保证N，N+1端口与远端交互。</p><h2 id="problems"><a href="#problems" class="headerlink" title="problems"></a>problems</h2><p>一个基本的控制交互过程是，本地生成socket，向远端建立连接，利用socket进行实时通信。所有的交互都是明文交互，因此可以读取、解析回复是什么东西。至于各个回复，RFC959说得就很清楚了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Session::pasv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ob buf;</span><br><span class="line">    <span class="built_in">string</span> format = <span class="string">"PASV\r\n"</span>;</span><br><span class="line">    <span class="function">RegularExpression <span class="title">pasv</span><span class="params">(<span class="string">"(\\d&#123;1,3&#125;),(\\d&#123;1,3&#125;)\\)"</span>)</span></span>;</span><br><span class="line">    ctrl_cnn.sendBytes(format.c_str(), format.length());</span><br><span class="line">    ctrl_cnn.receiveBytes(buf, buf.length());</span><br><span class="line"></span><br><span class="line">    reply rp = replyParser(buf.<span class="built_in">read</span>());</span><br><span class="line"></span><br><span class="line">    CHECK(rp, StatusPassiveMode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; filter;</span><br><span class="line">    pasv.split(rp.des, filter);</span><br><span class="line">    desDataPort = (stoi(filter[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) | stoi(filter[<span class="number">2</span>]);</span><br><span class="line">    data_cnn.<span class="built_in">connect</span>(Net::SocketAddress(addr.host(), desDataPort));</span><br><span class="line">    <span class="keyword">return</span> rp.code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这过程中，有一些让人卡壳的事情，总是导致it works, why? 这里例举了一下。</p><h6 id="CMAKE找不到库"><a href="#CMAKE找不到库" class="headerlink" title="CMAKE找不到库"></a>CMAKE找不到库</h6><p>我以及一些同学的项目中使用了CMAKE，所谓makefile for makefile。。。然鹅引用第三方库，是需要通过<code>find_library</code>和<code>target_link_library</code>才能找到相应的东西。CMAKE会给makefile添加特定的链接参数，这样才可以找到我们使用的库文件。<br>单句的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g file.cpp -o -file -lPocoNet -lPocoFoundation -lm</span><br></pre></td></tr></table></figure></p><p>如果没有添加链接参数，0ops，头文件找不着了。<br>最后CMakeList.txt大概长这样：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(final_lab_v2 VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(final_lab_v2 main.cpp</span><br><span class="line">                            FrontEnd.cpp</span><br><span class="line">                            Connector.cpp</span><br><span class="line">                            Session.cpp</span><br><span class="line">                            OnceBuffer.cpp</span><br><span class="line">                            Buffer.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(POCO_NET PocoNet)</span><br><span class="line"><span class="keyword">find_library</span>(POCO_FD PocoFoundation)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(final_lab_v2 <span class="variable">$&#123;POCO_NET&#125;</span> <span class="variable">$&#123;POCO_FD&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_definitions</span>(-I/usr/local/opt/openssl/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_NAME <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure></p><h6 id="socket数据传输的完整性问题"><a href="#socket数据传输的完整性问题" class="headerlink" title="socket数据传输的完整性问题"></a>socket数据传输的完整性问题</h6><p>这里涉及的，就包括什么时间传输完，什么时间接收完，以及粘包问题。在socket编程中，我们底层调用的函数为recv和send，而这两个函数可以设置为阻塞/非阻塞，利用多线程技术可以实现同步/异步。使用过程中发现，每次send一句命令，读的时候总能完整地读到相应的response。It works，why？</p><p>这里就要涉及阻塞、非阻塞的行为：<br>阻塞情况下:<br>在阻塞条件下，read/recv/msgrcv的行为:</p><ol><li>如果没有发现数据在网络缓冲中会一直等待，</li><li>当发现有数据的时候会把数据读到用户指定的缓冲区，但是如果这个时候读到的数据量比较少，比参数中指定的长度要小，read 并不会一直等待下去，而是立刻返回。<br><strong>read 的原则:是数据在不超过指定的长度的时候有多少读多少，没有数据就会一直等待。</strong><br>所以一般情况下:我们读取数据都需要采用循环读的方式读取数据，因为一次read 完毕不能保证读到我们需要长度的数据，read 完一次需要判断读到的数据长度再决定是否还需要再次读取。<br>非阻塞情况下:<br>在非阻塞的情况下，read 的行为:</li><li>如果发现没有数据就直接返回，</li><li>如果发现有数据那么也是采用有多少读多少的进行处理．<br>所以:read 完一次需要判断读到的数据长度再决定是否还需要再次读取。<br>对于读而言: 阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回．</li></ol><p>recv 中有一个MSG_WAITALL 的参数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv(sockfd, buff, buff_size, MSG_WAITALL),</span><br></pre></td></tr></table></figure></p><p>在正常情况下recv 是会等待直到读取到buff_size 长度的数据，但是这里的WAITALL 也只是尽量读全，在有中断的情况下recv 还是可能会被打断，造成没有读完指定的buff_size的长度。<br>所以即使是采用recv + WAITALL 参数还是要考虑是否需要循环读取的问题，在实验中对于多数情况下recv (使用了MSG_WAITALL)还是可以读完buff_size，所以相应的性能会比直接read 进行循环读要好一些。</p><p>So, 阻塞状态下，connect，send一句，receive一句，完整的，it works。正确性由Linux内核保证。参考书目：Unix网络编程。<br>还有一个就是粘包问题。粘包问题在golang TCP编程中是一个典型的问题。比如你发了RETR命令，服务端首先会发一个150的回复，在data传输完成之后，会发一个226的回复。如果你没有正确的时间点读到，两条回复就会粘在一起。这时候你就尴尬了，如何parse也是个问题。所以，阻塞状态下，send一个RETR，读150的response，然后再开始data_connection传送数据，然后再ctrl_cnn.recv，这样就可以保证正确的时序。粘包问题在FTP中基本就遇不到了。</p><h6 id="一些琐碎问题"><a href="#一些琐碎问题" class="headerlink" title="一些琐碎问题"></a>一些琐碎问题</h6><ol><li>每次发送/接收完数据，使用完毕后，buffer都要清空，因为上一次的数据会粘在\0后面。一个字符串读完了，但\0后面可能会保留上一次的东西，在数据写/ctrl parsing的时候，就容易出错。可以分装一个OnceBuffer。用memset去清空就行了。</li><li>发送/接收文件必须保证读完，另外写socket/文件的时候，不要固定buffer，要根据fread/receiveBytes的返回值来确定到底写多少。比如，固定buffer长度可能导致文件末尾多出了很多无用的0的问题。</li><li><code>#pragma once</code>保证了不会重复包含。</li><li>多行回复（HELP）咱就不做了，反正也不会给用户裸命令（逃</li><li>我们客户端是connection，用TCPserver是不行的（这是fei hua。。）</li><li>unique_ptr大幅度降低内存泄漏问题</li><li>用python写会更加快，会更加没有平台相关性，甚至可以用来写GUI。</li></ol><p><strong>坑都是一起踩的坑，这里感谢沉迷MC的黄板桥同学，沉迷WOW的向日葵同学，和吃麦当劳的ZLT同学hhhhhh</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;今年大二下OS lab从HTTP转变为FTP，要求实现客户端与服务端。参考文档为&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;，语言不限（LJJ老师啥都没说），做法不限（兴许不要import ftp就行。。。），这里细数一下客户端编写过程中踩过的坑。由于还没有提交作业，就不贴ugly的代码了。。。&lt;br&gt;
    
    </summary>
    
    
      <category term="networking" scheme="https://blog.wxk.me/categories/networking/"/>
    
    
      <category term="ftp" scheme="https://blog.wxk.me/tags/ftp/"/>
    
      <category term="lab" scheme="https://blog.wxk.me/tags/lab/"/>
    
  </entry>
  
  <entry>
    <title>计网-静态路由实验解析</title>
    <link href="https://blog.wxk.me/2018/05/05/static_route_lab/"/>
    <id>https://blog.wxk.me/2018/05/05/static_route_lab/</id>
    <published>2018-05-05T15:19:32.000Z</published>
    <updated>2020-06-02T05:40:16.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络架构拓扑结构"><a href="#网络架构拓扑结构" class="headerlink" title="网络架构拓扑结构"></a>网络架构拓扑结构</h2><p>   <img src="/images/p1.png" alt="实验拓扑结构"></p><p>   根据实验手册的规定，拓扑结构如上图：</p><p>   整个拓扑结构被划分为3个网段：10，11，12。其中10段为<u>路由器之间</u>的段，11段为<u>Router1与PCA之间</u>的段，12段为<u>Router2与PCB之间</u>的段。路由器为<strong>多端设备</strong>，因此<strong>每个端口都有一个IP地址</strong>；PC为单端设备，<u>只有一个IP地址</u>。</p><a id="more"></a><p>   根据实验的设置，整个结构包含三个网，网络地址分别为：</p><ul><li>10.0.0.0</li><li>11.0.0.0</li><li><p>12.0.0.0</p><p>三个地址对应三个网的划分。主机PCA想要到达PCB，途中必须经过两个路由器，vice versa。</p></li></ul><h2 id="路由器命令解释"><a href="#路由器命令解释" class="headerlink" title="路由器命令解释"></a>路由器命令解释</h2>   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sys# 进入系统设置模式</span><br><span class="line">sysnameRT1# 设置系统名字为RT1</span><br><span class="line">int e 0/0 # 进入以太网0号端口进行设置</span><br><span class="line">ip addr 10.0.0.1 24# 设置该端口(0号)IP地址为10.0.0.1，子网掩码包含24位</span><br><span class="line">(e 0/1 类似)</span><br><span class="line"></span><br><span class="line">display<span class="built_in"> ip </span>routing-table# 显示，IP协议的设置，路由表</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置静态路由，三个参数分别为：目标地址，子网掩码，下一跳地址</span></span><br><span class="line">ip route-static&lt;destinaton&gt; &lt;subnet mask&gt; &lt;nexthop&gt;</span><br><span class="line">ip route-static 10.0.0.0 255.255.255.0 10.0.0.2</span><br><span class="line"><span class="comment"># 去往10.0.0.0网路，子网掩码为3个255，需要的下一个路由为10.0.0.2</span></span><br><span class="line"></span><br><span class="line">undo <span class="built_in">..</span>. # 撤销某条命令</span><br></pre></td></tr></table></figure><h2 id="路由表状态解释"><a href="#路由表状态解释" class="headerlink" title="路由表状态解释"></a>路由表状态解释</h2>   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Destination/MaskProtocolPreCostNexthopInterface</span><br><span class="line">(目标地址)  协议下一跳网络接口</span><br><span class="line">需要前去的目标主机  路由协议   这两个不知道前往该主机， 对应的网口（或者回环）</span><br><span class="line"> 需要向哪个  回环就是自己</span><br><span class="line"> 端口发送数据</span><br></pre></td></tr></table></figure><p>   例如：</p>   <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span>Direct<span class="number">0</span><span class="number">0</span><span class="number">10.0</span><span class="number">.0</span><span class="number">.2</span>Ethernet0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line">前往<span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span>这个网，需要向<span class="number">10.0</span><span class="number">.0</span><span class="number">.2</span>发送数据。这个路由是接口直接连接得来的，所以协议为Direct（直接）</span><br></pre></td></tr></table></figure><p>   ![未命名文件 (3).png][1]</p><p>   因此，在这个拓扑内：</p><p>   <strong>PCA ping Router1是可以ping通的，在设置了PCA的IP地址后；Router1 对 Router2是可以ping通的，其他直连路亦然。</strong><u>因为他们直接连起来了。</u></p><p>   然鹅，PCA是不可以ping通PCB的，Router2也不可以ping通PCA的。R1同样ping不通PCB的。Why？这里就要解释一下ping的原理和路由的原理。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>   路由，route，意思是，路径，即从某点a到某点b的一条道路。路由包含了目标地址，下一跳地址。也就是说，以上面的为例子，<u>去往10.0.0.0这个网，路由器需要发往10.0.0.2这个地址。</u>也就是说，然鹅，在没有设置路由的情况下，PCB想要到PCA，它把包发给Router2，（因为只有一个口可以发出去），然鹅router2不知道该发给谁，<u>它就把包丢掉了</u>。所以设置之前，PCA和PCB是<strong>不互联</strong>的。</p><p>   在后续的实验步骤中，包含了设置路由的操作，目的就是告诉路由器，前往11，或者12这两个网段，需要把包发给谁。例如，在Router1设置：</p>   <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route-static <span class="number">12.0</span><span class="number">.0</span><span class="number">.0</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>   就是告诉路由器，若11段要前往12段，需要把数据包发给10.0.0.2这个口。子网掩码是为了确认两个网是平行的，不属于谁的子网。</p><p>   设置完这个选项后，当PCA发送包出去，发送给路由器时，路由器就会发送给10.0.0.2这个口。于是Router2就会把数据包根据目标地址，发出去了。于是乎PCA就可以到达PCB。</p><p>   在Router2的设置是类似的，为了让12段可以到达11段。</p><p>   然鹅，<strong>只设置一边是不可以ping通的</strong>。Why？这里解释一下ping的原理。</p><h2 id="ping-program"><a href="#ping-program" class="headerlink" title="ping program"></a>ping program</h2><p>   ping常用来检测路径的连通情况。需要<strong>双向可达</strong>，这样才可以ping通。这是因为ping利用的ICMP协议，ping的主机发送请求，被ping的主机收到请求后回复。至于ICMP是什么，超出了我们要讨论的范围。我们知道这是一种IP层协议，以及ping的过程需要主机向目标发送请求，目标返回一个信号。</p><p>   ping的工作过程如下：</p><p>   ping程序以目标IP为地址，发送一个ICMP包(echo request)。ICMP通过一定的路径，到达了目标。目标收到后，立刻返回一个信号(echo reply)。ping主机收到信号后，就确定，在两台主机之间，<strong>存在一条通路，可以从一端到达另一端。</strong>如果这个包在中途被丢掉了，不管是在哪儿丢的，最后ping的主机都无法收到回复，超出了一定的时间无法收到回复后，发送端便认为，<strong>目标不可达</strong>。</p><p>   ping的过程就是如此。若不存在一条路由，使得两端双向可达，哪怕存在链路，也是不可以ping通的。这就解释了为什么设置一端ping不通。假设ping的数据包从A主机发出，在Router1的指引下去到了Router2，然后Router2分发给了B。B立刻对A的地址进行回复，然鹅到了Router2后，Router2不知道发给谁，就把这个包视为非法包(invalid)，对其丢弃。因此B的回复永远到不了A，A就会超时，自然会不通了。</p><h2 id="设置过程"><a href="#设置过程" class="headerlink" title="设置过程"></a>设置过程</h2><ol><li><p>设置路由器端口IP、主机IP（略）</p></li><li><p>查看路由表（略）</p></li><li><p>第十步：添加静态路由。这里就是把路由器添加一条静态路由，目标网络为12.0.0.0，下一跳地址为10.0.0.2。回到上图，就是Router2的en0/0。因为对于路由器1，想要到达12网，就必须从10.0.0.2这个口进去。然后发生了什么，路由器1就不需要知道了。这样，一切从11段发出去的，以及路由器1发出去的，都会被发往10.0.0.2。</p></li><li><p>从PCA ping Router2的10.0.0.2以及ping PCB</p><p>这里，结论是，ping 10.0.0.2不可以通，PCB也通不了。原因是，Router2和Router1直接相连，因此Router1知道去往10段需要发给Router1的10.0.0.2口。因此，ping 10.0.0.2时，数据包从A主机跳到Router1，Router1查表，发现目标是router2的一个口，而且是直连的，就发出去了。router2的10.0.0.2收到后，立刻响应，然而路由2没有一条通往11段的记录，就无法把包回给11网段，因此被丢弃。ping B主机的原理类似，包到达Router1，Router1发给Router2，Router2分发给PCB，PCB回复，但Router2不知道发给谁，丢弃，A主机就永远收不到回复了。<strong>GG！</strong></p></li><li><p>在Router2添加一条到11段的路由</p><p>Router2添加完这条路由，跟上文阐述的类似，它就知道了去往11段是要发给10.0.0.1了。所以，从A主机ping B，或者Router2，当B主机或者Router2回复的时候，回复的数据包到了Router2，就被发往10.0.0.1。然后Router1收到，分发给自己或者A主机。收到请求，<strong>ping成功</strong>。</p></li><li><p>删除RT1添加的路由，添加默认路由</p><p>默认路由的意思是，当路由器找不到目标主机相应的下一跳，就会发给这个地址。例如，A发往B，经过路由器1，路由器1不知道发给谁，就发给默认的那个口。至于结果，路由器不管。</p><p>在这里，我们添加的路由是：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>  <span class="number">10.0</span><span class="number">.0</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>全0，代表任意IP地址，意思是，当找不到一条特殊约定的路由，就使用它。而由于默认路由的规定，发给了10.0.0.2。也就是说，找不到该发给谁，统统发给这个地址，10.0.0.2。</p><p>这样，第三次ping是可以ping通的。A发给了Router1，Router1找不到目标，发给了10.0.0.2，然鹅10.0.0.2就是我们要的目标，所以B可以收到，也可以回复。回复的数据包由于先前的设置，也会发回去。于是，ping成功。</p></li></ol><h2 id="一些其他的设置："><a href="#一些其他的设置：" class="headerlink" title="一些其他的设置："></a>一些其他的设置：</h2><ol><li>交换机与主机、路由器之间用直连线，路由器、主机之间用交叉线。交叉线就是两头线序不一样的线，比如棕色的那条，一个在一边，一个在另一边</li><li>设置交换机IP，也需要手动设置主机IP</li><li>从超级终端ping，是利用路由器ping出去。从cmd ping，才是从主机ping出去</li><li>交叉线不够，可以把直连线插交换机，交换机再接路由器，然后再从路由器连交换机，然后连路由器。（具体看操作吧，说不清楚了——）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络架构拓扑结构&quot;&gt;&lt;a href=&quot;#网络架构拓扑结构&quot; class=&quot;headerlink&quot; title=&quot;网络架构拓扑结构&quot;&gt;&lt;/a&gt;网络架构拓扑结构&lt;/h2&gt;&lt;p&gt;   &lt;img src=&quot;/images/p1.png&quot; alt=&quot;实验拓扑结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;   根据实验手册的规定，拓扑结构如上图：&lt;/p&gt;
&lt;p&gt;   整个拓扑结构被划分为3个网段：10，11，12。其中10段为&lt;u&gt;路由器之间&lt;/u&gt;的段，11段为&lt;u&gt;Router1与PCA之间&lt;/u&gt;的段，12段为&lt;u&gt;Router2与PCB之间&lt;/u&gt;的段。路由器为&lt;strong&gt;多端设备&lt;/strong&gt;，因此&lt;strong&gt;每个端口都有一个IP地址&lt;/strong&gt;；PC为单端设备，&lt;u&gt;只有一个IP地址&lt;/u&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="networking" scheme="https://blog.wxk.me/categories/networking/"/>
    
    
      <category term="lab" scheme="https://blog.wxk.me/tags/lab/"/>
    
      <category term="homework" scheme="https://blog.wxk.me/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>CS: APP CH5：编译器/处理器视角的程序优化</title>
    <link href="https://blog.wxk.me/2017/09/27/opt-program-perf/"/>
    <id>https://blog.wxk.me/2017/09/27/opt-program-perf/</id>
    <published>2017-09-27T02:16:13.000Z</published>
    <updated>2020-06-02T05:40:16.803Z</updated>
    
    <content type="html"><![CDATA[<h6 id="借banner以表达对MC的热爱。。。-￣▽￣"><a href="#借banner以表达对MC的热爱。。。-￣▽￣" class="headerlink" title="借banner以表达对MC的热爱。。。(￣▽￣)"></a>借banner以表达对MC的热爱。。。(￣▽￣)</h6><p>v0.1: initial commit<br>v0.1.1: 感谢小神师兄的提醒与指导！</p><hr><p><em>CS: APP</em> 第五章从编译器与处理器的角度，利用c语言实现，描述了程序通用的优化方法。这种通用的方法的度量因不同处理器而异，但策略是相似的。除开算法上的优化，基于机器的<strong>系数级</strong>优化是本章的重点。我们利用CPE(Cycle Per Element)来度量程序的执行效率，以4代 core i7-47x0 以及 GCC4.8.x 为样例机器，通过多种方式来对程序进行系数级优化。<br><a id="more"></a><br><a href="https://fs.wxk.es/f/096b4ca037f441fca236/?dl=1">没有书的同学点这里……</a>（第二版与第三版类似，尽管我们用的是第三版）</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;对程序进行系数级的优化，如书中所说，是一件非常magic的事情。有些看上去可能有所优化的东西，其实对程序并没有太大的影响；而有些微不足道的动作，可能就带来巨大的性能提升。因此，我们需要不断尝试，不断寻找最优解，最后判定优化的瓶颈在哪里。这是算法理论与实现细节的结合，需要多方面的寻找最佳的解决方案。<br>&emsp;&emsp;理解编译器与处理器的运行特点，从而进行程序优化是本章的主题。书中针对编译器与处理器两个方面提出了不同的解决方案。这两个方案在实践中同等重要，各自有不同的意义。通过对编译器动作的了解，我们可以了解哪里可以让编译器产生优秀的汇编指令，减少PC跳转，以及不必要的内存访问或其他操作，这种操作是不取决于机器种类的；通过对处理器的了解，我们可以减少数据依赖，以达到最大的数据平行计算(parallelism)，追求最高的运行速度。我们通过不断修改自己的代码，从而达到一个模块化与高效性之间的平衡。<br><img src="plot1.png" alt="Figure5.2 redux"></p><h2 id="程序效率的表达"><a href="#程序效率的表达" class="headerlink" title="程序效率的表达"></a>程序效率的表达</h2><p>&emsp;&emsp;由于程序效率跟处理数据的速度有关，对于程序的效率，书中用了“CPE”的单位来表达。即”Cycles per element”。取处理每个元素所需的处理器周期作为指标。通常，我们会取一组数字进行曲线拟合，获取一次多项式拟合的斜率作为衡量指标：CPE。(Figure5.2)<br>&emsp;&emsp;这里的周期，是指<strong>完成一个元素处理所需要的平均周期</strong>。在对这个元素进行处理的时候，需要的周期越短，速度就越快。<br>$$<br>CPE = \frac{cycles}{element}<br>$$<br>&emsp;&emsp;在图5.2中，psum1的CPE是9.0， psum2的是6.0。可见，面对不同的策略，显然效率有所不同。<br>&emsp;&emsp;这里的周期，是指<strong>完成一个元素处理所需要的平均周期</strong>。在对这个元素进行处理的时候，需要的周期越短，速度就越快。同时，衡量一个程序是否优化到瓶颈，还需要更多的衡量标准。现有的衡量标准，是在一定的CPU指标的基础上进行度量。我们的样例CPU(Core i7 4e)的性能进行分析也是如此。<br>度量的方法有：</p><ul><li>单位耗时(latency): 做连续同一种运算时，每次运算所需消耗的时间。</li><li>吞吐量极限(throuput bound): 跟CPU的吞吐能力有关</li><li>处理时间(issue time): 每条指令处理时间</li><li>处理容量(capability): 与CPU功能单元有关的能力</li></ul><p>例如：（单位：CPE）</p><table><thead><tr><th>op</th><th>Latency</th><th>Issue</th><th>capacity</th></tr></thead><tbody><tr><td>float addition</td><td>3</td><td>1</td><td>1</td></tr><tr><td>int addition</td><td>3</td><td>1</td><td>4</td></tr><tr><td>float multiplication</td><td>5</td><td>1</td><td>2</td></tr></tbody></table><p>这些指标跟CPU以及程序的运行状态息息相关，因为它们标志着处理器的能力极限。也就是说，越接近处理器本身的极限，程序优化得就越好。其中latency bound是一个常用的极限，然后throughput bound是最终得极限。<br>有了这样的基准之后，我们就可以测试程序的运行效率了。同时，在编译的时候<strong>我们开启 -O1 优化开关，利用优化前后的比较观察优化效果。</strong></p><h2 id="编译器视角的优化"><a href="#编译器视角的优化" class="headerlink" title="编译器视角的优化"></a>编译器视角的优化</h2><p>&emsp;&emsp;从编译器的视角优化，意思是写出能让编译器能产生更高效的汇编指令的代码。在这个层面上，我们就需要理解编译器所做的工作。</p><h4 id="编译器的能力与障碍"><a href="#编译器的能力与障碍" class="headerlink" title="编译器的能力与障碍"></a>编译器的能力与障碍</h4><p>&emsp;&emsp;现代编译器大多数情况下会用复杂的算法分析我们的代码并进行优化。同时，它通常附带有<code>-Og</code>,<code>-O1</code>等优化开关，允许我们决定优化的激进程度。这种编译编译器取决的优化工作我们很难进行处理。然而，许多工作都是原有的优化无法完成的，这些无法完成的工作称之为“优化障碍”( <em>optimization blockers</em> )。这种优化障碍在编译器层面是无可避免的，因为只它会在<strong>安全的基础上</strong>优化我们的代码，使其在汇编层面上更加高效。<br>for example:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span> </span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle2</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span> </span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显然，<code>twiddle1</code>相对于<code>twiddle2</code>低效，因为第一个进行了6次内存访存，第二个进行了3次。然编译编译器并不会把第一种优化成第二种，因为涉及到了内存别名(memory aliasing)问题。若第一次输入的参数为(xp, xp), 则两次运算都只是对xp进行操作。这样产生的效果，或副作用(side effact)就与<code>twiddle2</code>不一致。这种<strong>改变行为的优化，编译器不会做</strong>。<br>&emsp;&emsp;不仅如此，在函数调用方面，大多数编译器也不会判断一个函数是否造成了副作用。因此在优化的时候总是以最坏情况来做，即保留原有的函数调用。如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f()+ f()+ f()+ f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;编译器不会把第一种优化以达到第二种的效果，它会保留函数调用，每次触发就进行一次跳转，返回。因为它不会预测<code>f()</code>是否改变了什么。</p><p>&emsp;&emsp;不过，其中的一个小插曲是，尽管编译器通常有优化开关，例如在优化参数为<code>-O2</code>的甚至更高时候，编译器就会更加激进地修饰代码，但这样就提高了潜在的副作用上的风险。<br>&emsp;&emsp;举个书本外的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> count 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function">__inline__ <span class="keyword">uint64_t</span> <span class="title">perf_counter</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> lo, hi;</span><br><span class="line">    <span class="comment">// take time stamp counter, rdtscp does serialize by itself, and is much</span></span><br><span class="line">    <span class="comment">// cheaper than using CPUID</span></span><br><span class="line">    __asm__ __volatile__(<span class="string">"rdtscp"</span> : <span class="string">"=a"</span>(lo), <span class="string">"=d"</span>(hi));</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uint64_t</span>)lo) | (((<span class="keyword">uint64_t</span>)hi) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[count];</span><br><span class="line">    <span class="keyword">uint64_t</span> t1 = perf_counter();</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; count / <span class="number">3</span>) &#123;</span><br><span class="line">        a[<span class="number">3</span> * i - <span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">        a[<span class="number">3</span> * i - <span class="number">2</span>] = <span class="number">11</span>;</span><br><span class="line">        a[<span class="number">3</span> * i - <span class="number">1</span>] = <span class="number">111</span>;</span><br><span class="line">        a[<span class="number">3</span> * i] = <span class="number">121</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> t2 = perf_counter();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t2 - t1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个程序嵌入了一段汇编代码，以读取执行<code>while</code>循环前后的CPU周期差值。当默认优化或者为<code>-O1</code>的时候，程序正常输出周期差；但如果开启了<code>-O2</code>（在Apple clang 8.0.0 下），情况就不一样了。输出的并不是我们想要的结果。</p><p>&emsp;&emsp;鉴于此，我们就有在编译器层面上优化的思路了。</p><p>在书中我们多次使用了下面这个程序样本：这是一个向量的实现，效果类似于c++ STL里面的vector：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP *</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create vector of specified length */</span></span><br><span class="line"><span class="function">vec_ptr <span class="title">new_vec</span><span class="params">(<span class="keyword">long</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Retrieve vector element and store at dest */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_vec_element</span><span class="params">(vec_ptr v, <span class="keyword">long</span> index, <span class="keyword">data_t</span> *dest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return lenght of  */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">vec_length</span><span class="params">(vec_ptr v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine1</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; vec_length(v); i++) &#123;</span><br><span class="line">        <span class="keyword">data_t</span> val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<u>全章基本上都沿用这样的个例子的延伸，所以我们的阐述也围绕它进行。</u></p><p>在这里，我们可以做的工作有：</p><ul><li>优化循环效率</li><li>降低过程调用</li><li>去除不必要的内存访问</li></ul><p>这三项工作是相辅相成的，它们的结合才会有最优的结果。</p><h4 id="1-1-优化循环效率"><a href="#1-1-优化循环效率" class="headerlink" title="1.1 优化循环效率"></a>1.1 优化循环效率</h4><p>&emsp;&emsp;从<code>combine1</code>中我们不难观察到，对整个combine函数影响最大的是 for 循环。因为它是函数的功能主题。通过观测可以得到书本上的值：</p><table><thead><tr><th>Function</th><th>Page</th><th>Method</th><th>+ (int)</th><th>* (int)</th><th>+(float)</th><th>*  (float)</th></tr></thead><tbody><tr><td>combine1</td><td>507</td><td>-Og</td><td>22.68</td><td>20.02</td><td>19.98</td><td>20.18</td></tr><tr><td>combine1</td><td>507</td><td>-O1</td><td>10.12</td><td>10.12</td><td>10.17</td><td>11.14</td></tr></tbody></table><p>也就是说，combine1在开启O1的时候，CPE是10.12到11.17之间。但如果改变了循环的方式，就可以得到更好的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Retrieve vector element and store at dest.</span></span><br><span class="line"><span class="comment"> * Return 0 (out of bounds) or 1 (successful)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_vec_element</span><span class="params">(vec_ptr v, <span class="keyword">long</span> index, <span class="keyword">data_t</span> *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= v-&gt;len)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *dest = v-&gt;data[index];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Move call to vec_length out of loop */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine2</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> length = vec_length(v);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">data_t</span> val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种策略下，这个函数的CPE可以得到一定的提升。</p><table><thead><tr><th>Function</th><th>Page</th><th>Method</th><th>+ (int)</th><th>* (int)</th><th>+(float)</th><th>*  (float)</th></tr></thead><tbody><tr><td>combine1</td><td>507</td><td>-O1</td><td>10.12</td><td>10.12</td><td>10.17</td><td>11.14</td></tr><tr><td>combine2</td><td>509</td><td>Move vec_length</td><td>7.02</td><td>9.03</td><td>9.02</td><td>11.03</td></tr></tbody></table><p>这里的函数和<code>combine1()</code>明显不同的是，每次循环调用的<code>vec_length()</code>移到了外部。这是一种<strong>代码移动</strong>(code motion)工作，意图将循环无关变量<code>vec_length(v)</code>在外部进行初始化以达到优化效果，因而又称为<em>loop invariant code motion</em>。</p><blockquote><p>Loop-invariant code which has been hoisted out of a loop is executed less often, providing a speedup. We can therefore move the computation to an earlier section of the code that does not get evaluated as often. <a href="https://en.wikipedia.org/wiki/Loop-invariant_code_motion">wikipedia: Loop-invariant code motion</a></p><p><em>在这里感谢小神师兄的指正。此处因为代码移动而非代码修饰，修饰可以参阅ECMAScript 6的【修饰器】部分</em></p></blockquote><p>&emsp;&emsp;这种编译器因为可能的副作用问题不会而不会做的优化需要我们自己做。在此，就需要辨别一些循环中被计算多遍但却不会变的过程计算。第一个过程中，对于每次循环，都会调用一次<code>vec_length()</code> 函数。修改后的代码只调用了一次 <code>vec_length</code> 。这样，循环就减少了函数调用，去除了重复的长度计算，降低了耗时。</p><p>这种排除循环无关变量重复迭代的方法有时候效果是显著的。甚至极端情况下可以避免潜在的渐近时间复杂度提升。一个极端的例子：<br><code>string.h</code> 中有叫<code>strlen()</code>的函数，它通过遍历每一个字符来获取字符串的长度。如果我把函数调用放在循环里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]=<span class="string">"VeryGG!!!"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然看上去没毛病，但其实这里就已经有个潜在的 $O(n^2)$ 。因为<code>strlen()</code>的机制，每次循环都要遍历整个字符串，加上原始的 $O(n)$ ，那就成了一个<strong>指数渐进</strong>的循环。而<strong>这种低效对程序效率的影响是致命的，它会严重拉低程序的效率。</strong></p><p>&emsp;&emsp;两种循环的效率大概如下图：</p><p><img src="f5.2.png" alt="figure of origin loop and enhanced loop"></p><p>&emsp;&emsp;为何这样渺小的修改可以得到效率的提高呢？这就需要理解编译器的工作。编译器在编译第一个函数的时候，对于每次循环，都会调用一次 <code>vec_length()</code> 函数。修改后的代码只调用了一次 <code>vec_length</code> 函数。这样，循环就减少了函数调用，降低了耗时。<br>&emsp;&emsp;这种做法确实加快了运行速度。然而，这种代码移动并非编译器都会为开发者完成。因为修改前后可能面临着结果不同的问题，也就是副作用(site effact)问题。如果一个函数在优化前和优化后对于预料，或者说任何结果都是没有差异的，那优化就是有效的。但面对这种做法的时候，遇到指针别名问题(Pointer Aliasing)等问题时，结果是会出现差异的。尽管编译器试图采用代码移动，但局限性导致其采取了保守的策略。在优化参数为<code>-O2</code>的甚至更高时候，编译器就会更加激进移动代码，但这样就提高了潜在的副作用上的风险。</p><h4 id="降低过程调用"><a href="#降低过程调用" class="headerlink" title="降低过程调用"></a>降低过程调用</h4><p>降低过程调用的意图非常明显。过程调用中因常出现重复计算或检索问题(overhead)而导致低效。<br>例如下列过程调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get_vec_start */</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> *<span class="title">get_vec_start</span><span class="params">(vec_ptr v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Direct access to vector data */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine3</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">long</span> length = vec_length(v);</span><br><span class="line">    <span class="keyword">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    *dest = IDENT;  <span class="comment">// identical element</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        *dest = *dest OP data[i]; <span class="comment">// OP refer to + or *</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>combine3</code>的for 比<code>combine2</code>中的高效，因为<code>combine2</code>中每次检索数据都要将向量遍历一遍（成功或失败都类似）。此处通过将读取容器元素的过程改写为直接访问地址，从而降低过程调用，提高了效率。这种<strong>直接的地址访问</strong>降低了过程运行的成本。类似的降低过程调用的工作几近优化程序的瓶颈。</p><h4 id="1-3-减少内存访问"><a href="#1-3-减少内存访问" class="headerlink" title="1.3 减少内存访问"></a>1.3 减少内存访问</h4><p>&emsp;&emsp;内存访问的速度比寄存器访问慢很多，这是……正常人都知道的常识。减少内存访问，即利用临时(循环)变量来替代直接的指针迭代。如果每一次迭代都通过指针解引用来更改所指的数据，那即意味着每次都要从内存读取写入（这只是通用的直观的说法，更复杂的情况应该在处理器视角参数）。这样相对于直接的变量迭代效率一定是低下的。<br>&emsp;&emsp;有几种很常见的状况：</p><ul><li>指针作为迭代变量</li><li>指针搜索与位移</li></ul><p>&emsp;&emsp;在这里就不举例子了，自己意会哈～</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;通过了解编译器的能力与限制，我们就可以对症下药，而不是盲目地降低程序的可读性与模块化程度，给自己和他人的理解带来困扰，破坏软件工程的基本原则。在现代足够智能的编译器的情况下，认识到在这个视角能干什么显得非常必要。</p><h2 id="处理器视角的优化"><a href="#处理器视角的优化" class="headerlink" title="处理器视角的优化"></a>处理器视角的优化</h2><p>&emsp;&emsp;处理器视角优化，相对于前者而言，是在机器层面上的优化。不同的机器有不同的特点，所以要根据机器来处理细节。但是，在不失一般性的情况下，具有相似的策略。所以，我们就根据样本机器来分析。不同机器就要有细节上的修饰。<br>&emsp;&emsp;现代处理器和第四章的流水线模型也有很大的不同。现代乱序处理器更复杂。现代乱序处理器简单区分呢ICU（Instruction Control Unit）和EU（Executive Unit）。<br><img src="plot2.png" alt="out-of-order processor"><br>&emsp;&emsp;总的来说，现代CPU有能力超前地获取即将运行的数据与指令，并利用分支预测，进行提前演算，在分支语句被执行的时候决定是否运行、写入。存储与加载在cache存在的情况下，也有能力超前地fetch数据。在此其中，在数据处理的速度方面，最主要关系的就是EU中的功能单元——处理单一state的基础模块。一个CPU中可能有多个这样的模块，而这些模块能否最大化并行地运作，运作结果是否有效，很大程度上决定了程序能否高效运行。而数据能否在处理器层面并行地运算，又与数据的依赖程度有关。数据超前运算是否生效，又与分支预测的结果相关。因此，</p><ul><li>尽量在数据上降低依赖程度，实现并行处理的最大化，</li><li>降低分支预测错误概率，避免误判的时间高消耗，</li></ul><p>我们就有机会写出高效运行的代码。</p><p>&emsp;&emsp;我们在这一章节上的讨论，基于 Intel i7 Haswell 这一样本机器。它拥有8个功能单元，基本情况是：</p><ol start="0"><li>Integer arithmetic, floating-point multiplication, integer and floating-point division, branches</li><li>Integer arithmetic, floating-point addition, integer multiplication, floating-point multiplication</li><li>Load, address computation</li><li>Load, address computation</li><li>Store</li><li>Integer arithmetic</li><li>Integer arithmetic, branches</li><li>Store address computation</li></ol><p>在这样的情况下，可以实现的效果：</p><table><thead><tr><th>Operation</th><th>Latency</th><th>Issue</th><th>Capacity</th></tr></thead><tbody><tr><td>(integer)</td><td></td><td></td><td></td></tr><tr><td>Addition</td><td>1</td><td>1</td><td>4</td></tr><tr><td>Multiplication</td><td>3</td><td>1</td><td>1</td></tr><tr><td>Division</td><td>3-30</td><td>3-30</td><td>1</td></tr><tr><td>(floating point)</td><td></td><td></td><td></td></tr><tr><td>Addition</td><td>3</td><td>1</td><td>1</td></tr><tr><td>Multiplication</td><td>5</td><td>1</td><td>2</td></tr><tr><td>Capacity</td><td>3-15</td><td>3-15</td><td>1</td></tr></tbody></table><p>&emsp;&emsp;根据这样详细的定义，排除cache方面可能的干扰，我们就可以在样本机上量化计算了。</p><p>书中对于降低依赖程度有如下方法：</p><ul><li>循环解元(loop unrolling)</li><li>提高平行性(enhancing Parallelism)</li></ul><p>对于降低跳转误判概率，解释比较简略，即<strong>尽量让编译器生成<code>CMOV</code>的代码，而不是<code>JMP</code></strong>。</p><p>在此之前，我们要有一定的语言与方法来判断数据（指令）的依赖性，以及指令的执行流程。因此运用了数据流程图(Data-flow graph)这么个方法解释。如，对于书中的combine4，汇编的结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">combine4: data_t = float, OP = *</span><br><span class="line">i in %rdx, data in %rax, limit in %rbp, acc in %xmm0</span><br><span class="line">.L488:</span><br><span class="line">  mulss  (%rax, %rdx, 4), %xmm0   # Multiply acc by data[i]</span><br><span class="line">  addq   $1, %rdx                 # Increment i</span><br><span class="line">  cmpq   %rd, %rbp                # Compare limit:i</span><br><span class="line">  jg     .L488                    # If &gt;, goto loop</span><br></pre></td></tr></table></figure></p><p>得到的data-flow graph为：<br>![屏幕快照 2017-11-03 下午10.12.35.png][5]<br>经过重新编排，我们就可以知晓数据之间的依赖性。<br>![20171103.png][6]<br>所以在这个函数里头，load-&gt;mul是一条主要时间线，这一次迭代的主要影响就跟乘法相关。</p><p>在这样的语言表示下，我们就有办法解释为什么循环解元与平行增强对程序起优化作用了。</p><h5 id="循环解元-loop-unrolling"><a href="#循环解元-loop-unrolling" class="headerlink" title="循环解元(loop unrolling)"></a>循环解元(loop unrolling)</h5><p>&emsp;&emsp;loop unrolling的思路是，<strong>通过在计算上的分步运行并最终合并结果，实现提高一次循环中CPE的效果</strong>。简而言之，就是将一次循环所能做的元素修改提高。其实在这个方法上与增强平行性是相辅相成的，因为分开进行运算意味着更充分地使用了有效的function unit。</p><p>举个🌰：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, acc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        acc += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种情况下，效率是1x线性的，因为每次处理一个元素。稍加修饰，就可以变得约为2倍。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> arr[n])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> it = n / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> i, acc = <span class="number">0</span>, acc1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; it; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        acc += arr[i];</span><br><span class="line">        acc1 += arr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; n; i++) &#123;</span><br><span class="line">    acc += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc + acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样的代码修饰，实现了<strong>一次迭代中并行地处理2个数据</strong>。因为<code>acc</code>与<code>acc1</code>没有耦合，处理器可以并行地进行计算。如此修改，提高了处理单元上的并行性，因为样本机器一次可处理的4个加法，大于目前的所需并行计算数目，速度约为原来的2x。然这种k-degree并非越大越好，因为unrolling后如果degree太高，会产生加载、计算上的等待，造成debuff。</p><h4 id="依赖解绑"><a href="#依赖解绑" class="headerlink" title="依赖解绑"></a>依赖解绑</h4><p>&emsp;&emsp;依赖解绑的意思是，可以分开算的数据，就不要使其出现依赖关系。因为一旦没有依赖，可以并行地计算。for example，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcu</span><span class="params">(<span class="keyword">int</span> arr1[n], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> acc = arr1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        tmp *= x;</span><br><span class="line">        acc += arr[i] * tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是经典的输入一个多项式以及x，输出运算结果的函数。它没有经过解元的操作，以便我们的讲解。因此，它的效率是较为一般的。然而，另一种，依据秦九韶算法:</p><p>$$<br>a_0 + x(a_1 + x(a_2+…+ x(a_{n-1} + xa_n)…))<br>$$<br>即：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcu1</span><span class="params">(<span class="keyword">int</span> arr1[n], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// int tmp = x;</span></span><br><span class="line">    <span class="keyword">int</span> acc = arr1[n];</span><br><span class="line">    <span class="keyword">for</span> ( i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        acc = arr1[i] + x * acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这种写法是及其低效的！</strong>现代处理器在cache的帮助下，可以在上一次循环的时候就加载下一次循环中所需要的数据；而修改后的代码<u>每一次的运算都基于上一次的结果，产生了一个<em>load-use</em> dependency; 而前一个函数中，<code>tmp</code> 和 <code>acc</code> 是独立开来的，他们的运算是并行的，而且每次算好只要加载进入下一次循环即可立即使用。</u>。这样，就会把load的时间插在了use的前面，而不是独立开来。也就是说：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">改变之前：(运行时间）</span><br><span class="line">+-----+ +----+</span><br><span class="line">|<span class="string"> cal </span>|<span class="string"> </span>|<span class="string"> ld </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> +----+</span></span><br><span class="line">|<span class="string">     </span>|<span class="string"> +----+</span></span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string"> ld </span>|</span><br><span class="line">+-----+ |<span class="string">    </span>|</span><br><span class="line">+-----+ |<span class="string">    </span>|</span><br><span class="line">|<span class="string"> cal </span>|<span class="string"> +----+</span></span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">+-----+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改变之后：(运行时间）</span><br><span class="line">+-----+</span><br><span class="line">|<span class="string"> cal </span>|</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">+-----+</span><br><span class="line">+-----+</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">|<span class="string">  ld </span>|</span><br><span class="line">|<span class="string">     </span>|</span><br><span class="line">+-----+</span><br></pre></td></tr></table></figure></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  ||<span class="string">        arr[n]      x</span></span><br><span class="line"><span class="string">  </span>||<span class="string">         </span>||<span class="string">        </span>|<span class="string"> </span>|</span><br><span class="line">+-----+  +--------+  +-----+</span><br><span class="line">|<span class="string"> acc </span>|<span class="string">  </span>|<span class="string"> arr[n] </span>|<span class="string">  </span>|<span class="string">  x  </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string">  </span>|<span class="string"> (load) </span>|<span class="string">  </span>|<span class="string">     </span>|</span><br><span class="line">+-----+  +--------+  +-----+</span><br><span class="line">  ||<span class="string">         </span>||<span class="string">________</span>|<span class="string"> </span>|</span><br><span class="line">  ||<span class="string">         </span>|<span class="string">___________</span>|</span><br><span class="line">  ||<span class="string">               </span>||<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">  ||<span class="string">_____(calcu)___</span>||<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">  |<span class="string">_________________</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">  ||<span class="string">                   </span>|<span class="string"> </span>|</span><br><span class="line">  ||<span class="string">                   </span>|<span class="string"> </span>|</span><br><span class="line">+-----+  +--------+  +-----+</span><br><span class="line">|<span class="string"> acc </span>|<span class="string">  </span>|<span class="string"> arr[n] </span>|<span class="string">  </span>|<span class="string">  x  </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string">  </span>|<span class="string"> (load) </span>|<span class="string">  </span>|<span class="string">     </span>|</span><br><span class="line">+-----+  +--------+  +-----+</span><br></pre></td></tr></table></figure><p>load-use独立开来，时间就取决于use，而不是 load + use。这就是高效之处。<br><strong>由此可知，上述两种方法相互依赖。结合使用，才能有效地进行系数级别的优化。</strong></p><h4 id="减少跳转"><a href="#减少跳转" class="headerlink" title="减少跳转"></a>减少跳转</h4><p>&emsp;&emsp;减少跳转的关键在于，使得代码尽量使用<code>CMOV</code>, 而不是<code>JMP</code>。因为JMP涉及了PC更改以及预运算清空问题，产生了时延（参考第4章中PIPE的实现）。例如，可以用三目运算符处理的，不用<code>if...else</code>；尽量用inline等。现代处理器已经可以90%做出准确判断，例如循环的实现，不必产生任何跳转。只有在循环结束、条件函数调用的时候，才可能产生跳转。因此，这方面我们能做的比较少。</p><h2 id="优化的限制因素"><a href="#优化的限制因素" class="headerlink" title="优化的限制因素"></a>优化的限制因素</h2><h4 id="寄存器个数限制"><a href="#寄存器个数限制" class="headerlink" title="寄存器个数限制"></a>寄存器个数限制</h4><p>&emsp;&emsp;寄存器的个数决定了一次可以load的数量。一旦 loop unrolling 过度，超过了寄存器可以承载的数量，就会产生penalties。这个比较好理解。</p><h4 id="跳转问题"><a href="#跳转问题" class="headerlink" title="跳转问题"></a>跳转问题</h4><p>&emsp;&emsp;跳转问题通常无法解决，因为取决于处理器的算法问题。但我们可以尽量使得其产生CMOV的代码，处理器会分别计算然后加载所需要的数值。这样就免除了跳转中产生的时延。</p><h2 id="未竟之处"><a href="#未竟之处" class="headerlink" title="未竟之处"></a>未竟之处</h2><p>书本对优化的阐述依然留下了一些问题。例如，我们假设处理器是单核的，而现代处理器一般都有多核运行；同时，也没有考虑多线程、多进程问题。然在我们阐述的模型基础上，我们可以预测可以做到的更多的操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;<em>CS:APP</em> 第5章根据编译器和处理器的特性，描述了一个完整的程序优化蓝图。现代的编译器已经足够智能，善于尽可能地产生最优的代码；现代处理器也同样如此，会尽量地跑满所有的功能单元。而我们需要做的，就是完成编译器、处理器无法完成的工作，解决数据搜寻中的低效问题，解绑数据依赖，从而让机器能够在数据安全的情况下，在 function unit 层面上并行地计算。如此针对性地进行优化，而不是做类似于 <code>i / 2</code> 改成 <code>i &gt;&gt; 2</code> ，以及将函数融合到一起之类的的动作，我们就可以在尽量不降低程序模块与可读性上，真正达到优化的目的，而不是既没有提高效率，又使得代码不必要地丑陋。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;借banner以表达对MC的热爱。。。-￣▽￣&quot;&gt;&lt;a href=&quot;#借banner以表达对MC的热爱。。。-￣▽￣&quot; class=&quot;headerlink&quot; title=&quot;借banner以表达对MC的热爱。。。(￣▽￣)&quot;&gt;&lt;/a&gt;借banner以表达对MC的热爱。。。(￣▽￣)&lt;/h6&gt;&lt;p&gt;v0.1: initial commit&lt;br&gt;v0.1.1: 感谢小神师兄的提醒与指导！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;CS: APP&lt;/em&gt; 第五章从编译器与处理器的角度，利用c语言实现，描述了程序通用的优化方法。这种通用的方法的度量因不同处理器而异，但策略是相似的。除开算法上的优化，基于机器的&lt;strong&gt;系数级&lt;/strong&gt;优化是本章的重点。我们利用CPE(Cycle Per Element)来度量程序的执行效率，以4代 core i7-47x0 以及 GCC4.8.x 为样例机器，通过多种方式来对程序进行系数级优化。&lt;br&gt;
    
    </summary>
    
    
      <category term="CS:APP" scheme="https://blog.wxk.me/categories/CS-APP/"/>
    
    
      <category term="computer system" scheme="https://blog.wxk.me/tags/computer-system/"/>
    
  </entry>
  
  <entry>
    <title>坐标地址拾取器</title>
    <link href="https://blog.wxk.me/2017/09/22/lla/"/>
    <id>https://blog.wxk.me/2017/09/22/lla/</id>
    <published>2017-09-22T01:04:18.000Z</published>
    <updated>2020-06-02T05:40:16.801Z</updated>
    
    <content type="html"><![CDATA[<p>国赛模就这样愉快地结束了，用了一大堆的工具和语言。做了很多繁琐的工作。从C语言到R到Matlab，做了不少图。</p><p>其中有一个很有意思的东西，利用百度地图的坐标拾取系统获取经纬度对应的地址。是一个被爬取出来的地图API。</p><blockquote><p><a href="http://api.map.baidu.com/?qt=rgc&amp;x=13407612.87&amp;y=3550364.78&amp;dis_poi=1">http://api.map.baidu.com/?qt=rgc&amp;x=13407612.87&amp;y=3550364.78&amp;dis_poi=1</a><br><a id="more"></a><br>参考<a href="http://www.saitjr.com/uncategorized/baidu-location-picker-interface.html">saitjr</a>的博客获取的消息，将经纬度坐标转换成墨卡托坐标，然后向百度发请求，就可以get到了具体的地理位置了。</p></blockquote><p>然后呢，我给它套了个壳。以方便快捷地使用。不过还是有点害怕。万一appending mode把别人的文档搞坏了呢。。（逃</p><p><a href="https://coding.net/u/ping1008/p/lla/git">仓库在这里～</a> （开发完成。。。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国赛模就这样愉快地结束了，用了一大堆的工具和语言。做了很多繁琐的工作。从C语言到R到Matlab，做了不少图。&lt;/p&gt;
&lt;p&gt;其中有一个很有意思的东西，利用百度地图的坐标拾取系统获取经纬度对应的地址。是一个被爬取出来的地图API。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://api.map.baidu.com/?qt=rgc&amp;amp;x=13407612.87&amp;amp;y=3550364.78&amp;amp;dis_poi=1&quot;&gt;http://api.map.baidu.com/?qt=rgc&amp;amp;x=13407612.87&amp;amp;y=3550364.78&amp;amp;dis_poi=1&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.wxk.me/categories/python/"/>
    
    
      <category term="坐标拾取" scheme="https://blog.wxk.me/tags/%E5%9D%90%E6%A0%87%E6%8B%BE%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>Class Stuff</title>
    <link href="https://blog.wxk.me/2017/09/07/class-stuff/"/>
    <id>https://blog.wxk.me/2017/09/07/class-stuff/</id>
    <published>2017-09-07T00:39:52.000Z</published>
    <updated>2020-06-02T05:40:16.797Z</updated>
    
    <content type="html"><![CDATA[<h6 id="emsp-emsp-这个学期教我们离散的是Yjj"><a href="#emsp-emsp-这个学期教我们离散的是Yjj" class="headerlink" title="&emsp;&emsp;这个学期教我们离散的是Yjj."></a>&emsp;&emsp;这个学期教我们离散的<strong>是Yjj</strong>.</h6><p>&emsp;&emsp;</p><ul><li><a href="https://fs.wxk.es/d/f85ff48bb23a48d3972f/">陈寅老师的ppt</a> (psw: ClassStuff)</li><li>如果你有什么好的资料，欢迎发到<strong><a href="https://fs.wxk.es/u/d/46db83cce0f9419faed3/">这里</a></strong>来</li></ul><p>（继续愉快地念屁屁踢）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;emsp-emsp-这个学期教我们离散的是Yjj&quot;&gt;&lt;a href=&quot;#emsp-emsp-这个学期教我们离散的是Yjj&quot; class=&quot;headerlink&quot; title=&quot;&amp;emsp;&amp;emsp;这个学期教我们离散的是Yjj.&quot;&gt;&lt;/a&gt;&amp;emsp;&amp;emsp
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
